# Triadic First-Order Logic Queries in Temporal Networks

Omkar Bhalerao University of California, Santa Cruz Santa Cruz, USA obhalera@ucsc.edu

C. Seshadhri University of California, Santa Cruz Santa Cruz, USA sesh@ucsc.edu

# Abstract

Motif counting is a fundamental problem in network analysis, and there is a rich literature of theoretical and applied algorithms for this problem. Given a large input network , a motif is a small "pattern" graph indicative of special local structure. Motif/pattern mining involves finding all matches of this pattern in the input . The simplest, yet challenging, case of motif counting is when has three vertices, often called a triadic query. Recent work has focused on temporal graph mining, where the network has edges with timestamps (and directions) and has time constraints. Such networks are common representations for communication networks, citation networks, financial transactions, etc.

Inspired by concepts in logic and database theory, we introduce the study of thresholded First Order Logic (FOL) Motif Analysis for massive temporal networks. A typical triadic motif query asks for the existence of three vertices that form a desired temporal pattern. An FOL motif query is obtained by having both existential and thresholded universal quantifiers. This allows for a query semantics that can mine richer information from networks. A typical triadic query would be "find all triples of vertices, , such that they form a triangle within one hour". A thresholded FOL query can express "find all pairs , such that for half of where (,) formed an edge, (,) also formed an edge within an hour".

We design the first algorithm, FOLTY, for mining thresholded FOL triadic queries. The theoretical running time of FOLTY matches the best known running time for temporal triangle counting in sparse graphs. Specifically, FOLTY runs in time ( log max). Here, is the number of temporal edges in the input graph, is the maximum core number (degeneracy), and max is the maximum edge multiplicity. We give an efficient implementation of FOLTY using specialized temporal data structures. FOLTY has excellent empirical behavior, and can answer triadic FOL queries on graphs with nearly 70M edges is less than hour on commodity hardware. Our work has the potential to start a new research direction in the classic well-studied problem of motif analysis.

Yunjie Pan University of Michigan, Ann Arbor Ann Arbor, USA panyj@umic.edu

Nishil Talati University of Michigan, Ann Arbor Ann Arbor, USA talatin@umich.edu

# CCS Concepts

• Theory of computation → Graph algorithms analysis; • Information Systems → Data Mining;Social Networks.

# Keywords

Motif counting, temporal network, First Order Logic, subgraph counting, triangle counting

#### ACM Reference Format:

Omkar Bhalerao, Yunjie Pan, C. Seshadhri, and Nishil Talati. 2018. Triadic First-Order Logic Queries in Temporal Networks. In Proceedings of Make sure to enter the correct conference title from your rights confirmation email (Conference acronym 'XX). ACM, New York, NY, USA, [18](#page-17-0) pages. [https://doi.](https://doi.org/XXXXXXX.XXXXXXX) [org/XXXXXXX.XXXXXXX](https://doi.org/XXXXXXX.XXXXXXX)

# 1 Introduction

Triangle counting is a fundamental problem in network analysis, that has been extensively studied in the literature [\[2,](#page-11-0) [17,](#page-12-0) [18,](#page-12-1) [20,](#page-12-2) [21,](#page-12-3) [24,](#page-12-4) [40,](#page-12-5) [41,](#page-12-6) [47,](#page-12-7) [48,](#page-12-8) [54,](#page-12-9) [56,](#page-13-0) [60\]](#page-13-1). This problem has found many applications in network analysis [\[19\]](#page-12-10), synthetic graph generation [\[46\]](#page-12-11), indexing graph databases [\[23\]](#page-12-12), and discovering communities [\[18,](#page-12-1) [36\]](#page-12-13). Many real-world networks are temporal, meaning that edges have timestamps. For instance, consider the financial network of a bank, in which the nodes represent bank accounts, and directed edges represent transfer of money between accounts [\[10,](#page-11-1) [13,](#page-12-14) [25\]](#page-12-15). Over the past few years, there has been research on defining and counting temporal motifs, which incorporate time and ordering constraints on edges [\[12,](#page-12-16) [25](#page-12-15)[–27,](#page-12-17) [31,](#page-12-18) [38,](#page-12-19) [50–](#page-12-20)[52\]](#page-12-21). Temporal triangle/motif counts have proven to be useful in a multitude of applications such as network classification [\[55\]](#page-12-22), temporal text network analysis [\[57\]](#page-13-2), analyzing financial networks [\[16,](#page-12-23) [29\]](#page-12-24), etc.

Motif (especially triangle) counting is an extremely powerful technique in graph mining. Yet, it is unable to capture richer patterns such as the following. Suppose we want to find edges (, ) of the network where: whenever makes a transaction to , then makes a transaction to within an hour. Clearly, this is related to triangles involving , ,, but observe that is not a fixed vertex. How can we express such richer patterns in terms of motifs?

# 1.1 First Order Logic Motifs

We take inspiration from the concept of First Order Logic (FOL) statements in logic and database theory. The study of this concept is ubiquitous in database theory and parameterized graph theory [\[1,](#page-11-2) [5,](#page-11-3) [7,](#page-11-4) [11,](#page-12-25) [14\]](#page-12-26), logic and designing AI expert systems [\[33,](#page-12-27) [35,](#page-12-28) [42\]](#page-12-29).

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.

Conference acronym 'XX, Woodstock, NY

<sup>©</sup> 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM. ACM ISBN 978-1-4503-XXXX-X/2018/06 <https://doi.org/XXXXXXX.XXXXXXX>

<span id="page-1-0"></span>![](_page_1_Figure_1.jpeg)

![](_page_1_Figure_2.jpeg)

terns in Financial Transaction Networks [\[4,](#page-11-5) [29\]](#page-12-24)

In the language of FOL, a motif (say, a triangle) query is an existential FOL statement. We are asking: do there exist vertices , and such that the (, ,) forms a triangle, maybe satisfying certain temporal constraints? In mathematical language, we would write ∃ ∃ ∃ (, ,), where (, ,) is a Boolean predicate stating that there are edges among , , forming a triangle with the desired constraints. (A temporal motif would enforce some timestamp conditions in (, ,).) The motif counting problem is to count all possible solutions to the FOL statement.

A general FOL statement would involve both existential and universal quantifiers. For example, the FOL statement ∃ ∃ ∀ (, ,) could express the query: do there exist vertices , such that for all neighbors of , (, ,) form a triangle? With a more complex predicate , we can even express: do there exist , such that for all neighbors where (,) is an edge, (, ) is an edge that formed within 10 minutes? As we discuss later, we also include thresholded universal quantifiers, which represent "for at least a -fraction of neighbors" (for parameter ).

There are applications for analysis of financial transaction networks. Recent work of Liu et al. [\[29\]](#page-12-24) on the Venmo transaction network discovered that the temporal triangle in Figure[-1](#page-1-0) is a likely indication of gambling activities. An FOL query can determine if there are edges (, ) such that most neighbors of participate in such triangles. As another example, consider the two patterns, denoted "Scatter-Gather" and "Bipartite" in Figure[-1.](#page-1-0) Altman et al. discovered these patterns as signs of money laundering in financial networks [\[4\]](#page-11-5). Often the yellow nodes are individuals, and the blue nodes are fake or laundering accounts. The challenge of representing these as motifs is that the number of blue nodes is unknown, so we may not know the size of the motif.

The Scatter-Gather pattern is easily captured as a triadic FOL query: are there vertices , such that for (say) most where (,) is a transaction, the transaction (, ) occurs within (say) a few days? Observe how we apply a thresholded universal quantifier

over to capture the intermediate blue nodes, so we do not need to specify their number. A similar FOL query captures the Bipartite money laundering pattern.

In addition, solutions to these queries can be used to discover edges, which participate in a cohesive group of vertices in . For instance, in a citation network [\[53\]](#page-12-30) where nodes represent papers and edges (, ) indicate that paper cites paper , we assign each edge the timestamp of . Next, we run the ∃∃∀ query on this dataset for = 1 year, list all the edges which satisfy this query, along with their common neighbors. We observe that these vertices correspond to research papers, which were either published in the same journal or are on related topics. For instance, the temporal edge between the paper tiled "Virtual Memory,ACM Computing Surveys (CSUR)"() and "Measurements of segment size"() served as a solution to this query. The common neighbours of this edge were papers titled:

- (1) "Dynamic storage allocation systems"
- (2) "Further experimental data on the behavior of programs in a paging environment"
- (3) "The working set model for program behavior"
- (4) "A note on storage fragmentation and program segmentation"

Out of these 6 papers, 5 were published in "Communications of ACM", except for the paper titled "Virtual Memory", which was published in "ACM Computing Surveys". Thus, the set {} ∪ { } ∪ { () ∩ ()} for any solution = (, , ) to the ∃∃∀ query could potentially form a cohesive set of vertices.

Motivated by these applications, we ask:

Can we give a formalism for thresholded FOL motif queries on temporal networks, and design efficient algorithms for answering such queries?

### 1.2 Formal Definition

Let = ( , ) be a temporal network. Every edge in is represented as a triple (, , ), where is the head, is the destination, and is the edge timestamp. Note that is a multigraph, since there can be many temporal edges (in both directions) between a pair of vertices. We define our main query below. We use the definitions of temporal motifs from [\[37](#page-12-31)[–39\]](#page-12-32).

<span id="page-1-1"></span>Definition 1.1. A thresholded First Order Logic (FOL) triadic query is an expression1 2 3 (, ,) where each is either ∃ (existential quantifier) or ∀ , for parameter ∈ (0, 1) (thresholded universal quantifier).

An ∃ . . . quantifier is satisfied if there exists some in the universe (vertex set) satisfying the remaining sentence. A ∀ quantifier is satisfied if for at least a -fraction of the universe, the remaining sentence is satisfied. Typically, the universe for a ∀ quantifier is the neighborhood of a previous vertex.

The Boolean predicate (, ,) represents a temporal motif on the vertices , ,. A temporal motif specifies the direction of edges in , ,, the time ordering of edges, and an upper bound on the time interval containing these edges.

To give a concrete example, consider the following query: ∃ ∃ ∀1/2 ∈ (), (, ,) form the triangle of Figure[-1c](#page-1-0) within one hour. A solution to this query is pair (, ) of adjacent vertices, which form a triangle (, ,) with at least half of 's neighbors

<span id="page-2-0"></span>

![](_page_2_Figure_1.jpeg)

(c) Example of a nonsolution for ∃∃∀ query

Figure 2: Consider the query ∃ ∃ ∀ ∈ (), the edges (, ), (,), and (,) occur within 20 timesteps. In the left figure, the edge (, ) is a solution. In the right figure, it is not a solution. Triangle (, , ) violations the timestamp constraint, while triangle (, ,) violates the directions.

. In each of these triangles, the edge (, ) appears first, followed by the edge (,) and finally the edge (, ). Further, all three edges occur within an hour of each other. What this means is that there exist temporal edges <sup>1</sup> = (, , 1), <sup>2</sup> = (,, 2) and <sup>3</sup> = (,, 3) such that the triangle (1, 2, 3) is an instance of the temporal motif specified in the predicate . In this case, predicate is given by the gambling triangle in Figure[-1c.](#page-1-0) Therefore, for a pair (, ) to be solution to this query, there must exist a temporal edge = (, , ) that forms an instance of the gambling triangle with at least half of's neighbors. In this case, we can say that the temporal edge = (, , ) certifies that the pair (, ) is indeed a solution to the given ∃ ∃ ∀1/2 ∈ () query. In this work, we develop algorithms, which allow us to enumerate all certificates to an ∃∃∀ query i.e. instead of just one, we find all temporal edges on (, ) that satisfy the input predicate. We will often refer to a certificate = (, , ) as a solution to the ∃∃∀ query.

As another example, consider the following query: ∃ ∀1/<sup>2</sup> ∈ () ∀1/<sup>3</sup> ∈ (), edge (, ) appears first, then edge (,), and finally edge (,), and all occur in 40 minutes. (The predicate (, ,) is the entire sentence after the quantifiers.) This means that we are looking for a vertex such that for at least half of its neighbors , at least one third of the neighbors of form the desired triangle specified. In particular, for at least half of 's neighbors , there exists a temporal edge = (, , ) such that forms the desired temporal triangle with a third of 's neighbors . So, for at least a one-third neighbors of , contains temporal edges <sup>2</sup> = (,, 2) and <sup>3</sup> = (,, 3) such that ≤ <sup>2</sup> ≤ <sup>3</sup> ≤ +, where is 40 mins.

Observe that thresholded FOL queries provide rich semantics for pattern mining in graphs. While we typically consider the universe for with the last quantifier as the neighborhood of the previous vertex, similar techniques can be developed for cases in which the universe happens to be, say the intersection of the neighborhoods of the previous two vertices.

It is straightforward to define the notion of a solution to the thresholded FOL query. Figure[-2](#page-2-0) gives an example.

<span id="page-2-1"></span>Definition 1.2. The solution to the FOL query1 2 3 (, ,) is the set of vertices whose assignment to the prefix of existential quantiers makes the statement true.

Specifically, for ∃ ∃∃ queries, a solution is a triple of vertices. For ∃ ∃∀, a solution is a pair (, ). For ∃ ∀ ∀ and ∃ ∀ ∃ queries, a solution is a single vertex.

We do not consider queries that begin with a universal quantifier, since there is no notion of a solution. (Using negation and de Morgan's laws, one can convert it to one of the queries in definition[-1.2.](#page-2-1)) Thus, we have four kinds of thresholded FOL queries, denoted as ∃∃∃, ∃∃∀, ∃∀∃, and ∃∀∀. The meaning of these should be clear from the above definition.

We now come to the main computational problem. Given a thresholded FOL query, we wish to count and enumerate the number of solutions of these queries. As explained earlier, in the case of ∃∃∃ queries, this is simply the problem of temporal triangle counting. In this work, we focus on Triadic Queries i.e. FOL queries, in which predicate is a temporal triangle. The main technical question we resolve is the following.

Is there an efficient algorithm to count/enumerate solutions of a thresholded FOL triadic query, whose theoretical running time is comparable to the best temporal triangle counters?

In this paper, we present our techniques by taking the example of the predicate, which is given by the temporal triangle of Figure[-2a.](#page-2-0) However, our techniques can be generalized to deal with alternate temporal triangles as well.

# 1.3 Contributions

Our main result is a theoretical algorithm, First Order Logic Triadic Yielder (FOLTY), that can exactly compute and enumerate the number of solutions to any thresholded FOL triadic query. As we explain below, the running time matches the best known temporal triangle counter [\[39\]](#page-12-32), based on the best possible complexity known for triangle counting [\[8\]](#page-11-6). We give an efficient, practical implementation of FOLTY that can process temporal graphs with tens of millions of edges. We list out the important contributions of our work.

Defining thresholded FOL queries. To the best of our knowledge, this is the first work that sets up the notion of thresholded FOL queries for temporal networks. While the notion of FOL queries for databases has been studied before [\[15,](#page-12-33) [22\]](#page-12-34), there is no work in the data mining literature that sets up the problems given in [1.1](#page-1-1) and [1.2.](#page-2-1) We believe that these definitions set up a new research direction in motif analysis. This work also initiates the use of orientation-based methods for analyzing first-order logic (FOL) queries on attributed networks, a question which was posed in [\[45\]](#page-12-35).

An algorithm with provable runtime guarantees. FOLTY has the best possible theoretical running time up to log factors, assuming the forty year old bound of Chiba-Nishizeki for sparse triangle counting [\[8\]](#page-11-6). We prove that FOLTY also has a running time

<span id="page-3-0"></span>![](_page_3_Figure_2.jpeg)

(a) ∃∃∀, for Venmo Network (b) ∃∀∃, for Venmo Network.

Figure 3: We apply FOLTY to the Venmo transaction Network in [\[29\]](#page-12-24). We compute solutions for the ∃ ∃ ∀ and ∃ ∀ ∃, where the triangle is (, ), (,), (,) (see Figure-[2a\)](#page-2-0). The threshold is varied on the -axis. The time interval is denoted by DELTA, and is varied to get different trends.

of ( log max), where is the number of temporal edges, is the maximum core number (degeneracy), and max is the maximum multiplicity (number of parallel edges). This is the same running time of the best temporal triangle counters [\[39\]](#page-12-32). Up to log factors, this matches the forty year old Chiba-Nishizeki () bound for triangle counting [\[8\]](#page-11-6).

We achieve this bound by a combination of orientation techniques of triangle counting, combined with specially constructed temporal data structures. One of our novelties is the use of segment trees, an efficient data structure to process intervals. FOLTY combines segment trees and degeneracy orientations to achieve its running time. This gives the log max dependence, as opposed to a linear dependence by enumeration methods. We note that FOLTY gets the solutions to a query without enumerating all temporal triangles.

Unified frameworks to deal with FOL Queries. As mentioned earlier, there are four kinds of FOL queries. We show how to efficiently reduce ∃∀∀ and ∃∀∃ to ∃∃∀ queries. This gives a unified algorithm for solving FOL queries. We also show how to deal with thresholded universal queries efficiently, without enumerating entire lists of temporal edges.

Excellent empirical performance: We empirically evaluate the performance of FOLTY on a wide range of temporal graph datasets and various FOL queries. We conduct multiple experiments with varying values of thresholded quantifiers and time intervals. We observe that FOLTY works well, taking less than 20 mins. on networks with nearly 65M edges. Our algorithm for ∃∃∀ and ∃∀1∀<sup>2</sup> consistently beats the SOTA triangle enumeration algorithm. We note that there is no previous code to solve this problem. As we discuss later, all existing algorithms either compute a total temporal triangle count, or enumerate all temporal triangles. The number of temporal triangles can be in billions with for graphs with millions of edges. Hence, we require the techniques developed to get FOL query solutions without a full enumeration.

Detecting motif trends: We apply FOLTY to a number of realworld datasets, and get various trends over thresholded quantifiers. An example is shown in [3.](#page-3-0) For example, we get a flattening of counts as the threshold crosses 0.7, meaning that edges that form triangles with a 0.7 fraction of their neighbors form triangles with almost their entire neighborhood. As shown in the appendix, we

can also apply FOL queries to detect edges in citation networks that are likely to be in the same topic.

### 1.4 Related Work

The subject of general motif counting is vast, so we do not attempt to cover all related work. We refer the reader to a tutorial of Seshadhri and Tirthapura on subgraph counting [\[49\]](#page-12-36). We only focus on results on temporal motif counting.

The problem of Temporal motif counting was first introduced in [\[38\]](#page-12-19), and since then, significant progress has been made in developing efficient algorithms for this question. [\[31\]](#page-12-18) presented a general-purpose algorithm that precisely counts the occurrences of any temporal motif in a graph . [\[61\]](#page-13-3) later enhanced this algorithm to achieve better performance on GPUs. Other algorithms that provide exact motif counts include [\[50\]](#page-12-20) and [\[34\]](#page-12-37). Additionally, there has been considerable focus on developing specialized algorithms for mining particular motifs, such as the temporal triangle [\[25,](#page-12-15) [39,](#page-12-32) [55\]](#page-12-22), Butterfly-counting [\[6\]](#page-11-7) etc.

There has also been considerable interest in developing efficient sampling methods, that generate accurate estimates of motif counts. [\[30,](#page-12-38) [44\]](#page-12-39) divide the timespan of the input graph into multiple intervals, randomly sample one of them, and then generate exact counts within the sampled subgraph. [\[59\]](#page-13-4) introduced a method that samples a uniform random edge and counts the motif instances incident on it. Other sampling methods include [\[3,](#page-11-8) [43\]](#page-12-40). More recently, [\[37\]](#page-12-31) proposed an efficient approach for counting motifs on 3 and 4 vertices by introducing the concept of Path-Sampling. [\[58\]](#page-13-5) utilize predictions from ML models to estimate temporal triangle count in streaming temporal networks.

We stress that none of these methods are geared towards solving general FOL queries. While these methods can enumerate all motifs, it would require extra logic to deduce the solutions. Moreover, the number of temporal motifs can easily be in billions for moderate graphs with only tens of millions of edges.

# 2 Main Ideas

Preliminaries. We begin with some preliminaries on the orientation methods for triangle counting. For temporal graph , the underlying static graph is constructed by removing all direction and parallel edges. Further, we assume that is presented to us as a list of temporal edges, sorted in the increasing order of timestamp. Given a vertex ∈ , () = { ∈ | {, } ∈ ( )}. Given a pair of distinct vertices and , we use , to denote the list of temporal edges from to , sorted in the increasing order of their timestamp. We assume (1) access to these lists. Given , ∈ , we use (, ) to denote the number of temporal edges with and as their endpoints.

Given an undirected graph , and an ordering on its vertices, we can orient the edges of to obtain a directed graph → defined as follows: → = ( , → ), where → = {(, ) | {, } ∈ () ∧ () < ()}. Given ∈ , define + () as the out-neighbourhood of in→ and − () as its in-neighbourhood. Next, we introduce the notion of degeneracy of .

Definition 2.1. The degeneracy of an undirected graph is the smallest integer , such that there exists an ordering of with

| + ()| ≤ for every ∈ . The resulting ordering is called degeneracy ordering.

The degeneracy ordering of an undirected graph can be obtained by repeatedly removing the lowest degree vertex from [\[32\]](#page-12-41). If two or more vertices have the same lowest degree, then the ties are resolved based on their id. Further, the order in which the vertices are removed gives the degeneracy ordering. The degeneracy ordering of can be computed in (|()|) time.

Given an edge = {, } in , its degree is defined as the degree of its lower-degree endpoint. A classic result of Chiba-Nishizeki states that

Lemma 2.1.1. [\[8\]](#page-11-6) Í ∈() = ()

For a temporal edge = (, , ), we call as the source of this edge if () < (), else the source will be .

How to solve FOL queries. Consider the predicate given by the temporal triangle in Figure[-2a.](#page-2-0) A triple (, ,) of vertices forms a -temporal triangle if there exist temporal edges (, , 1), (,, 2) and (,, 3) such that <sup>1</sup> ≤ <sup>2</sup> ≤ <sup>3</sup> ≤ <sup>1</sup> + (more concretely, these temporal edges should satisfy the constraints specified in the input query). Similarly, a temporal edge = (, , ) forms a -temporal triangle with a vertex if there exist temporal edges (,, 2) and (,, 3) which satisfy ≤ <sup>2</sup> ≤ <sup>3</sup> ≤ +. Clearly, these edges form a triangle that matches the motif specified in the input predicate (refer Figure[-2a\)](#page-2-0).

Now let us consider the ∃∃∀ query with a threshold ∈ (0, 1). A temporal edge = (, , ) is a solution to this query if at least fraction of 's neighbors form at least one -temporal triangle with .

Given a temporal network , the first step is to construct its underlying static graph and use it to obtain the directed graph → , where is the degeneracy ordering of . Our algorithm outputs 2 arrays of size , namely in-count and out-count. These arrays are indexed by the temporal edges in . For each temporal edge , in-count[] stores the number of vertices in − ( ) which form at least one -temporal triangle with . Here is used to denote the source of . A similar notion can be defined for outcount[].

Note that every neighbor of , that forms a -temporal triangle with = (, , ), must be a common neighbor of both and . Therefore, every such vertex will be in the neighborhood of 's source. Suppose neighbors of participate in a -temporal triangle with . Then, it follows that exactly neighbors of form a -temporal triangle with . As a result, if in-count[] + out-count[] ≥ | ()|, then at least fraction of 's neighbors form the desired triangle with . In this case, will be a solution to the ∃∃∀ query.

The two arrays can also be used to determine solutions for the ∃∀1∀<sup>2</sup> and ∃∀∃ queries. For the former query, we look for vertices , such that for at least <sup>1</sup> fraction of 's neighbors , there exists a temporal edge = (, , ), such <sup>2</sup> fraction of 's neighbors form a -temporal triangle with . Observe that for a given vertex , and for every such neighbor of , the temporal edge = (, , ) must be a solution to the ∃∃∀<sup>2</sup> query. Consequently, solutions to the given ∃∀1∀<sup>2</sup> query can be obtained by enumerating solutions to the ∃∃∀<sup>2</sup> query.

A similar approach can be used to enumerate the solutions to the ∃∀∃ query. A vertex is a solution to this query if, for at least -fraction of 's neighbors , there exists a temporal edge = (, , ) such that is incident on at least one -temporal triangle. In particular, for at least | ()| neighbors of , must contain a temporal edge = (, , ) for which in-count[] + out-count[] ≥ 1. From this discussion, it is evident that the arrays in-count[] and out-count[] are crucial for determining solutions for all the three queries.

Challenges. First Attempt: Let us consider a simple approach which, at very high level, begins by enumerating all the triangles in . Each temporal edge is assigned a counter which is initially 0. For every temporal edge = (, , ), its associated counter is used to store the number of vertices in ()∩ (), which form at least one -temporal triangle with . If ≥ | ()|, then will be a solution to ∃∃∀ query. To compute this value, we simply iterate over all the triangles (, ,) in . For every triangle (, ,), we fetch the temporal edge lists ,, , and ,. These are potential matches to the edges labeled 1,2 and 3 in the motif, given in Figure[-2a.](#page-2-0) Our goal is identify the edges in , , that form a -temporal triangle with . To do so, for every temporal edge = (, , ) ∈ , , we look for a pair of edges (<sup>2</sup> = (,, 2), <sup>3</sup> = (,, 3)) ∈ , ×, that satisfies ≤ <sup>2</sup> ≤ <sup>3</sup> ≤ + . Note that the existence of such a pair immediately implies that forms a -temporal triangle with . In this case, we increment the counter by 1. Since these edge lists are sorted in the increasing order of their timestamp, we can find such a pair (if it exists) for every temporal edge in , in ((, ) +(,) +(,)) time. This procedure is also repeated for the temporal edges going from to .

Now, let us analyze the time complexity of this algorithm. Triangle enumeration in can be done in () time. The time spent in updating the values of the counters is upperbounded by Í {,} ∈( ) Í ∈ ()∩ () ((, ) + (,) + (,)) for some suitable constant . Now observe that the number of times (, ) appears in this sum is equal to the number of triangles incident on the edge {, } in . This quantity is upperbounded by , i.e. the degree of the edge {, }. Therefore, the previous sum is at most cÍ (,) ∈( ) ,(, ) ≤ max Í (,) ∈( ) (, ) = · max, where max = max∈( ) . Note that max can be must larger than . Clearly, this approach does not work.

Challenge 1: Lets consider an alternative approach. For a given temporal edge = (, , ), we will use to denote its source and to denote its other endpoint. Recall that = iff () < (). In the previous case, in order to determine the value of the counter =(,,) , we would iterate over all triangles (, ,) that contain the edge {, }. For every such triangle, we spend ((, ) + (,) + (,)) time in figuring out which the temporal edges in , form a -temporal triangle with . Now assume that there exists a procedure, which

- (1) computes the correct value of by looking solely at the vertices in ∈ + ( ) ∩ ( ) (as opposed to ( ) ∩ ( )), where is the degeneracy ordering of and
- (2) determines which edges in , are incident on a -temporal triangle with in((, )+(,)) time (i.e. by making a pass over the temporal edges incident on the source vertex only ( , , ,) , as opposed to iterating through all the three edge-lists , , , and ,).

In this case, given an edge {, }, instead of iterating over all of () ∩ (), it suffices to look into + ( ) ∩ ( ). Recall that if (, ) ∈ (→ ), then () must be less that () (i.e. is the source vertex). Therefore, for every (, ) ∈ (→ ) and ∈ + (), if ∈ () then we fetch the edge lists ,, ,, , and execute the above on these lists. Note that since is the source, the algorithm can iterate only through the temporal edges incident on the source . These are precisely the edges in lists , and ,. Similarly, when we fetch the edge lists ,, , and ,(potential choices for edges labeled 1,2 and 3 in Figure[-2a\)](#page-2-0), the algorithm can iterate through the temporal edges in the lists , and , only, since they are the ones incident on the source . As a result, overall time complexity of the algorithm can be upper bounded by Í (,) ∈( ) Í ∈ <sup>+</sup> ( )∩ ( ) ((, ) + (,)). Now observe that a single term (, ) appears at most | + ( )| times in this sum, which is upper bounded by . This leads to the() running time. Hence, the first challenge is to come up with a procedure that satisfies 1 and 2

Challenge 2: For an edge = {, }, () ∩ () can be partitioned into + ( ) ∩ ( ) and − ( ) ∩ ( ). Given a temporal edge = (, , ), in order to compute the value of the counter , we need to know which vertices in + ( ) and − ( ) form a -temporal triangle with . Turns out, it is relatively easy to identify the out-neighbors in + ( ), which form a -temporal triangle with . The main challenge is dealing with the in-neighbors − ( ). Consider ∈ − ( ). This is equivalent to saying that ∈ + (). Further, if ∈ ( ), then ∈ + () since ( ) < ( ). Since the algorithm iterates over every (, ) ∈ (→ ) and ∈ + (), the contribution of to the value of will be accounted when considering the edge (, ) ∈ (→ ) and ∈ + () i.e. when is the source vertex. Our goal is find, for each edge in , , a pair of edges in , × , that forms a -temporal triangle with . However, note that we are no longer allowed to iterate through the edges in the list , . We can only go over the edges in the lists , and , since the source vertex is . This is the second challenge, where we would like to determine the edges in , that form a -temporal triangle with , without going over the edges in the list , for every ∈ − ( ).

# 3 ∃∃∀ Query

Given a temporal graph = ( , ), our goal is to find solutions to the ∃∃∀ query mentioned in [1.2.](#page-2-1)

The algorithm begins by constructing the underlying static graph . This can be done by making a single pass through the edges of . Next, for every static edge {, } ∈ , it defines a counter . The counter is used to store the number of common neighbours of and in . In order to compute the value of , the algorithm first determines the lower degree endpoint of the static edge {, }. Assume to be this endpoint. Next, it steps through the neighbours of in . For every ∈ (), if is adjacent to , it increases the value of by 1. Finally, the algorithm repeats this procedure for every static edge {, } ∈ .

Next, it computes the degeneracy ordering of , followed by the construction of the directed graph → . Our goal is to compute in-count[] and out-count[] for every temporal edge .

Broadly speaking, it is relatively easier to determine the value of out-count[]. However, similar approach cannot be used to compute in-count[]. This is primarily because in → , the out-degree of each vertex is upper bounded by the degeneracy , however the in-degree can be arbitrarily large. This leads to different ways of dealing with the in-neighbours and out-neighbours, each of which are presented in sections [3.1](#page-5-0) and [3.2](#page-6-0) respectively.

# <span id="page-5-0"></span>3.1 Dealing with Out-Neighbours

Given an edge (, ) ∈ → , the goal is to compute out-count[] for every temporal edge = (, , ) (and (, , )). We defer the proofs of the theorems in this section to the supplementary material. Note that if (, ) ∈ → , then () < ().

The algorithms presented in this section use the following subroutines as primitives:

(1) FindExceedingEntryLS(1, 2) : <sup>1</sup> and <sup>2</sup> are lists of temporal edges, sorted in the increasing order of timestamp. The function returns a list <sup>12</sup> of size |<sup>1</sup> |. For every ∈ 1, <sup>12</sup> [] stores the index of the first edge in <sup>2</sup> with timestamp at least (). Further, it does so in time (|<sup>1</sup> | + |<sup>2</sup> |).

(2) FindExceedingEntryBS(1, 2) : <sup>1</sup> and <sup>2</sup> are lists of temporal edges, sorted in the increasing order of timestamp. The function returns a list <sup>12</sup> of size |<sup>1</sup> |. For every ∈ 1, the function uses binary search to determine the index of the first edge in <sup>2</sup> whose timestamp exceeds (). Thus the overall running time of the algorithm is (|<sup>1</sup> | log |<sup>2</sup> |).

(3) FindBoundingEntry(1, 2, ) : As before, <sup>1</sup> and <sup>2</sup> are lists of temporal edges, sorted in the increasing order of timestamp. The function returns a list <sup>12</sup> of size |<sup>1</sup> |. For every ∈ 1, <sup>12</sup> [] stores the index of the last edge in <sup>2</sup> with timestamp at most () + . This function runs in (|<sup>1</sup> | + |<sup>2</sup> |) time.

Let us fix an edge (, ) in → and an out-neighbour of . Assume that is adjacent to in . If not, then it is obvious that cannot form a triangle with . Suppose <sup>1</sup> ← , . The goal is to compute the value of out-count[] for every ∈ 1. Set <sup>2</sup> to , and <sup>3</sup> to ,. An edge ∈ <sup>1</sup> forms at least one temporal triangle with , if there exists a pair (2, 3) ∈ <sup>2</sup> × <sup>3</sup> which satisfies () ≤ (2) ≤ (3) ≤ () + . Thus, for an edge ∈ 1, if such a pair exists in <sup>2</sup> × 3, then the algorithm increments out-count[] by 1. This leads to the following natural question: "How to find such a pair?"

Given 1, <sup>2</sup> and 3, the algorithm proceeds as follows (refer algorithm[-1\)](#page-6-1):

(1) It invokes FindExceedingEntryLS(1, 2) to get the list 12. We will abuse notation and use <sup>12</sup> [] to denote the index, as well the edge at this index in 2.

(2) Next, it invokes FindExceedingEntryBS(2, 3) to obtain the list 23. We will abuse notation and use <sup>23</sup> [] to denote the index, as well the edge at this index in 3.

(3) Finally, for every ∈ 1, it checks whether() ≤ (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []]) ≤ () +. If this condition holds, then it increments out-count[] by 1. Otherwise, it proceeds to the next edge of 1.

The following theorem shows that forms a -temporal triangle with if and only if (, <sup>12</sup> [], <sup>23</sup> [<sup>12</sup> []]) form a -temporal triangle.

<span id="page-6-1"></span>Algorithm 1 : OutNeighboursCase1(,, , ,, , out-count[])

Input: ,→ ,, 1: 1 ← ,, 2 ← ,, 3 ← , 2: <sup>12</sup> ← FindExceedingEntryLS(1, 2) 3: <sup>23</sup> ← FindExceedingEntryBS(2, 3) 4: for = (, , ) ∈ <sup>1</sup> do 5: if () ≤ (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []] ≤ () + then 6: out-count[] ← out-count[] + 1

<span id="page-6-2"></span>

| Algorithm 2 | : | OutNeighboursCase2(𝐺,𝐺𝑆, 𝑢, 𝑣,𝑤, 𝛿, out-count[]) |  |  |
|-------------|---|--------------------------------------------------|--|--|
|             |   |                                                  |  |  |

Input: ,→ ,, 1: Get the lists <sup>1</sup> ← ,, <sup>2</sup> ← ,, <sup>3</sup> ← , 2: <sup>13</sup> ← FindBoundingEntry(1, 3, ) 3: <sup>12</sup> ← FindExceedingEntryBS(1, 2) 4: for = (, , ) ∈ <sup>1</sup> do 5: if () ≤ (<sup>12</sup> []) ≤ (<sup>13</sup> []) ≤ () + then 6: out-count[] ← out-count[] + 1

<span id="page-6-3"></span>Algorithm 3 : OutNeighbours(,→ ,, , out-count[])

Input: ,→ ,, 1: for (, ) ∈ (→ ) do 2: for ∈ + () do 3: if is adjacent to then 4: OutNeighboursCase1(,, , ,, , out-count[]) 5: OutNeighboursCase2(,, , ,, , out-count[])

Theorem 3.1. Consider a temporal edge = (, , ) with () < () and an out-neighbour of which is adjacent to . forms at least one -temporal triangle with if and only if () ≤ (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []]) ≤ () + .

Proof. If () ≤ (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []]) ≤ () + holds, then the edges in 1, <sup>12</sup> [] in <sup>2</sup> and <sup>23</sup> [<sup>12</sup> []] in <sup>3</sup> form a -temporal triangle.

Now suppose that the edges 1, <sup>2</sup> and <sup>3</sup> form a -temporal triangle, with ∈ for = 1, 2, 3 and <sup>1</sup> = . It must be the case that () ≤ (2) ≤ (3) ≤ () + . Based on the definition of the lists <sup>12</sup> and 23, we know that () ≤ (<sup>12</sup> []) ≤ (2), (2) ≤ (<sup>23</sup> [2]) ≤ (3) and (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []]). Since (<sup>12</sup> []) ≤ (2), it follows that (<sup>23</sup> [<sup>12</sup> []]) ≤ (<sup>23</sup> [2]). Putting it all together, we get () ≤ (<sup>12</sup> []) ≤ (<sup>23</sup> [<sup>12</sup> []]) ≤ (<sup>23</sup> [2]) ≤ (3) ≤ () + . Therefore , <sup>12</sup> [] and <sup>23</sup> [<sup>12</sup> []] form a -temporal triangle. This completes the proof. □

Next, consider the case in which 1 consists of the temporal edges from to i.e. <sup>1</sup> ← ,. Set <sup>2</sup> to , and <sup>3</sup> to ,. As before, an edge in <sup>1</sup> forms a -temporal triangle with if there exists a pair in <sup>2</sup> × 3, that satisfies the temporal window and ordering constraints. Since the edges in 2 are not incident on the source of the edge (, ), the algorithm cannot make a pass through the edges in this list. Therefore, it uses uses algorithm[-2](#page-6-2) instead. The following claim establishes the correctness of algorithm[-2.](#page-6-2)

Theorem 3.2. Consider a temporal edge = (, , ) with () < () and an out-neighbour of which is adjacent to in . will form at least one temporal triangle with if and only if () ≤ (<sup>12</sup> []) ≤ (<sup>13</sup> []) ≤ ()+, where the lists 1, 2, 3, <sup>12</sup> and 23 are defined as above.

Proof. If the condition () ≤ (<sup>12</sup> []) ≤ (<sup>13</sup> []) ≤ () + is satisfied, then the edges in 1, <sup>12</sup> [] in <sup>2</sup> and <sup>13</sup> [] in <sup>3</sup> form a -temporal triangle.

Now suppose that the edges 1, <sup>2</sup> and <sup>3</sup> form a -temporal triangle, with ∈ for = 1, 2, 3 and <sup>1</sup> = . Clearly () ≤ (2) ≤ (3) ≤ () + . Based on the definitions of the lists <sup>12</sup> and 13, it follows that () ≤ (<sup>12</sup> []) ≤ (2) and (3) ≤ (<sup>13</sup> []) ≤ () + . Putting these together, we get () ≤ (<sup>12</sup> []) ≤ (2) ≤ (3) ≤ (<sup>13</sup> []) ≤ () + . Therefore, we can conclude that the edges , <sup>12</sup> [] and <sup>13</sup> [] form a -temporal triangle. □

Combining the two cases, the overall procedure for dealing with the out-neighbours is outlined in algorithm[-3.](#page-6-3)

Theorem 3.3. The procedure OutNeighboursruns in( log max) time.

Proof. The overall time spent by the algorithm is ( Í (,) ∈→ Í ∈ <sup>+</sup> () ((, )+(,)) log max). Since | + ()| ≤ for every ∈ (→ ), it follows that the time complexity can be upper bounded by ( Í (,) ∈→ ((, )) ( log max)) = ( log max). □

Note that in the end, for every = (, , )/(, , ) ∈ (), assuming () < (), out-count[] will contain the number of out-neighbours of which form at least one -temporal triangle with .

### <span id="page-6-0"></span>3.2 Dealing with In-Neighbours

After dealing with the out-neighbours, we need to compute incount[] for every temporal edge .

Fix a temporal edge = (, , ). Assume for the moment that () < (). Suppose ∈ − () ∩ (). Observe that if ∈ − () ∩ (), then ∈ + (). Also ∈ + () as () < (). Consequently, in-count[] must be updated when considering the edge (, ) ∈ (→ ) and its out-neighbor ∈ + () . In this case, we set <sup>2</sup> to , and <sup>3</sup> to , respectively. Since is the source, we cannot enumerate the edges in the list , .

As before, forms a -temporal triangle with if there is a pair of edges (2, 3) ∈ <sup>2</sup> × <sup>3</sup> that satisfies ≤ (2) ≤ (3) ≤ + . For every ∈ 2, let <sup>23</sup> [] be the first edge in <sup>3</sup> with timestamp at least (). Define ,, as the following collection of intervals, ,, := { [max{0, (<sup>23</sup> []) − }, ()] | { ∈ 2} ∧ {() ≤ (<sup>23</sup> []) ≤ () + }}. We begin by stating the following theorem.

<span id="page-6-4"></span>Theorem 3.4. The temporal edge = (, , ) forms at least one -temporal triangle with if and only if there exists an interval in ,, that contains = ().

Proof. Let us assume that the edges 1, <sup>2</sup> and <sup>3</sup> form a satisfying triangle, where <sup>1</sup> = and ∈ for = 1, 2, 3. We would like to show that there exists an interval in ,, which contains (1). From the definition of the list 23, we know that

(<sup>23</sup> [2]) ≤ (3). Therefore, (<sup>23</sup> []) − ≤ (3) − . Since 1, <sup>2</sup> and <sup>3</sup> form a -temporal triangle, (3) ≤ (1) + ≤ (2) + . As a consequence, (3) − ≤ (2). Hence we get (<sup>23</sup> [2]) − ≤ (3) − ≤ (2). Equivalently, (3) − ∈ [(<sup>23</sup> [2]) − , (2)]. Since (3) ≤ (1) + , it follows that (3) − ≤ (1) ≤ (2). Since (3) − ∈ [(<sup>23</sup> [2]) − , (2)], we can conclude that (1) ∈ [(<sup>23</sup> [2]) − , (2)]. Further, since (2) ≤ (<sup>23</sup> [2]) ≤ (3) ≤ (1) + ≤ (2) +, we can conclude that (2) ≤ (<sup>23</sup> []) ≤ (2) + . Combined with the fact that <sup>2</sup> ∈ <sup>2</sup> implies that the interval [(<sup>23</sup> [2]) − , (2)] ∈ ,, . Hence we have found an interval in ,, that contains (1).

For the other direction, let us assume that there exists an interval = [1, 2] in ,, that contains = (). Then there must exist an edge ′ ∈ <sup>2</sup> such that (<sup>23</sup> [ ′ ]) − = <sup>1</sup> and ( ′ ) = 2. Therefore, (23 [ ′ ]) − ≤ () ≤ ( ′ ). Since ( ′ ) ≤ (23 [ ′ ]), we have that (23 [ ′ ]) − ≤ () ≤ ( ′ ) ≤ (23 [ ′ ]), which is equivalent to () ≤ ( ′ ) ≤ (23 [ ′ ]) ≤ () +. So there exist edges ′ ∈ 2 and <sup>23</sup> [ ′ ] ∈ <sup>3</sup> that form a -satisfying triangle with the edge . This completes the proof. □

Note that a similar result can be proved for the temporal edges of the form (, , ) by setting <sup>1</sup> ← ,, <sup>2</sup> ← , and <sup>3</sup> ← ,. Equipped with theorem[-3.4,](#page-6-4) the algorithm proceeds as follows: for every edge (, ) ∈ → and ∈ + () ∩ (), it gets the edgelists <sup>1</sup> ← ,, <sup>2</sup> ← , and <sup>3</sup> ← ,. The goal is compute in-count[] for every ∈ 1. In the following discussion, we will stick to the case <sup>1</sup> ← ,, <sup>2</sup> ← ,, <sup>3</sup> ← ,, since the other one can be handled analogously.

Once the algorithm has the lists 2 and 3, it invokes FindExceedingEntryLS(2, 3) to get the list 23. It uses this list to get the intervals in the set ,,. Next, the algorithm iterates through the temporal edges in 1. For every ∈ 1, if it discovers an interval in ,, which contains , it increments the value of in-count[] by 1. Note that if <sup>1</sup> ← ,, then the algorithm sets <sup>2</sup> ← , and <sup>3</sup> ← ,. All the remaining steps will be the same.

However, observe that in this case, the algorithm iterates through the temporal edges ∈ <sup>1</sup> for every in-neighbor ∈ − () ∩ (). To achieve the() bound, we need to avoid this from happening at all.

To get around this issue, we adopt the following approach: for every static edge {, }, create two instances of a data structure that can be used store intervals. The first one, which we denote by , , is used to deal with the temporal edges of the form = (, , ). The second one, denoted by ,, is used to deal with temporal edges = (, , ). When the algorithm gets the list ,,, it inserts the intervals which belong to this list into ,. Similarly, it inserts the intervals of the list ,, in , . It repeats this procedure for all (, ) ∈ → and ∈ + ().

Finally, the algorithm iterates over the temporal edges in . The hope is that for every temporal edge = (, , ), the data structure , efficiently computes and returns the number of distinct lists ,, which consist of at least one interval containing in it, as varies across − ()(or − () if () < ()) . In the next section, we offer a brief overview of how segment trees can be used for this purpose. A detailed discussion can be found in the supplementary

<span id="page-7-0"></span>

| Algorithm 4 | InNeighbours(𝐺,𝐺𝑆,𝐺→𝜋<br>: | , 𝛿, | in-count[𝑒]) |
|-------------|----------------------------|------|--------------|

| 𝐺,𝐺𝑆,𝐺→𝜋<br>Input:<br>, 𝛿                                                       |
|---------------------------------------------------------------------------------|
| 1: For every<br>{𝑢, 𝑣<br>} ∈ 𝐺𝑆<br>, build segment trees<br>𝑇𝑢,𝑣<br>and<br>𝑇𝑣,𝑢 |
| 2: for<br>𝐸(𝐺→𝜋<br>) do<br>(𝑢, 𝑣) ∈                                             |
| +<br>for<br>𝑤<br>∈ 𝑁<br>(𝑢)<br>do<br>3:                                         |
| if<br>𝑤<br>is adjacent to<br>𝑣<br>then<br>4:                                    |
| ′<br>Get the lists<br>← 𝐸𝑣,𝑢,<br>← 𝐸𝑤,𝑢,<br>𝐿2<br>𝐿3<br>𝐿<br>2 ← 𝐸𝑤,𝑢<br>5:     |
| ′<br>and<br>𝐿<br>3 ← 𝐸𝑣,𝑢                                                       |
| 𝐿23<br>←FirstExceedingEntryLS(𝐿2, 𝐿3)<br>6:                                     |
| ′<br>′<br>′<br>𝐿<br>23 ←FirstExceedingEntryLS(𝐿<br>, 𝐿<br>)<br>7:<br>2<br>3     |
| Get the list<br>𝐼𝑢,𝑣,𝑤<br>using<br>𝐿23<br>and<br>𝐿2<br>8:                       |
| ′<br>′<br>Get the list<br>𝐼𝑢,𝑤,𝑣<br>using<br>𝐿<br>23 and<br>𝐿<br>9:<br>2        |
| InsertSegTree(𝐼𝑢,𝑣,𝑤,𝑇𝑣,𝑤, 𝑢)<br>10:                                            |
| InsertSegTree(𝐼𝑢,𝑤,𝑣,𝑇𝑤,𝑣, 𝑢)<br>11:                                            |
| 12: for<br>{𝑢, 𝑣<br>} ∈ 𝐸(𝐺𝑆<br>) do                                            |
| for<br>do<br>𝑒<br>∈ 𝐸𝑢,𝑣<br>13:                                                 |
| count<br>← LookUpSegTree(𝑡(𝑒),𝑇𝑢,𝑣<br>)<br>14:                                  |
| in-count[𝑒]<br>← in-count[𝑒] + count<br>15:                                     |
| for<br>do<br>𝑒<br>∈ 𝐸𝑣,𝑢<br>16:                                                 |
| count<br>← LookUpSegTree(𝑡(𝑒),𝑇𝑣,𝑢)<br>17:                                      |
| in-count[𝑒]<br>← in-count[𝑒] + count<br>18:                                     |

material. The overall algorithm to handle in-neighbours is presented in algorithm[-4.](#page-7-0)

# 3.3 Using Segment Trees to handle In-neighbors

Fix a temporal edge = (, , ). Our goal is to compute in-count[]. Let be the segment tree associated with the edge (, ). Assume that the intervals which were inserted in this tree came from three lists: 1, 2 and 3. Each node of , in addition to a segment, stores a counter which may or may not be updated every time an interval is inserted in . Note that by inserting an interval, we mean that we simulate the process of inserting an interval. The tree itself does not store any intervals.

When queried with , the algorithm looks for the segments in that contain . All these segments lie on a path in . The algorithm traverses this path, adds the values of the counters stored in the nodes on this path, and returns the resulting sum. And the hope is that this sum is equal to the number of lists among 1, 2, 3, which contain at least one interval with in it.

For the sake of simplicity, assume that each of the three lists contain at least one interval with in it. Further, consider the simple procedure, in which every time an interval is inserted at a node in , the procedure increments its counter by 1. Ideally, if exactly one interval in each list contains, then there is nothing to worry about, and the sum of counters correctly evaluates to 3. However, dealing with the case in which there exist multiple intervals containing within the same list is not as straightforward.

We briefly describe the issue here. Let and be two nodes on the path of the segments containing . Assume to be a descendant of on this path. Suppose <sup>1</sup> contains intervals and , which will be stored at and respectively. If is inserted before , then we can avoid increasing the counter of . This is because when looking for , the algorithm will encounter on its path. The moment is

Triadic First-Order Logic Queries in Temporal Networks Conference acronym 'XX, June 03–05, 2018, Woodstock, NY

finds that that 's counter is non-zero, it will prune the search and move on to the next interval.

However, if is inserted before , then we have a problem. This is because now, the path leading upto does not contain . Therefore, the algorithm will increment its counter by 1, and when queried with , it will return 2 as opposed to 1. To get past this issue, we introduce the idea of lazy updating of counters.

Broadly speaking, the idea is to delay counter updates rather than performing them immediately upon each interval insertion. This is implemented as follows: when an input interval is inserted and a node in the tree is selected to store it, instead of updating the node's counter right away, we mark the node as grey. For example, both and would be marked grey in this step, which we refer to as Phase-1.

Next, we proceed to Phase 2, where all the intervals are reinserted in the original order. During this re-insertion, if an interval is to be placed at node , and none of the nodes along the insertion path are grey, we keep grey. However, if there is any grey node along the path to , we reset 's color to white. In the earlier example, since lies on the path to and is grey, is turned back to white.

In the final phase i.e. Phase 3, the intervals are inserted once more, and this time, we update the counters only at the nodes that remain grey. So, in the previous case, we will only update the counter of and not of . As a result, the algorithm will return 1 as opposed to 2. Full implementation details are provided in the supplementary material.

# 3.4 Putting it All Together

Combining the ways to deal with the in-neighbours and out-neighbours, we present the overall algorithm in algorithm[-5.](#page-9-0) Refer to Appendix for the proof.

Theorem 3.5. The overall running time of the algorithm is ( log max)

### 4 ∃∀∀ Query and ∃∀∃ Query

Given a temporal graph = ( , ), we seek to find solutions to the ∃, ∀, ∀ query:

Suppose solves the query. Then, for 1% of 's neighbors , contains at least one temporal edge = (, , ), which solves the "∃∃∀" query, when its threshold is set to 2. This observation leads to the following, very simple algorithm:

- (1) First, solve for the ∃∃∀<sup>2</sup> query . Let denote the set of solutions to this query.
- (2) For every vertex ∈ (), create a dictionary , indexed by the vertices in ().
- (3) For every = (, , ) ∈ , if [] = 1, then proceed to the next edge in . Otherwise, set [] = 1.
- (4) Finally, compute Í ∈ () [].
- (5) Finally, for every ∈ (), if Í ∈ () [] ≥ <sup>1</sup> | ()|, then include in the solution set.

The algorithm for the ∃∀∃ is essentially the same, except for the lines (1) and (5). In particular, in line (1), instead of enumerating solutions to the ∃∃∀ query for a threshold value equal to 2, the algorithm enumerates edges which satisfy in-count[] + outcount[] ≥ 1. The additional change needed is to update line (5)

![](_page_8_Figure_19.jpeg)

(a) Phase 1: Insert the intervals into the segment tree, update suitable colors but donot update the counters

![](_page_8_Figure_21.jpeg)

(b) Phase 2: Suppose we reinsert the intervals of <sup>1</sup> in the same order. During the insertion of [8, 10], we come across the grey node containing the segment [7, 10]. Hence we recolor the segment [9, 10], which is supposed to contain [8, 10] to white. On the contrary, since none of the nodes on the path leading up to segment [7, 10] were grey, we retain its color during the insertion of [6, 13].

![](_page_8_Figure_24.jpeg)

(c) Update the counters of grey nodes only.

### Figure 4: Insertion into Segment Trees, different phases

of the algorithm by replacing <sup>1</sup> with , since there is only one threshold.

<span id="page-9-0"></span>

| ExistExistForAll(𝐺,𝐺𝑆,𝐺→𝜋<br>Algorithm 5<br>:<br>, 𝛿, 𝜏) |  |
|----------------------------------------------------------|--|
|----------------------------------------------------------|--|

Input: ,,→ ,

1: Initialise in-count[] and out-count[] arrays of size

2: Sol ←

- 3: OutNeighbours(,,→ , , out-count[])
- 4: InNeighbours(,,→ , , in-count[])
- 5: for = (, , ) ∈ () do
- 6: if out-count[] + in-count[] ≥ | ()| then
- 7: Sol ← Sol Ð {}
- 8: return Sol, |Sol|

<span id="page-9-3"></span>

| Table 1: Time to obtain solutions for | ∃∀∃ query, across dif |
|---------------------------------------|-----------------------|
| ferent choices of threshold, when     | 𝛿<br>= 4W             |

| Dataset                     | Threshold | Num. Solutions | Time(sec) |
|-----------------------------|-----------|----------------|-----------|
|                             | 25%       | 178            | 0.10      |
| CollegeMsg (CM)             | 50%       | 11             | 0.10      |
|                             | 75%       | 0              | 0.10      |
|                             | 25%       | 571            | 1.3       |
| email-Eu-core-Temporal (ET) | 50%       | 338            | 1.2       |
|                             | 75%       | 51             | 1.2       |
| sx-mathoverflow (MO)        | 25%       | 134            | 5.8       |
|                             | 50%       | 20             | 5.9       |
|                             | 75%       | 0              | 5.8       |
|                             | 25%       | 364            | 11.3      |
| sx-superuser (SU)           | 50%       | 95             | 11.1      |
|                             | 75%       | 4              | 11.3      |
|                             | 25%       | 408            | 5.2       |
| sx-askubuntu (AU)           | 50%       | 124            | 5.2       |
|                             | 75%       | 5              | 5.3       |
|                             | 25%       | 4105           | 92.4      |
| wiki-talk-temporal (WT)     | 50%       | 1128           | 94.3      |
|                             | 75%       | 108            | 92.4      |
|                             | 25%       | 7279           | 1746.6    |
| sx-stackoverflow (SO)       | 50%       | 1927           | 1960.1    |
|                             | 75%       | 123            | 1684.7    |

<span id="page-9-2"></span>Table 2: Time to obtain solutions for ∃∃∀ query, across different choices of threshold, when = 4W

| Dataset | Num. vertices | Num. edges | Threshold | Num Solutions | Time(sec) |
|---------|---------------|------------|-----------|---------------|-----------|
|         |               |            | 25%       | 102           | 0.06      |
| CM      | 1.90E+03      | 5.98E+04   | 50%       | 8             | 0.06      |
|         |               |            | 75%       | 0             | 0.05      |
|         |               |            | 25%       | 7167          | 1.19      |
| ET      | 1.01E+03      | 3.32E+05   | 50%       | 478           | 0.84      |
|         |               |            | 75%       | 28            | 0.35      |
|         |               |            | 25%       | 339           | 4.3       |
| MO      | 8.86E+04      | 5.07E+05   | 50%       | 65            | 2.8       |
|         |               |            | 75%       | 0             | 2.4       |
|         |               |            | 25%       | 1414          | 7.5       |
| SU      | 5.67E+05      | 1.44E+06   | 50%       | 383           | 6.07      |
|         |               |            | 75%       | 1             | 5.92      |
|         |               |            | 25%       | 1357          | 3.3       |
| AU      | 5.15E+05      | 9.64E+05   | 50%       | 398           | 3.03      |
|         |               |            | 75%       | 0             | 2.86      |
|         |               |            | 25%       | 7118          | 51.7      |
| WT      | 1.14E+06      | 7.83E+06   | 50%       | 1183          | 43.8      |
|         |               |            | 75%       | 11            | 42.5      |
|         |               |            | 25%       | 25455         | 956.452   |
| SO      | 2.60E+06      | 6.35E+07   | 50%       | 5904          | 883.687   |
|         |               |            | 75%       | 1             | 840.509   |

# 5 Experiments

We evaluate our algorithm on a number of different graphs from SNAP repository [\[28\]](#page-12-42), with edge count ranging from 50K, to nearly 70M. We implement it in C++ and executed it on Intel Xeon Platinum 8380 CPU. For our experiments, we use algorithm[-6](#page-9-1) to enumerate solutions to these queries.

<span id="page-9-5"></span>

|           | Table 3: Run time for SOTA triangle enumeration algorithm, |  |  |
|-----------|------------------------------------------------------------|--|--|
| 𝛿<br>= 4W |                                                            |  |  |

| Dataset | Num. vertices | Num. edges | Time(sec) |
|---------|---------------|------------|-----------|
| CM      | 1.90E+03      | 5.98E+04   | 0.8       |
| ET      | 1.01E+03      | 3.32E+05   | 10.9      |
| MO      | 8.86E+04      | 5.07E+05   | 1.4       |
| SU      | 5.67E+05      | 1.44E+06   | 5.12      |
| AU      | 5.15E+05      | 9.64E+05   | 4.2       |
| WT      | 1.14E+06      | 7.83E+06   | 141.29    |
| SO      | 2.60E+06      | 6.35E+07   | 1227.9    |

<span id="page-9-1"></span>Algorithm 6 : PRACTICAL-EEA(,, , count[], ) Input: , , count[], 1: for {, } ∈ ( ) do 2: Determine the lower degree end of the edge {, }. Let us denote the lower degree endpoint of this edge by and the other end by . 3: for ∈ () do 4: if ∈ () then 5: Get the lists <sup>1</sup> ← ,, <sup>2</sup> ← , and <sup>3</sup> ← ,. Also, get the lists ′ <sup>1</sup> ← ,, ′ <sup>2</sup> ← , and ′ <sup>3</sup> ← , 6: <sup>12</sup> ←FirstExceedingEntry(1, 2) 7: <sup>23</sup> ←FirstExceedingEntry(2, 3) 8: ′ <sup>12</sup> ←FirstExceedingEntry( ′ 1 , ′ 2 ) 9: ′ <sup>23</sup> ←FirstExceedingEntry( ′ 2 , ′ 3 ) 10: 11: for ∈ <sup>1</sup> do 12: if () ≤ (12 []) ≤ (23 [12 []]) ≤ () + then 13: count[] ← count[] + 1 14: for ∈ ′ 1 do 15: if () ≤ ( ′ <sup>12</sup> []) ≤ ( ′ <sup>23</sup> [ ′ <sup>12</sup> []]) ≤ () + then 16: count[] ← count[] + 1 17: for ∈ () do 18: if count ≥ | ()| then 19: counter += 1

20: return counter In tables[-2,](#page-9-2) [1](#page-9-3) and [4](#page-10-0) (in appendix), we report the overall running

time of our algorithm for thresholded ∃∃∀; ∃∀∃ and ∃∀∀ queries respectively. The run times, measured in seconds, are reported across various threshold values. For our experiments, we use algorithm[-6](#page-9-1) to determine solutions to these triadic queries. .

Our code is available at [1](#page-9-4)

For an ∃∀∀ query, we define two thresholds. We use <sup>1</sup> and <sup>2</sup> to denote the thresholds on the first and the second ∀ quantifiers respectively. We report the time taken to execute these queries in table[-4\(](#page-10-0)in supplementary material due to lack of space). It is evident from tables [1,](#page-9-3) [2,](#page-9-2) and [4](#page-10-0) that all three algorithms take nearly the same amount time to produce solutions to these queries. Further, we also compare our algorithm against the state of the art triangle enumeration algorithm (BT) [\[34\]](#page-12-37) (refer table[-3\)](#page-9-5), and observe that our algorithm for the ∃∃∀ and ∃∀∀ queries is consistently faster

<span id="page-9-4"></span><sup>1</sup>Code available at<https://anonymous.4open.science/r/Triadic-FOL-Queries-CEF3>

| Dataset                | 𝜏2  | 𝜏1  | Num. Solutions | 𝜏2  | 𝜏1  | Num. Solutions | Time 1(sec.) | Time 2(sec.) |
|------------------------|-----|-----|----------------|-----|-----|----------------|--------------|--------------|
|                        | 25% | 25% | 0              | 50% | 25% | 0              | 0.08         | 0.07         |
| CollegeMsg             |     | 50% | 0              |     | 50% | 0              | 0.08         | 0.07         |
|                        |     | 75% | 0              |     | 75% | 0              | 0.08         | 0.07         |
|                        | 25% | 25% | 1              | 50% | 25% | 0              | 1.2          | 0.8          |
| email-Eu-core-temporal |     | 50% | 0              |     | 50% | 0              | 1.2          | 0.8          |
|                        |     | 75% | 0              |     | 75% | 0              | 1.2          | 0.8          |
|                        |     | 25% | 0              |     | 25% | 0              | 4.5          | 3.1          |
| sx-mathoverflow        | 25% | 50% | 0              | 50% | 50% | 0              | 4.4          | 3.1          |
|                        |     | 70% | 0              |     | 75% | 0              | 4.5          | 3.1          |
|                        |     | 25% | 4              | 50% | 25% | 1              | 8.6          | 7.5          |
| sx-superuser           | 25% | 50% | 2              |     | 50% | 1              | 8.8          | 7.6          |
|                        |     | 75% | 0              |     | 75% | 0              | 8.6          | 7.5          |
|                        |     | 25% | 7              |     | 25% | 2              | 4.1          | 3.9          |
| sx-askubuntu           | 25% | 50% | 3              | 50% | 50% | 1              | 4.2          | 3.9          |
|                        |     | 75% | 0              |     | 75% | 0              | 4.1          | 3.9          |
|                        | 20% | 25% | 60             | 50% | 25% | 12             | 62.3         | 52.8         |
| wiki-talk-temporal     |     | 50% | 9              |     | 50% | 4              | 64.2         | 53.5         |
|                        |     | 75% | 0              |     | 75% | 0              | 62.5         | 52.7         |
|                        |     | 25% | 3737           | 50% | 25% | 3              | 1195.35      | 936.01       |
| sx-stackoverflow       | 25% | 50% | 1              |     | 50% | 1              | 1191.53      | 931.2        |
|                        |     | 75% | 0              |     | 75% | 0              | 1151.43      | 948.3        |

<span id="page-10-0"></span>Table 4: Time to obtain solutions for ∃∀1∀<sup>2</sup> query, across different choices of threshold, when = 4W.

than BT. Since rest of the queries build upon the data structures output by the algorithm for ∃∃∀ query, they take a bit longer, but are reasonably fast i.e have comparable run time as BT. We note that the BT runtimes reported below account for the time it takes to enumerate the triangles. To obtain solutions to the above queries, one needs some indexing mechanism on top of the triangle enumeration subroutine. Therefore, BT will take at least the reported time to determine solutions to these queries.

### 5.1 Insights

To gain some insights into the trend of number of solutions w.r.t different parameter, we define our query as follows: ∃∃ ∈ ()∀ ()∩ () (, ,), where represents the temporal triangle in Figure-[2a.](#page-2-0) We make similar modifications for ∃∀1∀<sup>2</sup> and ∃∀∃ queries. The primary reason for this modification is to get enough solutions that will allow us to gain some insights. This also demonstrates that are techniques are simple, and versatile enough to accommodate various other sets. Further, we see that conclusions drawn from these plots are often consistent with the case in which the universe is just (). Note that there is no difference in the time it takes to compute the solutions to the queries when we change the universe from () to () ∩ (). Doing so involves changing line-18 of algorithm[-6](#page-9-1) to | () ∩ ()|. Further, in certain applications, one may be interested in predicated where the universe is indeed () ∩ (). For instance, when trying to fetch cohesive groups of vertices, it may be more meaningful to have the intersection in the predicate.

Number of solutions for a fixed , varying threshold: Figure-[5a](#page-10-1) shows the trend in the number of solutions to ∃∃∀ query as we vary the value of threshold. We fix to 1Hr. Observe that generally, as the threshold increases, the number of solutions tends to decrease. This is because any edge that satisfies the ∃∃∀<sup>1</sup> , will also satisfy ∃∃∀<sup>2</sup> for any 2 < 1. For instance, For instance, if a temporal edge = (, , ) forms a -temporal triangle with at least 50% of and 's neighbors, it naturally satisfies the condition for 25% as well. Therefore, the number of solutions for threshold <sup>2</sup> is always at least as large as for any <sup>1</sup> ≥ 2, explaining the observed decline in solutions with increasing thresholds.

<span id="page-10-1"></span>![](_page_10_Figure_8.jpeg)

Figure 5: Number of solutions to different queries for a fixed delta, and varying thresholds

Further, observe from Figure- [5a](#page-10-1) that for relatively higher threshold values (typically exceeding 75%), the number of solutions is almost constant. This implies that most solutions to ∃∃∀0.75 query will also satisfy ∃∃∀0.9 query.

Similar trends can be observed in Figure[-5b,](#page-10-1) which depicts the variation in the number of solutions to ∃∀∃ query across a multitude of thresholds, when is set to 1Hr. Similar reasoning explains the decrease in the number of solutions as the value of the threshold increases. Further, beyond the 70% threshold, the number of solutions is almost constant. In fact, it is 0 in most cases, except for the "wiki-talk-temporal" dataset, where it is 9.

Figures[-5c](#page-10-1) and [5d](#page-10-1) illustrate the trend in the number of solutions to the ∃∀1∀<sup>2</sup> query for different values of the thresholds. As before, we set to 1Hr. In Figure[-5c](#page-10-1) we fix 2 to 20%, and in Figure[-5d,](#page-10-1) we set <sup>2</sup> to 25%. Note that for a fixed 1, the number of solutions to

<span id="page-11-9"></span>![](_page_11_Figure_1.jpeg)

Figure 6: Number of solutions to different queries for a varying delta, and fixed thresholds

<span id="page-11-10"></span>![](_page_11_Figure_3.jpeg)

Figure 7: Number of solutions to different queries for a varying delta, and fixed thresholds

the ∃∀1∀0.<sup>2</sup> query is at least the the number of solutions to the ∃∀1∀0.<sup>25</sup> query.

Also note that generally, the number of solutions to ∃∀∃ query exceeds the number of solutions to ∃∀∀ ′ query. This is because every solution to ∃∀∀ ′ query naturally satisfies ∃∀∃ query.

We note that similar observations can be extrapolated for the situations in which the universe is () rather than the intersection of neighborhoods.

Number of solutions for a fixed threshold, varying delta: Figures[-6a](#page-11-9) and [7a](#page-11-10) demonstrate the trend in the number of solutions to ∃∃∀ query as we vary the value of . In Figure[-6a,](#page-11-9) we set the

threshold to 25% and in Figure[-7a,](#page-11-10) threshold is set to 50%. Observe that the number of solutions to the query decreases as we increase . This is because, every temporal edge = (, , ) that satisfies the ∃∃∀ query for a given will naturally satisfy the ∃∃∀ for any ′ ≥ . This explains the increase in the number of solutions with increasing .

Similar trends can be observed in the solutions to ∃∀∃ query (Refer figures[-6b](#page-11-9) and [7b\)](#page-11-10). In figures [6b](#page-11-9) and [7b,](#page-11-10) we fix the thresholds to 10% and 30% respectively. As in the previous case, the number of solutions increases with increasing values.

Figures[-6c,](#page-11-9) [7c,](#page-11-10) [6d](#page-11-9) and [7d](#page-11-10) demonstrate the variation in the number of solutions to the ∃∀∀ query as changes from 10mins. to 1Hr. In figures[-6c](#page-11-9) and [6d,](#page-11-9) we fix the value of <sup>2</sup> to 20% and plot the trend in the number of solutions for <sup>1</sup> = 10% and <sup>2</sup> = 30%. In Figures[-7c](#page-11-10) and [7d,](#page-11-10) the value of <sup>2</sup> is set to 25% and we plot the number of solutions when <sup>1</sup> = 10% and <sup>2</sup> = 30%.

Discovering structure using FOL queries: In the introduction, we saw how ∃∃∀ queries can be used to discover cohesive edges in a citation network. These queries automatically find edges that support a large number of triangles, and we discover that the corresponding papers are in the same topic.

# 6 Conclusion

In this work, we initiate the study of thresholded triadic first-order logic queries in temporal networks. We present a practical algorithm with provable guarantees to find solutions to these queries. Note that our algorithm can be extended for other temporal triangles as well. In future, we would like to investigate if the techniques presented in this work can be generalised to other motifs and firstorder logic quantifiers.

# References

- <span id="page-11-2"></span>[1] Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of Databases. Addison-Wesley.<http://webdam.inria.fr/Alice/>
- <span id="page-11-0"></span>[2] Nesreen K Ahmed, Nick Duffield, Jennifer Neville, and Ramana Kompella. 2014. Graph sample and hold: A framework for big-graph analytics. In Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. 1446–1455.
- <span id="page-11-8"></span>[3] Nesreen K Ahmed, Nick Duffield, and Ryan A Rossi. 2021. Online sampling of temporal networks. ACM Transactions on Knowledge Discovery from Data (TKDD) 15, 4 (2021), 1–27.
- <span id="page-11-5"></span>[4] Erik Altman, Jovan Blanuša, Luc von Niederhäusern, Béni Egressy, Andreea Anghel, and Kubilay Atasu. 2023. Realistic synthetic financial transactions for anti-money laundering models. In Proc. of Neural Information Processing Systems (NeurIPS). 29851–29874.
- <span id="page-11-3"></span>[5] Marcelo Arenas and Gonzalo I. Diaz. 2016. The Exact Complexity of the First-Order Logic Definability Problem. ACM Trans. Database Syst. 41, 2 (2016), 13:1– 13:14.<https://doi.org/10.1145/2886095>
- <span id="page-11-7"></span>[6] Xin-Wei Cai, Xiangyu Ke, Kai Wang, Lu Chen, Tianming Zhang, Qing Liu, and Yunjun Gao. 2023. Efficient Temporal Butterfly Counting and Enumeration on Temporal Bipartite Graphs. CoRR abs/2306.00893 (2023). [doi:10.48550/ARXIV.](https://doi.org/10.48550/ARXIV.2306.00893) [2306.00893](https://doi.org/10.48550/ARXIV.2306.00893)
- <span id="page-11-4"></span>[7] Ashok K. Chandra and David Harel. 1980. Computable Queries for Relational Data Bases. J. Comput. Syst. Sci. 21, 2 (1980), 156–178. [https://doi.org/10.1016/0022-](https://doi.org/10.1016/0022-0000(80)90032-X) [0000\(80\)90032-X](https://doi.org/10.1016/0022-0000(80)90032-X)
- <span id="page-11-6"></span>[8] Norishige Chiba and Takao Nishizeki. 1985. Arboricity and Subgraph Listing Algorithms. SIAM J. Comput. 14, 1 (1985), 210–223. [doi:10.1137/0214017](https://doi.org/10.1137/0214017)
- <span id="page-11-11"></span>[9] Mark de Berg, Otfried Cheong, Marc J. van Kreveld, and Mark H. Overmars. 2008. Computational geometry: algorithms and applications, 3rd Edition. Springer. <https://www.worldcat.org/oclc/227584184>
- <span id="page-11-1"></span>[10] Mehrdad Farajtabar, Manuel Gomez-Rodriguez, Yichen Wang, Shuang Li, Hongyuan Zha, and Le Song. 2018. COEVOLVE: A Joint Point Process Model for Information Diffusion and Network Co-evolution. In Companion of the The Web Conference 2018 on The Web Conference 2018, WWW 2018, Lyon , France, April 23-27, 2018, Pierre-Antoine Champin, Fabien Gandon, Mounia Lalmas, and

Triadic First-Order Logic Queries in Temporal Networks Conference acronym 'XX, June 03–05, 2018, Woodstock, NY

Panagiotis G. Ipeirotis (Eds.). ACM, 473–477.

- <span id="page-12-25"></span>[11] Flavio Antonio Ferrarotti, Alejandra Lorena Paoletti, and José M. Turull Torres. 2009. First-Order Types and Redundant Relations in Relational Databases. In Advances in Conceptual Modeling - Challenging Perspectives, ER 2009 Workshops CoMoL, ETheCoM, FP-UML, MOST-ONISW, QoIS, RIGiM, SeCoGIS, Gramado, Brazil, November 9-12, 2009. Proceedings (Lecture Notes in Computer Science, Vol. 5833), Carlos A. Heuser and Günther Pernul (Eds.). Springer, 65–74. [doi:10.1007/978-3-](https://doi.org/10.1007/978-3-642-04947-7_9) [642-04947-7\\_9](https://doi.org/10.1007/978-3-642-04947-7_9)
- <span id="page-12-16"></span>[12] Zhongqiang Gao, Chuanqi Cheng, Yanwei Yu, Lei Cao, Chao Huang, and Junyu Dong. 2022. Scalable motif counting for large-scale temporal graphs. In 2022 IEEE 38th International Conference on Data Engineering (ICDE). IEEE, 2656–2668.
- <span id="page-12-14"></span>[13] Noé Gaumont, Clémence Magnien, and Matthieu Latapy. 2016. Finding remarkably dense sequences of contacts in link streams. Soc. Netw. Anal. Min. 6, 1 (2016), 87:1–87:14.
- <span id="page-12-26"></span>[14] Martin Grohe. 2011. From polynomial time queries to graph structure theory. Commun. ACM 54, 6 (2011), 104–112. [doi:10.1145/1953122.1953150](https://doi.org/10.1145/1953122.1953150)
- <span id="page-12-33"></span>[15] Martin Grohe, Stephan Kreutzer, and Sebastian Siebertz. 2014. Deciding firstorder properties of nowhere dense graphs. In Symposium on Theory of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014, David B. Shmoys (Ed.). ACM, 89–98.
- <span id="page-12-23"></span>[16] László Hajdu and Miklós Krész. 2020. Temporal network analytics for fraud detection in the banking sector. In International Conference on Theory and Practice of Digital Libraries. Springer, 145–157.
- <span id="page-12-0"></span>[17] Mohammad Al Hasan and Vachik S. Dave. 2018. Triangle counting in large networks: a review. WIREs Data Mining Knowl. Discov. 8, 2 (2018).
- <span id="page-12-1"></span>[18] Jack Hessel, Chenhao Tan, and Lillian Lee. 2016. Science, askscience, and badscience: On the coexistence of highly related communities. In Proceedings of the international AAAI conference on web and social media, Vol. 10. 171–180.
- <span id="page-12-10"></span>[19] Joseph J. Pfeiffer III, Timothy La Fond, Sebastián Moreno, and Jennifer Neville. 2012. Fast Generation of Large Scale Social Networks While Incorporating Transitive Closures. In 2012 International Conference on Privacy, Security, Risk and Trust, PASSAT 2012, and 2012 International Confernece on Social Computing, SocialCom 2012, Amsterdam, Netherlands, September 3-5, 2012. IEEE Computer Society, 154–165.
- <span id="page-12-2"></span>[20] Anand Padmanabha Iyer, Zaoxing Liu, Xin Jin, Shivaram Venkataraman, Vladimir Braverman, and Ion Stoica. 2018. ASAP: Fast, approximate graph pattern mining at scale. In 13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18). 745–761.
- <span id="page-12-3"></span>[21] Madhav Jha, C Seshadhri, and Ali Pinar. 2015. Path sampling: A fast and provable method for estimating 4-vertex subgraph counts. In Proceedings of the 24th international conference on world wide web. 495–505.
- <span id="page-12-34"></span>[22] Wojciech Kazana and Luc Segoufin. 2018. First-order queries on classes of structures with bounded expansion. CoRR abs/1802.04613 (2018). arXiv[:1802.04613](https://arxiv.org/abs/1802.04613) <http://arxiv.org/abs/1802.04613>
- <span id="page-12-12"></span>[23] Arijit Khan, Nan Li, Xifeng Yan, Ziyu Guan, Supriyo Chakraborty, and Shu Tao. 2011. Neighborhood based fast graph search in large networks. In Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2011, Athens, Greece, June 12-16, 2011, Timos K. Sellis, Renée J. Miller, Anastasios Kementsietsidis, and Yannis Velegrakis (Eds.). ACM, 901–912.
- <span id="page-12-4"></span>[24] Dániel Kondor, Nikola Bulatovic, József Stéger, István Csabai, and Gábor Vattay. 2021. The rich still get richer: Empirical comparison of preferential attachment via linking statistics in bitcoin and ethereum. Frontiers in Blockchain 4 (2021), 668510.
- <span id="page-12-15"></span>[25] Lauri Kovanen, Márton Karsai, Kimmo Kaski, János Kertész, and Jari Saramäki. 2011. Temporal motifs in time-dependent networks. Journal of Statistical Mechanics: Theory and Experiment 2011, 11 (2011), P11005.
- [26] Lauri Kovanen, Kimmo Kaski, János Kertész, and Jari Saramäki. 2013. Temporal motifs reveal homophily, gender-specific patterns, and group talk in call sequences. Proceedings of the National Academy of Sciences 110, 45 (2013), 18070– 18075.
- <span id="page-12-17"></span>[27] Rohit Kumar and Toon Calders. 2018. 2scent: An efficient algorithm to enumerate all simple temporal cycles. Proceedings of the VLDB Endowment 11, 11 (2018), 1441–1453.
- <span id="page-12-42"></span>[28] Jure Leskovec and Andrej Krevl. 2014. SNAP Datasets: Stanford Large Network Dataset Collection. [http://snap.stanford.edu/data.](http://snap.stanford.edu/data)
- <span id="page-12-24"></span>[29] Penghang Liu, Rupam Acharyya, Robert E Tillman, Shunya Kimura, Naoki Masuda, and Ahmet Erdem Sarıyüce. 2023. Temporal Motifs for Financial Networks: A Study on Mercari, JPMC, and Venmo Platforms. arXiv preprint arXiv:2301.07791 (2023).
- <span id="page-12-38"></span>[30] Paul Liu, Austin R Benson, and Moses Charikar. 2019. Sampling methods for counting temporal motifs. In Proceedings of the twelfth ACM international conference on web search and data mining. 294–302.
- <span id="page-12-18"></span>[31] Patrick Mackey, Katherine Porterfield, Erin Fitzhenry, Sutanay Choudhury, and George Chin. 2018. A chronological edge-driven approach to temporal subgraph isomorphism. In 2018 IEEE international conference on big data (big data). IEEE, 3972–3979.
- <span id="page-12-41"></span>[32] David W. Matula and Leland L. Beck. 1983. Smallest-Last Ordering and clustering and Graph Coloring Algorithms. J. ACM 30, 3 (1983), 417–427. [https://doi.org/](https://doi.org/10.1145/2402.322385)

[10.1145/2402.322385](https://doi.org/10.1145/2402.322385)

- <span id="page-12-27"></span>[33] Felipe Meneguzzi, Pankaj R. Telang, and Munindar P. Singh. 2013. A First-Order Formalization of Commitments and Goals for Planning. In Proceedings of the Twenty-Seventh AAAI Conference on Artificial Intelligence, July 14-18, 2013, Bellevue, Washington, USA, Marie desJardins and Michael L. Littman (Eds.). AAAI Press, 697–703. [doi:10.1609/AAAI.V27I1.8632](https://doi.org/10.1609/AAAI.V27I1.8632)
- <span id="page-12-37"></span>[34] Seunghwan Min, Jihoon Jang, Kunsoo Park, Dora Giammarresi, Giuseppe F. Italiano, and Wook-Shin Han. 2024. Time-Constrained Continuous Subgraph Matching Using Temporal Information for Filtering and Backtracking. In 40th IEEE International Conference on Data Engineering, ICDE 2024, Utrecht, The Netherlands, May 13-16, 2024. IEEE, 3257–3269. [doi:10.1109/ICDE60146.2024.00252](https://doi.org/10.1109/ICDE60146.2024.00252)
- <span id="page-12-28"></span>[35] Leora Morgenstern. 1986. A First Order Theory of Planning, Knowledge, and Action. In Proceedings of the 1st Conference on Theoretical Aspects of Reasoning about Knowledge, Monterey, CA, USA, March 1986, Joseph Y. Halpern (Ed.). Morgan Kaufmann, 99–114.
- <span id="page-12-13"></span>[36] Gergely Palla, Imre Derényi, Illés Farkas, and Tamás Vicsek. 2005. Uncovering the overlapping community structure of complex networks in nature and society. Nature 435 (07 2005), 814–818.
- <span id="page-12-31"></span>[37] Yunjie Pan, Omkar Bhalerao, C. Seshadhri, and Nishil Talati. 2024. Accurate and Fast Estimation of Temporal Motifs using Path Sampling. arXiv[:2409.08975](https://arxiv.org/abs/2409.08975) [cs.SI] <https://arxiv.org/abs/2409.08975>
- <span id="page-12-19"></span>[38] Ashwin Paranjape, Austin R Benson, and Jure Leskovec. 2017. Motifs in temporal networks. In Proceedings of the tenth ACM international conference on web search and data mining. 601–610.
- <span id="page-12-32"></span>[39] Noujan Pashanasangi and C Seshadhri. 2021. Faster and generalized temporal triangle counting, via degeneracy ordering. In Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery & Data Mining. 1319–1328.
- <span id="page-12-5"></span>[40] Aduri Pavan, Kanat Tangwongsan, Srikanta Tirthapura, and Kun-Lung Wu. 2013. Counting and sampling triangles from a graph stream. Proceedings of the VLDB Endowment 6, 14 (2013), 1870–1881.
- <span id="page-12-6"></span>[41] Ali Pinar, Comandur Seshadhri, and Vaidyanathan Vishal. 2017. Escape: Efficiently counting all 5-vertex subgraphs. In Proceedings of the 26th international conference on world wide web. 1431–1440.
- <span id="page-12-29"></span>[42] Stuart Russell and Peter Norvig. 2020. Artificial Intelligence: A Modern Approach (4th Edition). Pearson.<http://aima.cs.berkeley.edu/>
- <span id="page-12-40"></span>[43] Ilie Sarpe and Fabio Vandin. 2021. OdeN: simultaneous approximation of multiple motif counts in large temporal networks. In Proceedings of the 30th ACM International Conference on Information & Knowledge Management. 1568–1577.
- <span id="page-12-39"></span>[44] Ilie Sarpe and Fabio Vandin. 2021. Presto: Simple and scalable sampling techniques for the rigorous approximation of temporal motif counts. In Proceedings of the 2021 SIAM International Conference on Data Mining (SDM). SIAM, 145–153.
- <span id="page-12-35"></span>[45] C. Seshadhri. 2023. Some Vignettes on Subgraph Counting using Graph Orientations. Invited tutorial slides, International Conference on Database Theory (ICDT).<https://users.soe.ucsc.edu/~sesh/publication.html>
- <span id="page-12-11"></span>[46] C. Seshadhri, Tamara G. Kolda, and Ali Pinar. 2012. Community structure and scale-free collections of Erdös-Rényi graphs. Physical Review E 85, 5 (May 2012), 056109. [doi:10.1103/PhysRevE.85.056109](https://doi.org/10.1103/PhysRevE.85.056109)
- <span id="page-12-7"></span>[47] C Seshadhri, Ali Pinar, and Tamara G Kolda. 2014. Wedge sampling for computing clustering coefficients and triangle counts on large graphs. Statistical Analysis and Data Mining: The ASA Data Science Journal 7, 4 (2014), 294–307.
- <span id="page-12-8"></span>[48] C Seshadhri and Srikanta Tirthapura. 2019. Scalable subgraph counting: The methods behind the madness: WWW 2019 tutorial. In Proceedings of the Web Conference (WWW), Vol. 2. 75.
- <span id="page-12-36"></span>[49] C. Seshadhri and Srikanta Tirthapura. 2019. Scalable Subgraph Counting: The Methods Behind The Madness: WWW 2019 Tutorial.
- <span id="page-12-20"></span>[50] Xiaoli Sun, Yusong Tan, Qingbo Wu, Baozi Chen, and Changxiang Shen. 2019. Tm-miner: Tfs-based algorithm for mining temporal motifs in large temporal network. IEEE Access 7 (2019), 49778–49789.
- [51] Nishil Talati, Haojie Ye, Sanketh Vedula, Kuan-Yu Chen, Yuhan Chen, Daniel Liu, Yichao Yuan, David Blaauw, Alex Bronstein, Trevor Mudge, et al. 2022. Mint: An Accelerator For Mining Temporal Motifs. In 2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO). IEEE, 1270–1287.
- <span id="page-12-21"></span>[52] Nishil Talati, Haojie Ye, Yichen Yang, Leul Belayneh, Kuan-Yu Chen, David Blaauw, Trevor Mudge, and Ronald Dreslinski. 2022. Ndminer: accelerating graph pattern mining using near data processing. In Proceedings of the 49th Annual International Symposium on Computer Architecture. 146–159.
- <span id="page-12-30"></span>[53] Jie Tang, Jing Zhang, Limin Yao, Juanzi Li, Li Zhang, and Zhong Su. 2008. Arnet-Miner: extraction and mining of academic social networks. In Proceedings of the 14th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Las Vegas, Nevada, USA, August 24-27, 2008, Ying Li, Bing Liu, and Sunita Sarawagi (Eds.). ACM, 990–998.
- <span id="page-12-9"></span>[54] Charalampos E Tsourakakis, U Kang, Gary L Miller, and Christos Faloutsos. 2009. Doulion: counting triangles in massive graphs with a coin. In Proceedings of the 15th ACM SIGKDD international conference on Knowledge discovery and data mining. 837–846.
- <span id="page-12-22"></span>[55] Kun Tu, Jian Li, Don Towsley, Dave Braines, and Liam D. Turner. 2018. Network Classification in Temporal Networks Using Motifs. CoRR abs/1807.03733 (2018). arXiv[:1807.03733](https://arxiv.org/abs/1807.03733)<http://arxiv.org/abs/1807.03733>

- <span id="page-13-0"></span>[56] Ata Turk and Duru Turkoglu. 2019. Revisiting wedge sampling for triangle counting. In The World Wide Web Conference. 1875–1885.
- <span id="page-13-2"></span>[57] Davide Vega and Matteo Magnani. 2018. Foundations of Temporal Text Networks. Appl. Netw. Sci. 3, 1 (2018), 25:1–25:26. [doi:10.1007/S41109-018-0082-3](https://doi.org/10.1007/S41109-018-0082-3)
- <span id="page-13-5"></span>[58] Giorgio Venturin, Ilie Sarpe, and Fabio Vandin. 2025. Efficient Approximate Temporal Triangle Counting in Streaming with Predictions. CoRR abs/2506.13173 (2025).<https://doi.org/10.48550/arXiv.2506.13173>
- <span id="page-13-4"></span>[59] Jingjing Wang, Yanhao Wang, Wenjun Jiang, Yuchen Li, and Kian-Lee Tan. 2020. Efficient sampling algorithms for approximate temporal motif counting. In Proceedings of the 29th ACM international conference on information & knowledge management. 1505–1514.
- <span id="page-13-1"></span>[60] Pinghui Wang, Junzhou Zhao, Xiangliang Zhang, Zhenguo Li, Jiefeng Cheng, John CS Lui, Don Towsley, Jing Tao, and Xiaohong Guan. 2017. MOSS-5: A fast method of approximating counts of 5-node graphlets in large graphs. IEEE Transactions on Knowledge and Data Engineering 30, 1 (2017), 73–86.
- <span id="page-13-3"></span>[61] Yichao Yuan, Haojie Ye, Sanketh Vedula Wynn Kaza, and Nishil Talati. 2023. Everest: GPU-Accelerated System For Mining Temporal Motifs. arXiv preprint arXiv:2310.02800 (2023).

# A Appendix

# A.1 Segment-Trees to deal with in-neighbours

A.1.1 Primer on Segment Trees: Before we proceed, we specify that when talking about a temporal edge = (, , ), we will assume () < () for the ease of presentation. The other case can be handled analogously.

Recall that for every static edge {, }, the algorithm creates two segment trees, namely , , and ,. A segment tree is a balanced binary tree, used to store intervals. Every node of this tree contains a segment. We will use Seg() to denote the segment stored at. For every in , Seg() is obtained by combining the segments stored in the left and right children of. In particular, if Seg(LeftChild()) = [, ] and Seg(RightChild()) = [, ], then Seg() = [, ]. For our setting, in addition to a segment, every node contains a counter, which we denote by Counter() and a vertex, denoted by Vertex(). Given a node in and a set of intervals , the canonical subset of consists of intervals in , which contain Seg(), but do not contain Seg(parent()). In a segment tree, if the canonical subset of a node contains an interval , then is stored at that node. Although may belong to the canonical subset of several nodes in , it is well known that at any given level, there can be at most 2 nodes where the might be stored [\[9\]](#page-11-11). This fact is crucial in establishing the (log) complexity for inserting an interval in a segment tree. In particular, given an interval , the time needed to look for the nodes, whose canonical subset contains , is (ℎ), where ℎ is the height of the tree.

Coming back to the algorithm, note that for every (, ) ∈ → and ∈ + (), the algorithm first computes a list ,, of intervals, and then inserts them in the segment tree ,. Finally, given a temporal edge = (, , ), the algorithm traverses along a path in , . Every node on this path consists of a segment that contains . We shall refer to this path as the suitable path for in , . The algorithm accumulates the values of Counter() for every node on this path and subsequently returns the sum. The hope is that this value represents the number of vertices in − () ∩ (), which form at least one -temporal triangle with . This is precisely what in-count[] is expected to store.

### First Attempt :

Consider the intervals in ,, = for some ∈ − () ∩ (). Suppose the algorithm does the following: for every ∈ , it looks for the node(s) in , whose canonical subset contains . For every such node , it increments Counter() by 1.

We will use Figure[-8a](#page-15-0) as a running example. Suppose ,, = <sup>1</sup> = { [6, 13], [8, 10]}. Observe that the intervals [6, 13] and [8, 10] belong to the canonical subset of nodes 1(i.e. node with segment [7, 10]) and 2(i.e. node with segment [9, 10]) respectively. As a result, after inserting the intervals in 1, the algorithm updates Counter(1) and Counter(2) to 1. Now suppose = (, , 9). In order to compute in-count[], the algorithm looks for the suitable path of 9 in , . In this case, this path consists of nodes 1,2 and 4(i.e. node with segment [9, 10]). The algorithm adds the counters stored at these nodes and then returns the sum 2. However, both the intervals belong to the same list 1. Therefore, ideally, the sum should have been 1 (to account for the in-neighbour ). More concretely, the algorithm has over-counted the contribution of .

Case when 1 inserted before 2:

Now suppose the algorithm does the following: for every node encountered during the insertion of an interval , the algorithm checks if Counter() is greater than 0. If Counter() is indeed greater than 0, then it simply returns. Otherwise, it proceeds with the usual insertion process.

We emphasize that the intervals are not actually stored in the segment tree. When we say that the algorithm "inserts an interval ", we mean that it simulates the process of inserting . In particular, it looks for the nodes whose canonical subset contains , and then updates their fields.

How does this modification to the insertion procedure help? Consider the same example as before (refer figure[-8b\)](#page-15-0). First, the algorithm inserts <sup>1</sup> = [6, 13], and updates Counter(1) to 1. Next, during the insertion of <sup>2</sup> = [8, 10], the algorithm visits node 1. Since Counter(1) > 0, the algorithm simply returns and moves on to the next interval in the input list. Note that this procedure avoids the over-contribution of to in-count[], where = (, , 9). This is because there exists a unique node on the suitable path of 9, namely node 1, which reflects the contribution due to .

Why did it work? During the insertion of an interval , Suppose the algorithm visits a node with Counter() > 1 . We can conclude that

- (1) there exists an interval in the input list, which was inserted before and contains Seg() and
- (2) belongs to the canonical subset of some node in the subtree rooted at .

Now consider an edge = (, , ). Observe that for every node in the subtree rooted at , Seg() ⊆ Seg(). Consequently, if contains Seg(), then also contains every segment in the subtree rooted at . As a result, for any interval which belongs to the canonical subset of , if ∈ ∩ Seg(), then it follows that ∈ . Therefore, following the insertion of , it is no longer necessary to insert the intervals, which belong to the canonical subset of the nodes in the subtree, rooted at .

### What if 2 is inserted before 1?

Up until now, we assumed that the interval <sup>1</sup> = [6, 13] was inserted before <sup>2</sup> = [8, 10]. However, now let us switch the order of the intervals in <sup>1</sup> (refer figure[-8c\)](#page-15-0). In particular, suppose <sup>1</sup> = { [8, 10], [6, 13]}. Now the algorithm begins with the insertion of 1. Since none of the counters associated with the nodes, visited by the algorithm, are greater than 1, the algorithm updates Counter(2) to 1. Next, it inserts 2. Since node 1 is an ancestor of node 2, and <sup>2</sup> is in the canonical subset of node 1, it follows that none of the counters, stored at the nodes encountered during the insertion of 2, are greater than 1. This causes Counter(1) to increase by 1. This creates a problem, since the suitable path for = (, , 9) will return 2 as the value for in-count[]. As a consequence, the algorithm over-counts the contribution of .

More concretely, the algorithm fails if an interval , which belongs to the canonical subset of a node , is inserted after an interval , which belongs to the canonical subset of a node in the subtree, rooted at . Ideally, we would like to be inserted before , not the other way round.

To get around this issue, the insertion algorithm proceeds in phases. We introduce an additional Color field into the structure of every node in the tree. This field is initially white for all nodes.

Phase 1: Let denote a list of input intervals and be a segment tree. For every ∈ , the algorithm searches for the nodes in , whose canonical subset contains . During this process, if it encounters a grey node, then it simply returns and proceeds to the next interval in . On the other hand, if it successfully reaches a node whose canonical subset contains , then it updates 's color from white to grey. Note that it does not update any counters along the way.

- In the end, a node is colored grey if
- (1) contains an interval which belongs to the canonical subset of and
- (2) None of the nodes on the unique path from the root of to were grey in color during the insertion of .

In our example, at the end of phase 1, nodes 1 and 2 will be grey in color (refer figure[-9a\)](#page-16-0).

Phase 2: We begin by briefly describing the intuition for this phase. As seen before, for every interval ∈ , if the algorithm updates the counters associated with all the nodes, whose canonical subset contains , then it could return an over-estimate to in-count[] for some ∈ () (refer figure[-8c\)](#page-15-0). Therefore, the idea is to use the colors assigned to the nodes of the tree to help us decide, which counters need to be updated. The eventual goal is update the counters associated with the grey nodes only. However, we aren't quite there yet. For instance, consider figure[-8c](#page-15-0) At the end of phase 1, if 2 is inserted before 1, then both 1 and 2 will be grey, which as we saw before, is not good.

At the end of phase 1, few nodes of will be grey in color, while the rest will be white. Let be the subset of grey nodes in , which are reachable from the root via an entirely white path. In this phase, the goal is to recolor all the grey nodes back to white, except for the nodes in . Observe that for any two nodes , ∈ , cannot be in the subtree rooted at , and vice-versa.

Recall that an interval is stored at the node(s) whose canonical subset contain that interval. Now fix some ∈ . Since the rootto- path consists only of white nodes, none of the intervals in belong to the canonical subset of any ancestor of . Therefore, every interval in will be inserted at a node, which is either in , or in the subtree, rooted at some ∈ . Further, if belongs to the canonical subset of , and belongs to the canonical subset of some descendant of , then for any ∈ ∩ Seg() it immediately follows that ∈ . Therefore, it suffices to keep the nodes in grey (same as the case when <sup>1</sup> is inserted before 2) and update only their counters. This prevents over-counting the contribution of a particular in-neighbour while computing the in-counts.

Consider what happens during the insertion of an interval .

- (1) If the algorithm encounters a grey node, it takes note of this visit and proceeds with the insertion process. In the end, if it reaches a white node, it simply returns and moves on to the next interval in . On the other hand, if the algorithm reaches a grey node, then it changes the color of this node, back to white.
- (2) If the search for ends in a grey/white node and every other node visited by the algorithm was white in color, then it retains that node's color and proceeds to the next interval.

In the end, a node will be white in color if either

- (1) none of the intervals in belong to the canonical subset of or
- (2) has an ancestor whose canonical subset contains an interval ∈

In our example, at the end of phase 2, only node 1 will be grey in color. In fact, consider the suitable path of in , for some temporal edge = (, , ). Let 1, <sup>2</sup> and <sup>3</sup> denote the grey nodes on this path, in the decreasing order of their height. At the end of phase 2, only <sup>1</sup> will be grey, since it is the only grey node on , which is reachable from the root via an entirely white path. Further, this will holds irrespective of the order on which the intervals are inserted. Finally, we have phase 3.

Phase 3: Once the algorithm has identified the nodes in , now all it needs to do is suitably update the counters of these nodes by reinserting the intervals in . In this phase, the algorithm re-inserts the intervals of . As before, during the insertion of an interval ,

- (1) If the algorithm encounters a grey node, or it visits a white node with Counter() > 1, then it simply returns and moves on to the next input interval.
- (2) On the other hand, if the algorithm ends in a grey node, then it changes the color of that node back to white and updates its counter by adding 1 to it.

#### Why the Vertex field in the node structure?

Suppose there exists a list <sup>2</sup> = ,, = { [8, 14]}. Observe that <sup>3</sup> = [8, 14] belongs to the canonical subset of node 2. Therefore, during the insertion of 3, the algorithm will visit node 1. Since Counter(1) > 0, it will simply return. Therefore, the suitable path for = (, , 9) will return 1 as opposed to 2, since and are 2 different vertices in − () ∩ (), which have the property that their corresponding lists ,, and ,, , contain at least one interval with 9 in it. This is where the vertex field comes to the rescue.

For a node in , Vertex() keeps track of the most recent vertex which caused Counter() to be updated.

In particular, after inserting the intervals of ,, , suppose the algorithm needs to insert intervals in ,, for some ≠ in phase 3. Given an interval ∈ ,, ,

- (1) If the algorithm encounters a grey node, then simply return and move on to the next interval of ,, .
- (2) If the algorithm visits a white node with Counter() > 0, then check for Vertex(). If Vertex() ≠ , then continue with the insertion process. On the contrary, if Vertex() = , then return.
- (3) If the algorithm reaches(i.e. ends in) a grey node , then simply update its color to white, increment it's associated counter by 1 and set Vertex() to .

Note that phases 1 and 2 will not change. The above procedure is used in phase 3.

Combining these ideas, the overall algorithm is presented in Algorithms[-5.](#page-9-0)

### How to build the Segment Tree?

All throughout, we assumed that each static edge comes with pre-initialised segment trees. We now describe how to build the segment tree , . Note that in order to construct a segment tree, it is sufficient to specify the segments which will be stored in the leaves of the tree.

<span id="page-15-0"></span>![](_page_15_Figure_19.jpeg)

(a) Insertion of intervals into a segment tree

![](_page_15_Figure_21.jpeg)

(b) Insertion into segment tree. The algorithm encounters a node with non-zero counter during the insertion of [8, 10], so it returns.

![](_page_15_Figure_24.jpeg)

(c) If the orders of the intervals [6, 13] and [8, 10] are switched, we end up with the same issue.

### Figure 8: Insertion into Segment Trees

Typically, given a collection of intervals , its segment tree is built using the distinct endpoints of the intervals in [\[9\]](#page-11-11). However, in our case, the number of such endpoints can be very large. Instead we build , (and ,) using the timestamps of the temporal edges (, , )(and (, , )) for ∈ R. In particular, if = {1, 2, . . . , } denotes the collection of distinct timestamps of the temporal edges from to , then the leaves of the segment tree will consist of the following segments (1, 1], (1, 2], (2, 2], (2, 3], . . . , (, ].

Note that the intervals we wish to insert in , may not necessarily have the same endpoints as timestamps in . However given an interval :

<span id="page-16-0"></span>

![](_page_16_Figure_1.jpeg)

(a) Phase 1: Insert the intervals into the segment tree, update suitable colors but donot update the counters

![](_page_16_Figure_3.jpeg)

(b) Phase 2: Note the node with segment [7, 10] is the only grey node which is reachable from the root via an entirely white path. So we would like to retain its color. During insertion of [6, 13], the algorithm encounters [7, 10], in which case it will update FOUND to true, go all the way to node containing [8, 10], and change its color back to white.

![](_page_16_Figure_6.jpeg)

(c) Update the counters of grey nodes only.

#### Figure 9: Insertion into Segment Trees, different phases

- (1) If does not contain the timestamps in , then will not cause any update in to the fields of the nodes, stored in , , which is fine.
- (2) However, if does contain at least one of the timestamps in , then using binary-search, we can find the largest interval in with both endpoints in . For eg: if contains ≤ +<sup>1</sup> ≤

| Input: | 𝐼: interval,<br>: root of the segment tree<br>𝑇<br>𝑇 |
|--------|------------------------------------------------------|
|        | Color(𝑇<br>) =<br>Grey<br>1: if<br>then              |
| 2:     | return                                               |
|        | Seg(𝑇<br>)<br>3: if<br>⊆ 𝐼<br>then                   |
| 4:     | Color(𝑇<br>)←<br>Grey                                |
| 5:     | return                                               |
|        | 6: if<br>𝐼<br>∩ Seg(LeftChild(𝑇<br>)) ≠ 𝜙<br>then    |
| 7:     | if<br>Color(LeftChild(𝑇<br>)) = Grey<br>then         |
| 8:     | return                                               |
| 9:     | else                                                 |
| 10:    | Phase1(LeftChild(𝑇<br>),<br>𝐼)                       |
| 11: if | 𝐼<br>∩ Seg(RightChild(𝑇<br>)) ≠ 𝜙<br>then            |
| 12:    | if<br>Color(RightChild(𝑇<br>)) = Grey<br>then        |
| 13:    | return                                               |
| 14:    | else                                                 |
| 15:    | Phase1(RightChild(𝑇<br>),<br>𝐼)                      |
|        |                                                      |

· · · ≤ , then using binary search, we can extract the interval [ , ] and subsequently use it as a proxy for during the insertion process.

Putting it all together, the overall procedure is presented in Algorithm[-4.](#page-7-0)

Theorem A.1. The InNeighbourssubroutine runs in( log max time

Proof. First, for every static edge {, }, the algorithm constructs a pair of segment trees. This takes ((, ) log max) time. So the overall time to construct the segment trees is

( Í {,} ∈( ) (, ) log max) = ( log max).

Now consider a edge (, ) ∈ → and ∈ + (). First, in line 5, the algorithm gets the lists 1, <sup>2</sup> and 3. Then it invokes FindExceedingEntryLS, which takes ((, ) + (,)) time. Next, it inserts into the segment tree. Let ℎmax be the maximum height of the segment trees associated with the static edges in .

Consider the subroutine InsertSegTree(,,,,, ). This subroutine inserts the intervals of the list ,, in the segment tree ,. Insertion of an interval in , takes (ℎmax) time [refer chp. 10 of [\[9\]](#page-11-11)]. Therefore, the overall time it takes to insert the intervals which belong to the list ,, in , is given by (|,, |ℎmax). However, note that |,, | ≤ (, ).

Putting these facts together, the time it takes for the algorithm to insert the intervals in the segment tree is

( Í (,) ∈(→ ) Í ∈ <sup>+</sup> () (, )ℎmax). Note thatℎmax ≤ log max. Therefore, the overall run time is ( log max).

Additionally, for every temporal edge , getting the value of incount[] essentially involves looking up a path in a suitable segment tree. This can be done in time, proportional to the height of the tree. Therefore, the overall run time of lines 16-18 is ( log max).

Combining all these together, the overall run time of the subroutine is ( log max).

□

<span id="page-17-0"></span>

```
Algorithm 11 : LookUpSegTree(, )
```

Input: : timestamp, : root of a segment tree 1: sum ← 0 2: if ∈ Seg( ) then

3: sum ← sum + Counter( )

- 4: if ∈Seg(LeftChild( )) then
- 5: LookUpSegTree(,LeftChild( ))
- 6: else
- 7: LookUpSegTree(,RightChild( ))
- 8: return sum