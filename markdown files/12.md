# Hiord <sup>♯</sup> : An Approach to the Specification and Verification of Higher-Order (C)LP Programs<sup>∗</sup>

[MARCO CICCALÈ,](https://orcid.org/0009-0000-8821-0587) [DANIEL JURJO-RIVAS](https://orcid.org/0000-0001-6215-1080) and [JOSE F. MORALES](https://orcid.org/0000-0001-9782-8135)

Universidad Politécnica de Madrid (UPM), IMDEA Software Institute, Madrid, Spain (e-mails: [m.ciccale@alumnos.upm.es](mailto:m.ciccale@alumnos.upm.es), [marco.ciccale@imdea.org](mailto:marco.ciccale@imdea.org), [daniel.jurjo@alumnos.upm.es](mailto:daniel.jurjo@alumnos.upm.es), [daniel.jurjo@imdea.org](mailto:daniel.jurjo@imdea.org), [josefrancisco.morales@upm.es](mailto:josefrancisco.morales@upm.es), [josef.morales@imdea.org](mailto:josef.morales@imdea.org))

# [PEDRO LÓPEZ-GARCÍA](https://orcid.org/0000-0002-1092-2071)

Spanish Council for Scientific Research, IMDEA Software Institute, Madrid, Spain (e-mails: [pedro.lopez@csic.es](mailto:pedro.lopez@csic.es), [pedro.lopez@imdea.org](mailto:pedro.lopez@imdea.org))

# [MANUEL V. HERMENEGILDO](https://orcid.org/0000-0002-7583-323X)

Universidad Politécnica de Madrid (UPM), IMDEA Software Institute, Madrid, Spain (e-mails: [manuel.hermenegildo@upm.es](mailto:manuel.hermenegildo@upm.es), [manuel.hermenegildo@imdea.org](mailto:manuel.hermenegildo@imdea.org))

submitted 29 04 2025; revised 22 06 2025; accepted 07 07 2025

## Abstract

Higher-order constructs enable more expressive and concise code by allowing procedures to be parameterized by other procedures. Assertions allow expressing partial program specifications, which can be verified either at compile time (statically) or run time (dynamically). In higherorder programs, assertions can also describe higher-order arguments. While in the context of (C)LP, run-time verification of higher-order assertions has received some attention, compile-time verification remains relatively unexplored. We propose a novel approach for statically verifying higher-order (C)LP programs with higher-order assertions. Although we use the Ciao assertion language for illustration, our approach is quite general and we believe is applicable to similar contexts. Higher-order arguments are described using predicate properties—a special kind of property which exploits the (Ciao) assertion language. We refine the syntax and semantics of these properties and introduce an abstract criterion to determine conformance to a predicate property at compile time, based on a semantic order relation comparing the predicate property with the predicate assertions. We then show how to handle these properties using an abstract interpretation-based static analyzer for programs with first-order assertions by reducing predicate properties to first-order properties. Finally, we report on a prototype implementation and evaluate it through various examples within the Ciao system.

KEYWORDS: Higher-Order, Static Analysis, Assertions, Abstract Interpretation, (Constraint) Logic Programming.

# 1 Introduction

Abstraction is a fundamental principle in computer science often used for managing complexity. Higher-order constructs are a form of abstraction that enables writing code that

<sup>∗</sup> Partially funded by MICIU projects CEX2024-001471-M María de Maeztu and TED2021-132464B-I00 PRODIGY, as well as by the Tezos foundation. We would also like to thank the anonymous reviewers for their very useful and constructive feedback.

is more concise and expressive by allowing procedures to be parameterized by other procedures, resulting in more modular and maintainable code. (Constraint) logic programming languages like Prolog [\(Körner et al.](#page-16-0) [2022\)](#page-16-0) and functional programming languages like Haskell [\(Marlow](#page-16-1) [2010\)](#page-16-1) have included different forms of higher-order since their early days, and languages from other programming paradigms like Java or C++ have adopted them later on. In particular, Prolog systems allow defining higher-order predicates and making higher-order calls. E.g., the query: **?-** filter(even,**[**7,4,9**]**,L), passes the term even as an argument to the higher-order predicate filter/3, which applies the even/1 predicate to each element of the input list, selecting those that succeed, yielding L **= [**4**]**. Assertions are linguistic constructs for writing partial program specifications, which can then be verified or used to detect deviations in program behavior w.r.t. such specifications. The assertion-based approach to program verification [\(Hermenegildo et al.](#page-16-2) [1999;](#page-16-2) [Puebla](#page-16-3) [et al.](#page-16-3) [2000b;](#page-16-3) [Sanchez-Ordaz et al.](#page-16-4) [2021\)](#page-16-4) differs from other approaches such as strong type systems [\(Cardelli](#page-15-0) [1989\)](#page-15-0) in that assertions are optional and can include properties that are undecidable at compile time, and thus some checking may need to be relegated to run time. Hence, the assertion-based approach is closer to gradual typing in functional languages [\(Siek and Taha](#page-16-5) [2006\)](#page-16-5). The combination of higher-order predicates and assertions in the (C)LP context was already explored by [Stulova et al.](#page-16-6) [\(2014\)](#page-16-6). This work introduced the notion of predicate properties, a special kind of properties that allow using the full power of the (Ciao) assertion language for describing the higher-order arguments of procedures. This work also proposed an operational semantics for dynamically checking higher-order (C)LP programs annotated with such higher-order assertions. However, the static verification of programs with higher-order assertions was not addressed in that work, and remains relatively unexplored since other related work in (C)LP that supports higher order (e.g., [Miller](#page-16-7) [\(1991\)](#page-16-7); [Somogyi et al.](#page-16-8) [\(1996\)](#page-16-8); [Hill and Lloyd](#page-16-9) [\(1994\)](#page-16-9)) generally adheres to the strong typing model. In this work we propose a novel approach for the compile-time verification of higher-order (C)LP programs with assertions describing higher-order arguments. We present a refinement of both the syntax and the semantics of predicate properties ([§3\)](#page-6-0). Next, we define an abstract criterion to determine whether a predicate conforms to a predicate property at compile time, based on a semantic order relation between the definition of a predicate property and the partial specification of a predicate ([§4.1\)](#page-7-0). Then, we introduce an approach for "casting" predicate usage in a program analysis-friendly manner that enhances and complements the proposed abstract criterion ([§4.2\)](#page-10-0). We also propose a technique for dealing with these properties using an abstract interpretation-based static analyzer for programs with first-order assertions, by representing predicate properties as first-order properties that are natively understood by such an analyzer ([§4.3\)](#page-12-0). Finally, we present a prototype implementation of these techniques and study its application to a number of examples ([§5\)](#page-13-0). For concreteness, we use in our presentation the Ciao [\(Hermenegildo et al.](#page-16-10) [2012\)](#page-16-10) assertion language, and make use of its CiaoPP preprocessor [\(Hermenegildo et al.](#page-16-11) [2005\)](#page-16-11), that combines both static and dynamic analysis. However, we believe the approach is quite general and flexible, and can be applied, at least conceptually, to similar gradual approaches.

### 2 Preliminaries and notation

<span id="page-2-0"></span>Variables start with a capital letter. The set of terms is inductively defined as follows: (1) variables are terms (2) if f is an n-ary function symbol and t1, . . . , t<sup>n</sup> are terms, then f(t1, . . . , tn) is a term. We use the overbar notation (¯·) to denote a finite sequence of elements (e.g., t¯ ≡ t1, . . . , tn), and write |(¯·)| for representing its length. An atom has the form p(t¯) where p is an n-ary predicate symbol, and t¯ are terms. The function ar(p) denotes the arity of a predicate p. A higher-order atom has the form X(t¯) where X is a variable and t¯ are terms. (Note that variables are not allowed in the function symbol position of terms, only in literals). A constraint is a conjunction of expressions built from predefined predicates whose arguments are constructed using predefined functions and variables, e.g., X − Y > abs(Z). A literal is either an atom, a higher-order atom, or a constraint. Negation is encoded as finite failure, supported through a program expansion. A goal is a finite sequence of literals. A rule has the form H :- B where H, the head, is an atom and B, the body, is a possibly empty finite sequence of literals. A higher-order constraint logic program, or higher-order program P is a finite set of rules. We use σ to represent a variable renaming, and σ(L) or Lσ to represent the result of applying σ to a syntactic object L. The definition of an atom L in a program, defn(L), is the set of renamed program rules s.t. each renamed rule has L as its head. We assume that all rule heads are normalized, i.e., H is an atom of the form p(¯v) where v¯ are distinct variables. Let ∃¯ <sup>L</sup>θ denote the projection of the constraint θ onto the variables of L. We denote constraint entailment by θ<sup>1</sup> |= θ2.

Operational semantics of higher-order programs. The operational semantics of a higher-order program P is given in terms of its derivations, which are sequences of reductions between states. A state ⟨G | θ⟩ consists of a goal G, and a constraint store (or store) θ. We denote sequence concatenation by (::). We assume for simplicity that the underlying constraint solver is complete and projection exists. We use S ❀ S ′ to indicate that a reduction step can be applied to state S to obtain state S ′ . Naturally, S ❀<sup>∗</sup> S ′ indicates that there is a sequence of reduction steps from S to S ′ . A state S = ⟨L :: G | θ⟩ where L is a literal, is reduced to a state S ′ as follows:

- 1. If L is a constraint and θ ∧ L is satisfiable, then S ′ = ⟨G | θ ∧ L⟩.
- 2. If L is an atom and ∃(L :- B) ∈ defn(L), then S ′ = ⟨B :: G | θ⟩.
- 3. If L is a higher-order atom of the form X(t¯), then S ′ = ⟨p(t¯) :: G | θ⟩ given that ∃p ∈ P. θ |= (X = p) ∧ ar(p) = |t¯|.

Let L be an atom, S = ⟨L :: G | θ⟩, S ′ = ⟨G | θ ′ ⟩, and suppose S ❀<sup>∗</sup> S ′ . We refer to S as a call state for L, and S ′ as a success state for L. A query Q is a pair (L, θ), where L is a literal and θ a store for which the (C)LP system starts a computation from state ⟨L| θ⟩. The set of all derivations of P from a query Q is denoted derivs(P, Q), and this notation is naturally extended to a set of queries Q. Let D[−1] denote the last state of any derivation D. A finite derivation from a query Q is finished if the last state in the derivation cannot be reduced. A finished derivation from a query Q is successful if the last state is of the form ⟨□ | θ ′ ⟩, where □ denotes the empty goal sequence. In that case, the constraint ∃¯ Lθ ′ is an answer to Q. We denote by answers(P, Q) the set of answers of P to a query Q. A finished derivation is failed if the last state is not of the form ⟨□ | θ⟩. A query Q finitely fails if all derivations in derivs(P, Q) are finished and have failed.

Property formulas. Conditions on the constraint store are stated as property formulas. A property formula is a DNF formula of property literals. A property literal is a literal corresponding to a special kind of predicates called properties. Properties are typically defined in the source language, in the same way as ordinary predicates but marked accordingly, and are required to meet certain conditions [\(Hermenegildo et al.](#page-16-2) [1999;](#page-16-2) [Puebla](#page-16-3) [et al.](#page-16-3) [2000b\)](#page-16-3). In particular, they are normally required to be checkable at run time but not necessarily decidable at compile time, where they are safely approximated.[1](#page-3-0)

# Example 2.1 (Properties)

The following program defines the properties **list**/1 ("being a list") and **prefix**/2 ("being a prefix of a list"):

```
1 :- prop list/1. list([]).
2 list([_|Xs]) :- list(Xs).
                                   3 :- prop prefix/2. prefix([],Ys) :- list(Ys).
                                   4 prefix([X|Xs],[X|Ys]) :- prefix(Xs,Ys).
```

The property formula (**list**(Xs),**list**(Ys),**prefix**(Xs,Ys)) states that Xs and Ys should be lists, and that Xs should be a prefix of Ys. This formula contains three property literals corresponding to the **list**/1 and **prefix**/2 properties. ✷

<span id="page-3-2"></span>We now recall an instrumental definition about properties from [Puebla et al.](#page-16-3) [\(2000b\)](#page-16-3):

### Definition 2.1 (Succeeds trivially)

A property literal L succeeds trivially for θ in a program P, denoted θ ⇒<sup>P</sup> L, iff ∃θ ′ ∈ answers(P,(L, θ)). θ |= θ ′ . A property formula succeeds trivially for θ if all of the property literals of at least one conjunct of the formula succeeds trivially. ✷

Intuitively, a property literal (or formula) succeeds trivially if it succeeds for θ in P without adding new "relevant" constraints to θ. E.g., **list**(X) checks "X being a list."

Traditional assertions. Assertions are syntactic objects for expressing properties of programs that must be satisfied at program execution. We recall the herein relevant parts of the assertion schema of [Puebla et al.](#page-16-12) [\(2000a\)](#page-16-12). Traditional (or first-order ) predicate (or pred) assertions have the following syntax: "**:- pred** Pred **:** Pre **=>** Post**.**," where Pred is a normalized atom representing a predicate, and Pre and Post are property formulas. They express that all calls to Pred must satisfy the pre-condition Pre, and, if such calls succeed, the post-condition Post must be satisfied. If there are several pred assertions, the Pre field of at least one of them must be satisfied.

# <span id="page-3-1"></span>Example 2.2 (Assertions)

The following assertions for the take/3 predicate relating a list and its prefix:

<sup>1</sup> **:- pred** take(N,Xs,Ys) **:** (**int**(N), **list**(Xs)) **=> prefix**(Ys,Xs)**.** <sup>2</sup> **:- pred** take(N,Xs,Ys) **:** (**list**(Xs), **prefix**(Ys,Xs)) **=> int**(N)**.**

restrict the meaning of take/3 as follows:

- take(N,Xs,Ys) must be called with Xs bound to a list, and either N bound to an integer or Ys bound to a prefix of Xs.
- if take(N,Xs,Ys) succeeds when called with N bound to an integer and Xs bound to a list, then Ys must be bound to a prefix of Xs.

<span id="page-3-0"></span><sup>1</sup> Ciao assertions can also include global properties, which may not always be checkable at run time (e.g., termination), but we focus for brevity on the described types of assertions and properties.

• if take(N,Xs,Ys) succeeds when called with Xs bound to a list and Ys bound to a prefix of Xs, then N must be bound to an integer. ✷

We represent checks on the store by a set of assertions with a set of assertion conditions.

### Definition 2.2 (Assertion conditions)

Given a predicate represented by a normalized atom Pred, and its corresponding set of assertions {A1, . . . , An} with A<sup>i</sup> = "**:- pred** Pred **:** Pre<sup>i</sup> **=>** Post <sup>i</sup>**.**," the set of assertion conditions for Pred is {C0, C1, . . . , Cn} with

$$
C_i = \begin{cases} \text{cells}(Pred, \bigvee_{j=1}^{n} Pre_j) & i = 0\\ \text{success}(Pred, Pre_i, Post_i) & i \in 1..n \end{cases}
$$

Condition C<sup>0</sup> encodes the checks that ensure that all calls to the predicate represented by Pred are within those admissible by the set of assertions; we refer to it as the calls assertion condition. Conditions C1, . . . , C<sup>n</sup> encode the checks for compliance of the successes for particular sets of calls, and we call them the success assertion conditions. ✷

From this point on, we denote by A both the set of assertions of the program and, interchangeably, its associated set of assertion conditions. Also, for a normalized atom Pred, A(Pred) denotes only the assertions of A associated to the predicate Pred.

Example 2.3 (Assertion conditions)

The set of assertion conditions for the set of pred assertions in Example [2.2](#page-3-1) is:

```
calls(take(N,Xs,Ys), (int(N), list(Xs)) ∨ (list(Xs), prefix(Ys,Xs)))
success(take(N,Xs,Ys), (int(N), list(Xs)), prefix(Ys,Xs))
success(take(N,Xs,Ys), (list(Xs), prefix(Ys,Xs)), int(N)) ✷
```

Operational semantics of higher-order programs with traditional assertions. This operational semantics checks whether assertion conditions hold or not while computing the derivations from a query, halting the derivation as soon as an assertion condition is violated. For identifying a possible assertion condition violation, every assertion condition C is related to a unique label ℓ via a mapping label(C) = ℓ. States of derivations are now of the form ⟨G | θ | E⟩, where E denotes the set of labels for falsified assertion conditions (with |E| ⩽ 1); while such set is unnecessary if execution halts upon an assertion condition violation, we include it to keep the semantics presented in this paper close to that of previous work. A finished derivation from a query Q = (L, θ) is now successful if the last state is of the form ⟨□ | θ ′ | ∅⟩, failed if the last state is of the form ⟨L ′ | θ ′ | ∅⟩, and erroneous if the last state is of the form ⟨L ′ | θ ′ | {ℓ}⟩. We also extend the set of literals with syntactic objects of the form check(L, ℓ) where L is a literal and ℓ is a label for an assertion condition, which we call check literals. Thus, a literal is now a constraint, an atom, a higher-order atom, or a check literal. We now recall the notion of Semantics with Assertions from [Stulova et al.](#page-16-13) [\(2018\)](#page-16-13), which we adapt to support higher-order atoms. A state S = ⟨L :: G | θ | ∅⟩, can be reduced to a state S ′ , denoted S ❀<sup>A</sup> S ′ , as follows:

1. If L is a constraint or a higher-order atom, then S ′ = ⟨G′ | θ ′ | ∅⟩, with G′ and θ ′ obtained as in the operational semantics without assertions: ⟨L :: G | θ⟩ ❀ ⟨G′ | θ ′ ⟩. 2. If L is an atom and ∃(L :- B) ∈ defn(L), then

$$
S' = \begin{cases} \langle G | \theta | \{ \ell \} \rangle & \text{if } \exists C = \text{calls}(L, Pre) \in \mathcal{A}. \text{ label}(C) = \ell \land \theta \neq_P Pre \\ \langle B : PostC : G | \theta | \varnothing \rangle & \text{otherwise} \end{cases}
$$

where PostC = check(L, ℓ1) :: . . . :: check(L, ℓn) includes all the checks check(L, ℓi) such that ℓ<sup>i</sup> = label(Ci), with C<sup>i</sup> = success(L,Pre<sup>i</sup> ,Post <sup>i</sup>) ∈ A ∧ θ ⇒<sup>P</sup> Pre<sup>i</sup> .

3. If L is a check literal check(L ′ , ℓ), then

$$
S' = \begin{cases} \langle G | \theta | \{ \ell \} \rangle & \text{if } \exists C = \text{success}(L, \_, Post) \in \mathcal{A}. \text{ label}(C) = \ell \land \theta \nRightarrow_{P} Post \\ \langle G | \theta | \varnothing \rangle & \text{otherwise} \end{cases}
$$

The set of derivations for a program P with assertions A from a set of queries Q using the semantics with assertions is denoted derivsA(P, Q). Given a predicate represented by a normalized atom L, a store θ, and a set of queries Q, we define the success context SA(L, θ, P, Q) of L and θ for P and Q as {∃¯ Lθ ′ | ∃D ∈ derivsA(P, Q). ∃G. ⟨L :: G | θ⟩ ∈ D. D[−1] = ⟨G | θ ′ ⟩}. Intuitively, the success context of a predicate p with its assertions is the set of stores of the success states of p obtained using the semantics above.

Static program analysis by abstract interpretation. Abstract interpretation [\(Cousot and Cousot](#page-16-14) [1977\)](#page-16-14) is a mathematical framework for constructing sound, static program analysis tools. These tools extract properties about a program by interpreting it over a special abstract domain (D<sup>♯</sup> ), whose elements are finite representations of (possibly infinite) sets of actual constraints in the concrete domain (D). Elements of the concrete and abstract domains are related by two functions: abstraction (α : D → D<sup>♯</sup> ) and concretization (γ : D<sup>♯</sup> → D). Provided certain conditions on D<sup>♯</sup> , α, and γ, abstract interpretation guarantees soundness and termination of the analysis.

Goal-dependent abstract interpretation. We use, for concreteness, goal-dependent abstract interpretation, in particular the PLAI algorithm [\(Muthukumar and Hermenegildo](#page-16-15) [1992\)](#page-16-15). This technique takes a program P, an abstract domain D<sup>♯</sup> , and a set of initial abstract queries Q<sup>♯</sup> , describing all the possible initial concrete queries to P. An abstract query Q<sup>♯</sup> is a pair (L, λ), where L is an atom and λ ∈ D<sup>♯</sup> an abstraction of a set of concrete initial program states (e.g., constraint stores). A set of abstract queries Q<sup>♯</sup> represents a set of concrete queries defined as γ(Q<sup>♯</sup> ) = {(L, θ) | (L, λ) ∈ Q<sup>♯</sup> ∧ θ ∈ γ(λ)}. The algorithm computes a set of triples {⟨L1, λ<sup>c</sup> 1 , λ<sup>s</sup> 1 ⟩, . . . ,⟨Ln, λ<sup>c</sup> n , λ<sup>s</sup> n ⟩} where L<sup>i</sup> is an atom, and λ c i and λ s i are abstractions approximating the set of all call and success states for L<sup>i</sup> , respectively, for all occurrences of literal L<sup>i</sup> in all possible derivations of P from γ(Q<sup>♯</sup> ). Higher-order atoms are supported by reducing them to first-order calls when the called predicate can be determined by the analysis, or making conservative assumptions otherwise. For the rest of the paper, we assume that the abstract interpretation of a program P for the set of initial abstract queries Q<sup>♯</sup> , denoted by <sup>J</sup>P<sup>K</sup> ♯ Q<sup>♯</sup> , works with an implicit abstract domain D<sup>♯</sup> , which safely approximates the concrete values and operations. Although not strictly required, D<sup>♯</sup> has a lattice structure with a bottom-most element ⊥, meet (⊓), join (⊔), and less than (⊑) operators. As usual, ⊥ denotes the abstraction s.t. γ(⊥) = ∅.

Compile-time verification of (first-order) assertions. In addition to generating the results mentioned above, the analyzer also checks any (first-order) assertions in the program by safely approximating the property formulas of such assertions, and comparing

them against the analysis results (JP<sup>K</sup> ♯ <sup>Q</sup><sup>♯</sup> ) using the abstract operators.[2](#page-6-1) The verification result is reported as changes in the status and transformations of the assertions: **checked** if the properties are satisfied; **false** if some property is proved not to hold; or **check** if neither of the first two can be determined, in which case run-time checks will be inserted into the program to ensure run-time safety. The verification process yields an assignment of a value **checked**, **false**, or **check** to each assertion in <sup>A</sup>, denoted acheck(A, <sup>J</sup>P<sup>K</sup> ♯ <sup>Q</sup><sup>♯</sup> ).

#### 3 Specifying higher-order programs: predicate properties

<span id="page-6-0"></span>In higher-order (C)LP, variables can be bound to predicate symbols that are later invoked. This naturally gives rise to the need for expressing conditions on these predicates that must hold during program execution. To this end, predicate properties were introduced in [Stulova et al.](#page-16-6) [\(2014\)](#page-16-6), which we revise and refine here.[3](#page-6-2) A predicate property is defined as a set of anonymous assertions. Anonymous assertions generalize traditional assertions by allowing the predicate symbol in the Pred field to act as a placeholder.

#### Definition 3.1 (Anonymous assertion)

An anonymous assertion ◦A is an assertion whose Pred field is of the form \_(¯v), where v¯ are free, distinct variables, and \_ is a placeholder for a predicate symbol.[4](#page-6-3) Instantiating \_ with a specific predicate symbol p produces a traditional assertion for p derived from the anonymous assertion ◦A, denoted ◦A|p. ✷

#### Example 3.1 (Anonymous assertion)

Let ◦A be the anonymous assertion: "**:- pred** \_(X,Y) **: int**(X) **=> int**(Y)**.**." Then ◦A|<sup>p</sup> is the traditional assertion: "**:- pred** p(X,Y) **: int**(X) **=> int**(Y)**.**" obtained by instantiating the anonymous assertion ◦A with the predicate symbol p. ✷

#### Definition 3.2 (Predicate property)

A predicate property Π is a set of anonymous assertions { ◦A1, . . . , ◦An}. Its syntax is: "Π **:=** { **:- pred** \_(¯v) **:** Pre<sup>1</sup> **=>** Post1**.** . . . **:- pred** \_(¯v) **:** Pre<sup>n</sup> **=>** Postn**.** }**.**". The function ar(Π) denotes the arity of the predicates for which all of the anonymous assertions in Π express a property. Instantiating Π with a specific predicate symbol p produces a set of traditional assertions for p, denoted Π|<sup>p</sup> = { ◦A1|p, . . . , ◦An|p}. ✷

We use Π to refer to both a set of anonymous assertions and, interchangeably, the corresponding set of anonymous assertion conditions; extending instantiation accordingly.

#### Example 3.2 (Predicate property)

The following program defines the predicate property **int\_op** ("being a predicate that behaves as an integer nondeterministic binary operator"), and a higher-order assertion:

```
1 int_op := { :- pred _(X,Y,Z) : (int(X), int(Y)) => int(Z). }.
2 :- pred eval(A,B,Op,R) : (int(A), int(B), int_op(Op)) => int(R).
```

<span id="page-6-1"></span><sup>2</sup> We refer the reader to [Puebla et al.](#page-16-3) [\(2000b\)](#page-16-3); [Sanchez-Ordaz et al.](#page-16-4) [\(2021\)](#page-16-4) for the technical details on this subject.

<span id="page-6-2"></span><sup>3</sup> We propose a more compact syntax here that avoids having to use a named variable for the anonymous predicate symbol (as in [Stulova et al.](#page-16-6) [\(2014\)](#page-16-6)) and takes advantage of functional notation (**:=**).

<span id="page-6-3"></span><sup>4</sup> We also use for compactness "\_" as anonymous functor, a syntactic extension from the Ciao hiord package [\(Cabeza et al.](#page-15-1) [2004\)](#page-15-1), but double quotes '' can also be used to stay within ISO-Prolog syntax.

The predicate property literal **int\_op**(Op) states that Op should be a 3-ary predicate s.t., if called with its first two arguments bound to integers, then its third argument should be bound to an integer upon success. The higher-order assertion for the eval/4 predicate states that it must be called with its first two arguments bound to integers and its third argument bound to a predicate that conforms to property **int\_op**, and that if any such call succeeds, then its fourth argument should be bound to an integer. ✷

#### <span id="page-7-3"></span>4 Verifying higher-order programs

Once established how to specify higher-order programs using predicate properties, we now concentrate on how to verify such programs. We first recall some instrumental definitions from [Puebla et al.](#page-16-3) [\(2000b\)](#page-16-3) for reasoning about abstractions of property formulas. For the rest of the discussion, let P be a program and F a property formula defined in P.

Definition 4.1 (Trivial success set) We define the trivial success set of F as F ♮ = {∃¯ <sup>F</sup> θ | θ ⇒<sup>P</sup> F}. ✷

Example 4.1 (Trivial success set)

Let F = **list**(L), both θ<sup>1</sup> = {L **= [**1,2**]**} and θ<sup>2</sup> = {L **= [**1,X**]**} are in F ♮ , but θ<sup>3</sup> = {L **= [**1**|**\_**]**} is not, since a call to (L **= [**1**|**\_**]**, **list**(L)) would further instantiate the second argument of **[**1**|**\_**]**. The trivial success set F ♮ of F captures the notion that the **list**(L) property formula requires L to be instantiated to (the structure of) a list. ✷

<span id="page-7-2"></span>Definition 4.2 (Abstract trivial success subset) An abstraction is an abstract trivial success subset of F, denoted F <sup>♯</sup><sup>−</sup>, iff γ(F <sup>♯</sup><sup>−</sup>) ⊆ F ♮ . ✷

<span id="page-7-4"></span>Definition 4.3 (Abstract trivial success superset)

An abstraction is an abstract trivial success superset of F, denoted F <sup>♯</sup><sup>+</sup>, iff γ(F <sup>♯</sup>+) ⊇ F ♮ .✷

Intuitively, F <sup>♯</sup><sup>−</sup> and F <sup>♯</sup><sup>+</sup> are, respectively, a safe under- and over-approximation of the trivial success set F ♮ of the property formula F, and they can always be computed at compile-time by choosing the closest element in the abstract domain.

#### <span id="page-7-1"></span>4.1 Conformance to a predicate property

<span id="page-7-0"></span>When we provide a partial specification for a higher-order argument X of a higher-order predicate using a predicate property Π, we are describing requirements that the predicates that X may be bound to must meet. We refer to a predicate p behaving correctly w.r.t. Π as: p conforming to Π. We will now formalize this notion, with the goal of being able to safely approximate the set of predicates that X can be bound to without violating Π.

Definition 4.4 (Covered predicate)

Given C = calls(\_(¯v), ◦Pre) ∈ Π and ◦C = calls(p(¯v),Pre) ∈ A, we say that p can be covered with Π iff ◦Pre♮ ⊆ Pre♮ . ✷

<span id="page-7-5"></span>Intuitively, p can be covered with Π if the set of admissible calls to p is a superset of the set of admissible calls described by Π.

# Definition 4.5 (Redundance)

Under the same conditions as in Definition [4.4,](#page-7-1) given that p can be covered with Π, we define the set of assertion conditions A′ as follows:

$$
\mathcal{A}' = \{\text{calls}(p(\bar{v}), \text{Pre} \land \text{Pre})\} \cup (\mathcal{A} \setminus \{C\}) \cup (\Pi \setminus \{\text{C}\})|_p
$$

Given a sequence of literals G, let U(G) denote the result of removing all check literals from G. We extend U to derivations so that U(D) denotes the derivation resulting from transforming any (extended) state ⟨G | θ | E⟩ in D into the state ⟨G′ | θ⟩, where G′ = U(G). Let Q<sup>p</sup> be a query to p. We say that Π is redundant for p under Q<sup>p</sup> iff

$$
\forall D'\in\mathsf{derivs}_{\mathcal{A}'}(P,Q_p). \ \ D'_{[-1]}=\langle G'\,|\,\theta\,|\,\{\ell'\}\rangle,
$$

and

$$
\forall D \in \mathsf{derivs}_{\mathcal{A}}(P, Q_p). \ \mathcal{U}(D) = \mathcal{U}(D'),
$$

it holds that D[−1] ❀<sup>∗</sup> <sup>A</sup> ⟨G | θ | {ℓ}⟩ through a derivation that reduces only check literals (if any at all),[5](#page-8-0) where ℓ (resp., ℓ ′ ) is the label for a calls or success assertion condition in A(p(¯v)) (resp., A′ (p(¯v))). ✷

Intuitively, a predicate property Π is redundant for a predicate p under a query Q<sup>p</sup> to p iff augmenting the original set of assertion conditions (A) with that of Π (A′ ) does not introduce new run-time check errors in any derivation starting from Qp. [6](#page-8-1)

#### <span id="page-8-4"></span>Definition 4.6 (Conformance)

Let Q<sup>p</sup> be the set of all possible queries to p. A predicate p conforms to Π, denoted p ≺ Π, iff ∀Q<sup>p</sup> ∈ Qp. Π is redundant for p under Qp. Conversely, p does not conform to Π, denoted p ⊀ Π, iff ∃Q<sup>p</sup> ∈ Qp. Π is not redundant for p under Qp. ✷

To prove that a predicate conforms to a predicate property, all possible derivations from all possible queries to that predicate have to be considered, which is often not feasible in practice. To this end, we introduce the notion of abstract conformance as a compiletime conformance criterion. Abstract conformance safely approximates the notion of conformance by comparing the assertion conditions of a predicate and those of a predicate property under the order relation of an abstract domain. We denote by (≺<sup>♯</sup><sup>−</sup>) the notion of strong abstract conformance, and by (≺<sup>♯</sup><sup>+</sup>) that of weak abstract conformance. I.e., an under- and over-approximation of abstract conformance, respectively. Intuitively, strong abstract conformance captures only predicates known to conform, while weak abstract conformance also includes those for which conformance is unknown. Thus, the negation of weak abstract conformance captures the predicates that are known not to conform.

### <span id="page-8-3"></span>Definition 4.7 (Abstract conformance on "calls")

Let Pre be the pre-condition of the calls assertion condition for p in A, and ◦C be an anonymous calls assertion condition calls(\_(¯v), ◦Pre). Then:

$$
p \prec^{\sharp -} C \Leftrightarrow (Pre^{\sharp +} \sqsubseteq \,^{\circ}\! Pre^{\sharp -}) \land (Pre^{\sharp -} \sqsupseteq \,^{\circ}\! Pre^{\sharp +})
$$
  
$$
p \not\prec^{\sharp +} \,^{\circ}\! C \Leftrightarrow Pre^{\sharp +} \sqcap \,^{\circ}\! Pre^{\sharp +} = \bot
$$

<span id="page-8-2"></span><span id="page-8-0"></span><sup>5</sup> Note that this implies U(G) = U(G′ ).

<span id="page-8-1"></span><sup>6</sup> Note that, for the purposes of determining conformance, the assertions for the predicates in the program can be provided by the user, inferred by analysis, or a combination of both.

<span id="page-9-0"></span>![](_page_9_Figure_1.jpeg)

Figure 1: Example case analysis on a predicate property and assertions.

# Definition 4.8 (Abstract conformance on "success")

Let A be the set of assertion conditions for p, and ◦C be an anonymous success assertion condition success(\_(¯v), ◦Pre, ◦Post). Then:

$$
p \prec^{\sharp -} C \Leftrightarrow \exists S \subset \mathcal{A}, (Pre_{\sqcup}^{\sharp -} \sqsupseteq^0 Pre^{\sharp +}) \land (Post_{\sqcup}^{\sharp +} \sqsubseteq^0 Post^{\sharp -}),
$$
  
\nwhere\n
$$
\begin{cases}\nPre_{\sqcup}^{\sharp -} = \sqcup \{Pre^{\sharp -} \mid \text{success}(p(\bar{v}), Pre, \_) \in S\} \\
Post_{\sqcup}^{\sharp +} = \sqcup \{Post^{\sharp +} \mid \text{success}(p(\bar{v}), \_, Post) \in S\} \\
p \prec^{\sharp +} \circ C \Leftrightarrow \exists \text{success}(p(\bar{v}), Pre, Post) \in \mathcal{A}, (Pre^{\sharp +} \sqsubseteq^0 Pre^{\sharp -}) \land \\
\land (Post^{\sharp +} \sqcap \text{Post}^{\sharp +} = \bot) \land \exists \theta \in Pre^{\sharp}. \ S_{\mathcal{A}}(p(\bar{v}), \theta, P, \gamma(\mathcal{Q}_{p}^{\sharp})) \neq \varnothing\n\end{cases}
$$

where Q<sup>♯</sup> p is the set of abstract queries s.t. γ(Q<sup>♯</sup> p ) is a superset of the set of all valid queries to p described by the calls assertion condition of p in A. ✷

<span id="page-9-1"></span>Definition 4.9 (Abstract conformance)

We define abstract conformance to a predicate property as follows:

<span id="page-9-2"></span>
$$
p \prec^{\sharp -} \Pi \Leftrightarrow \forall \, ^{\circ}C \in \Pi_C. \ p \prec^{\sharp -} ^{\circ}C
$$
  
$$
p \not\prec^{\sharp +} \Pi \Leftrightarrow \exists \, ^{\circ}C \in \Pi_C. \ p \not\prec^{\sharp +} ^{\circ}C
$$

Note that abstract conformance is computed by first computing the abstract trivial success subsets or supersets of the involved property formulas, and then applying the operators of the abstract domain. For abstract domains which may lose precision with their (⊔) abstract operator, more advanced techniques for leveraging multiple abstractions become necessary, e.g., covering [\(Debray et al.](#page-16-16) [1997\)](#page-16-16). We now relate the notions of conformance and abstract conformance.

Theorem 4.1

Let p be a predicate, Π be a predicate property: p≺<sup>♯</sup><sup>−</sup> Π ⇒ p≺Π, and p⊀♯<sup>+</sup> Π ⇒ p⊀Π. ✷

Proof The proofs proceed by contradiction and direct proof, respectively, using Defs. [4.2](#page-7-2) to [4.8](#page-8-2) and some basic set manipulation. Detailed proofs can be found in Appendix [A.](#page-17-0) ✷

# Example 4.2 (Abstract conformance)

Consider determining conformance to the predicate property in Figure [1a—](#page-9-0)which, for simplicity, we will interchangeably refer to as Π for the rest of the example—given the assertions A = {A1, . . . , A5} in Figure [1b.](#page-9-0) (Notice that the property formulas of both Π and A include elements of the abstract domain represented by the lattice in Figure [1c\)](#page-9-0).

<span id="page-10-1"></span>

| Predi     | Prei    | Relation w. ◦Pre                                                                      | Abs. Conf. |
|-----------|---------|---------------------------------------------------------------------------------------|------------|
| n2n(X,Y)  | nat(X)  | nat(X) = nat(X)                                                                       | yes        |
| a2n(X,Y)  | atm(X)  | atm(X) ⊓<br>nat(X) = ⊥                                                                | no         |
| i2z(X,Y)  | int(X)  | int(X) ⊒<br>nat(X)                                                                    | maybe      |
| z2i(X,Y)  | zero(X) | zero(X) ⊑<br>nat(X)                                                                   | maybe      |
| nz2n(X,Y) | negz(X) | negz(X) ⊓<br>nat(X) ̸=<br>⊥<br>∧<br>negz(X) ̸⊑<br>nat(X)<br>∧<br>negz(X) ̸⊒<br>nat(X) | maybe      |

Table 1: Abs. conf. on "calls" example with ◦Pre = **nat**(X).

<span id="page-10-2"></span>Table 2: Abs. conf. on "success" example with ◦Pre = **nat**(X) and ◦Post = **nat**(Y).

| Predi     | Prei    | Relation w. ◦Pre                                                                      | Post i  | Relation w. ◦Post   | Abs. Conf. |
|-----------|---------|---------------------------------------------------------------------------------------|---------|---------------------|------------|
| n2n(X,Y)  | nat(X)  | nat(X) = nat(X)                                                                       | nat(Y)  | nat(Y) = nat(Y)     | yes        |
| a2n(X,Y)  | atm(X)  | atm(X) ⊓<br>nat(X) = ⊥                                                                | nat(Y)  | nat(Y) = nat(Y)     | maybe      |
| i2z(X,Y)  | int(X)  | int(X) ⊒<br>nat(X)                                                                    | zero(Y) | zero(Y) ⊑<br>nat(Y) | yes        |
| z2i(X,Y)  | zero(X) | zero(X) ⊑<br>nat(X)                                                                   | int(Y)  | int(Y) ⊒<br>nat(Y)  | maybe      |
| nz2n(X,Y) | negz(X) | negz(X) ⊓<br>nat(X) ̸=<br>⊥<br>∧<br>negz(X) ̸⊑<br>nat(X)<br>∧<br>negz(X) ̸⊒<br>nat(X) | nat(Y)  | nat(Y) = nat(Y)     | maybe      |

Their corresponding sets of assertion conditions are:

Π = {calls(\_(X,Y), **nat**(X)), success(\_(X,Y), **nat**(X), **nat**(Y))} A = {calls(Pred<sup>i</sup> ,Prei), success(Pred<sup>i</sup> ,Pre<sup>i</sup> ,Post <sup>i</sup>) | A<sup>i</sup> ∈ A}

We aim to determine which predicates partially specified by A abstractly conform to the predicate property Π. For each predicate Pred<sup>i</sup> and its associated calls and success assertion conditions, we: (1) determine abstract conformance to the anonymous calls condition of Π; (2) determine abstract conformance to the anonymous success condition of Π; and (3) determine abstract conformance to Π:

Tables [1](#page-10-1) and [2](#page-10-2) summarize the abstract conformance analysis between the calls and success assertion conditions of each predicate and those of Π, respectively. Specifically, for calls (in Table [1\)](#page-10-1), we compare the pre-conditions and apply Definition [4.7;](#page-8-3) for success (in Table [2\)](#page-10-2), we compare both pre- and post-conditions and apply Definition [4.8.](#page-8-2) As a summary, the only predicate that definitely conforms to **p\_nat\_nat** is n2n/2, since both of its assertion conditions conform to Π. ✷

#### 4.2 Wrappers

<span id="page-10-0"></span>Consider a predicate p and a predicate property Π s.t. p can be covered by Π. From Definition [4.4](#page-7-1) we know that given their respective pre-conditions Pre and ◦Pre, Pre♮ ⊇ ◦Pre♮ . Thus, according to Definition [4.7,](#page-8-3) p may abstractly conform to Π (p ≺<sup>♯</sup><sup>+</sup> Π), since Pre

may describe more admissible call states for p than ◦Pre, which can lead to omitting some run-time check errors that would be raised by ◦Pre.

Example 4.3 (Weak abstract conformance)

Consider a query **?-** foo(even) to the following program.

```
1 p_nat := { :- pred _(N) : nat(N). }. % 1-ary predicates for naturals.
2
3 :- pred even(N) : int(N). :- pred foo(P) : p_nat(P).
4 even(N) :- foo(P) :- P(10). % (1)
5 integer(N), 0 is N mod 2. foo(P) :- P(-10). % (2)
```

Take a derivation of such query that starts by reducing to the body of the first clause (1): no calls assertion condition violation is expected since all predicates that conform to **p\_nat** must accept all natural numbers on calls. Now, take a derivation that reduces to the body of the second clause (2): a calls assertion condition violation is expected since all predicates that conform to **p\_nat** must raise an error for any input different from a natural number. However, in this particular case, no error is raised, since the predicate even/1 accepts any integer on calls. Moreover, if we had:

```
6 p_neg := { :- pred _(N) : neg(N). }. % 1-ary predicates for negatives.
7
8 :- pred bar(P) : p_neg(P).
9 bar(P) :- P(-4).
```

then a clause like foo(P) **:-** bar(P)**.** would be problematic. For this clause, looking at the assertion of foo(P), the predicate in P is required to conform to **p\_nat**, which would be an error when calling bar(P) since **p\_neg** is disjoint from **p\_nat**. However, if we consider the particular case in which P = even, it may not. So, according to Definition [4.7,](#page-8-3) we could only conclude that even/1 ≺♯<sup>+</sup> **p\_nat**, i.e., even/1 may abstractly conform. ✷

In the example above, we motivate the need for such a restrictive condition for abstract conformance on calls (see Definition [4.7\)](#page-8-3). However, we may want to use predicates whose set of admissible calls is greater than that of a predicate property, but without unexpected behavior. To this end, we propose a technique to restrict the set of admissible calls of a predicate p described by Pre to match that of ◦Pre in a program analysis friendly manner. This restriction is implemented using wrappers. A wrapper for p with Π is simply a new predicate w(¯v) :- p(¯v) with an assertion "**:- pred** w(¯v) **:** ◦Pre**.**" (note that fields of pred assertions, in this case the post-condition, can be omitted, equivalently to true). A wrapper for p with Π also makes explicit the intention of creating a Π-tailored version of p. Additionally, wrappers can also be used to alleviate the process of determining abstract conformance on calls (particularly useful in the implementation), since the wrapper would syntactically (and thus, semantically) match the pre-condition of the predicate property.

Example 4.4 (Wrapper )

As a follow-up of the previous example, consider wrapping even/1 with **p\_nat**:

```
10 :- pred even_nat(N) : nat(N).
11 even_nat(N) :- even(N).
```

Intuitively, even\_nat/1 conforms to **p\_nat**, and the analyzer can now infer that the clause foo(P) **:-** bar(P)**.** should raise an error since even\_nat/1 only accepts naturals. ✷ Rationale for explicit wrappers. The design of Hiord <sup>♯</sup> follows the philosophy behind the Ciao system [\(Hermenegildo et al.](#page-16-10) [2012\)](#page-16-10), which extends Prolog with static and dynamic assertion checking (among other modular extensions) without altering its untyped nature. We also considered some alternative solutions to the problem at hand, such as tainting each predicate passed as an argument annotated with a predicate property, and restricting its future use in all internal (recursive) calls. However, this approach would have required modifying the standard Prolog semantics regarding higher-order calls. The use of wrappers allows us to simulate this behavior without altering the underlying semantics.

#### 4.3 First-order representation of predicate properties

<span id="page-12-0"></span>As mentioned in [§2,](#page-2-0) the abstract interpretation-based static analyzer can infer properties about higher-order programs, and also verify first-order assertions. However, here we obviously need to deal with predicate properties in assertions. Usually, for a new type of property, a new abstract domain is needed. As an alternative approach, we herein propose representing predicate properties as first-order properties of a kind which can be natively supported by the analyzer, thus allowing us to leverage existing and mature abstract domains. More concretely, we propose representing predicate properties as regular types, a special kind of properties (and thus defined as predicates) that are used to describe the shape of a term. Intuitively, such types will capture sets of predicate names. For example, given the predicate property **pp**, we can represent that the predicates p, and q strongly, and r weakly conforms to **pp** as the following regular types: **pp**−/1 = {**pp**−(p), **pp**−(q)} and **pp**+/1 = {**pp**+(p), **pp**+(q), **pp**+(r)}. [7](#page-12-1) Formally, given a predicate property Π, we define two associated regular types: π <sup>−</sup>/1 and π <sup>+</sup>/1, that capture the set of predicates that strongly and weakly abstractly conform to Π as follows: π <sup>−</sup>/1 = {π <sup>−</sup>(p) | p ∈ P ∧ p ≺♯<sup>−</sup> Π}, and π <sup>+</sup>/1 = {π <sup>+</sup>(p) | p ∈ P ∧ p ≺♯<sup>+</sup> Π}. By definition, π <sup>−</sup>/1 is a subtype of π <sup>+</sup>/1. These regular types reduce the compile-time checking of higher-order assertions to that of first-order assertions. Regular types can be abstracted and inferred by several abstract domains; for concreteness we use eterms [\(Vaucheret and Bueno](#page-16-17) [2002\)](#page-16-17).

# 4.4 Hiord <sup>♯</sup> algorithm

We now present Hiord <sup>♯</sup> , the core algorithm for the compile-time verification of a higherorder program P with higher-order assertions A (Algorithm [1\)](#page-13-1). First, it initializes a set of rules R, and it computes the regular type representations of each predicate property Π in P, i.e., the π <sup>−</sup> and π <sup>+</sup> predicates respectively (lines [4](#page-13-2) to [6\)](#page-13-3). This computation is performed by directly applying Definitions [4.7](#page-8-3) to [4.9](#page-9-1) using the operators of the abstract domain, and (implicitly) extending the program P with R. Since predicate properties can include predicate property literals from other predicate properties—i.e., dependencies among predicate properties—lines [4](#page-13-2) to [6](#page-13-3) are repeated until a fixpoint is reached (lines [2](#page-13-4) and [7\)](#page-13-5). Next, it computes the abstract interpretation of P, augmented with the regular type representations of every predicate property, for the set of abstract queries Q<sup>♯</sup> (line [8\)](#page-13-6). Finally, it performs the compile-time verification of the set of (now first-order) assertions A w.r.t. the static analysis results, where predicate properties are now treated as standard

<span id="page-12-1"></span><sup>7</sup> Or, using Ciao's functional notation: "**:- regtype pp**+/1**. pp**<sup>+</sup> **:=** <sup>p</sup> **<sup>|</sup>** <sup>q</sup> **<sup>|</sup>** <sup>r</sup>**.**."

<span id="page-13-1"></span>Algorithm 1 [Hiord <sup>♯</sup> ]: Verify a higher-order program with higher-order assertions

<span id="page-13-4"></span><span id="page-13-2"></span>Input: Program: P, assertions: A, abstract queries: Q<sup>♯</sup> Output: Verified status (**checked**/**false**/**check**) for the assertions A of P: V 1: R ← ∅ 2: repeat ▷ start fixpoint computation 3: R′ ← R ▷ save state to check fixpoint convergence 4: for all predicate property Π ∈ P do 5: R ← R ∪ {π <sup>−</sup>(p) | p ∈ P ∧ p ≺<sup>♯</sup><sup>−</sup> Π} ∪ {π <sup>+</sup>(p) | p ∈ P ∧ p ≺<sup>♯</sup><sup>+</sup> Π} ▷ regtypes 6: end for 7: until R = R′ ▷ fixpoint reached 8: V ← acheck(A, <sup>J</sup><sup>P</sup> <sup>∪</sup> <sup>R</sup><sup>K</sup> ♯ <sup>Q</sup><sup>♯</sup> ) ▷ first-order assertion checking process

<span id="page-13-6"></span><span id="page-13-5"></span><span id="page-13-3"></span>regular types (line [8\)](#page-13-6). As the result of the algorithm, we obtain the verified status of each assertion of A, where each assertion can be discharged (**checked**), disproved (**false**) and an error flagged, or left in **check** status, and subject to run-time checks, as in [Stulova](#page-16-6) [et al.](#page-16-6) [\(2014\)](#page-16-6). We argue that, despite the inherent complexity of the verification problem in hand, the proposed concepts make the compile-time checking algorithm clear and concise; and, more importantly, easily implementable using a first-order assertion checker.

#### 5 Implementation and experiments

<span id="page-13-0"></span>To demonstrate the potential of our approach, we have implemented a prototype of the Hiord <sup>♯</sup> technique as part of the Ciao system. It implements Algorithm [1](#page-13-1) and uses CiaoPP, the Ciao program preprocessor, with the eterms abstract domain. We ran experiments on a set of small but representative higher-order programs that were not possible to verify until this point. We illustrate below our experiments with a selection of these programs.

A synthetic benchmark. We started by defining a test case comprising a predicate property using an anonymous pred assertion and 25 predicates, each with a pred assertion, designed to exhaustively cover all possible orderings between the pre- and post-conditions of the predicate property and of each predicate. We then ran Hiord <sup>♯</sup> , obtaining the correct results that 2 predicates definitely did conform and 7 predicates definitely did not conform, with 16 predicates left where no definite conclusion could be reached.

Higher-order list utilities. We defined various partially specified higher-order utility predicates specialized for working with lists of a particular type **t**, e.g., **t**(X) **:- num**(X). For example, consider the **t\_cmp** predicate property defined below:

```
1 t_cmp := { :- pred _(X,Y) : (t(X), t(Y)). }.
```

which describes comparator predicates of elements of type **t**, that we then use in the higher-order assertion for a comparator-parameterizable quicksort implementation:

```
2 :- pred qsort(Xs,P,Ys) : (list(t,Xs), t_cmp(P)) => list(t,Ys).
```

and where the partition/4 predicate includes a call P(X,Y). The analysis is able to propagate the **t\_cmp** property on P to that point, and if in P(X,Y), X is inferred to be bound to, e.g., a, an error is statically captured by Hiord <sup>♯</sup> . Consider the following comparators:

```
3 :- pred lex(X,Y) : (term(X), term(Y)).
4 lex(X,Y) :- X @< Y.
```

```
5 :- pred lex_t(X,Y) : (t(X), t(Y)).
6 lex_t(X,Y) :- lex(X,Y).
```

For a query **?-** qsort(Xs,lex,Ys), Hiord <sup>♯</sup> reports a warning on calls since lex/2 ≺<sup>♯</sup><sup>+</sup> **t\_cmp** (it weakly abstractly conforms). Intuitively, lex/2 is not definitely conformant since it will not raise a run-time check error when called with a term that is not of type **t**, introducing unexpected behavior. For a query **?-** qsort(Xs,lex\_t,Ys) Hiord <sup>♯</sup> proves that it behaves correctly w.r.t. its higher-order assertion, since lex\_t/2 ≺<sup>♯</sup><sup>−</sup> **t\_cmp**.

Additionally, consider a predicate property which represents a parameterizable sorter of lists of elements of type **t**, defined "in terms of" the **t\_cmp** predicate property:

<sup>7</sup> **t\_sort :=** { **:- pred** \_(Xs,C,Ys) **:** (**list**(**t**,Xs), **t\_cmp**(C)) **=> list**(**t**,Ys)**.** }**.**

For determining that qsort/3 ≺♯<sup>−</sup> **t\_sort**, Hiord <sup>♯</sup> would need to perform an additional iteration of the fixpoint computation after the one above, i.e., after computing the predicates that weakly or strongly abstractly conform to the **t\_cmp** predicate property.

HTTP server. Consider the following schematic HTTP server, parameterized by a predicate that must be able to handle four REST operations. We use regular types for representing requests and responses, and a predicate property for representing handlers:

```
1 handler := { :- pred _(Rq,Rs) : req(Rq) => res(Rs). }.
2
3 :- regtype req/1. req := 'DELETE' | 'GET' | 'POST' | 'PUT'.
4 :- regtype res/1. res := 'OK' | 'CREATED' | 'BAD_REQUEST' | 'NOT_FOUND'.
```

and we add the following higher-order assertion to the server predicate:

```
5 :- pred server(H,Rq,Rs) : (handler(H), req(Rq)) => res(Rs).
```

Hiord <sup>♯</sup> detects that the predicate h/2 does not definitely conform to **handler** (h/2 ≺♯<sup>+</sup> **handler**) due to one its clauses:

<sup>6</sup> h('PUT', Rs) **:- ...**, Rs **=** 'BAD\_REQ'**.** % Bug, should be 'BAD\_REQUEST'

Dutch national flag. This problem involves sorting a list of red, white, or blue elements, such that elements of the same color are grouped together in a specified order (typically red, then white, then blue). However, we want to generalize the solution by allowing the user to provide a comparator that, given two elements, yields their comparison. We first define regular types to represent colored elements and the result of their comparison:

```
1 :- regtype rwb/1. rwb := r | w | b. 2 :- regtype lge/1. lge := < | > | = .
```

Next, we define a **dutch\_cmp** predicate property describing comparators between **rwb** elements; and provide a higher-order assertion to the dutch\_flag/3 higher-order predicate:

```
3 dutch_cmp := { :- pred _(X,R,Y) : (rwb(X), rwb(Y)) => lge(R). }.
4 :- pred dutch_flag(C,Xs,Ys) : (dutch_cmp(C), list(rwb,Xs)) => list(rwb,Ys).
```

Assume that we are given the implementation of dutch\_flag/3 and we need to provide a comparator cmp/3 which conforms to **dutch\_cmp**. Consider a first implementation attempt:

```
6 cmp(red,=, red). cmp(white,=,white). cmp(blue,=, blue).
7 cmp(red,<,white). cmp(white,>, red). cmp(blue,>, red).
8 cmp(red,<, blue). cmp(white,<, blue). cmp(blue,>,white).
                                                                      1 :- regtype rt1/1.
                                                                      2 rt1 := red | blue
                                                                      3 | white.
```

When determining its conformance to **dutch\_cmp**, Hiord <sup>♯</sup> finds that cmp/3 ⊀♯<sup>+</sup> **dutch\_cmp**, since CiaoPP infers the regular type **rt1** for the elements to compare, and **rt1** ⊓ **rwb** = ⊥ in eterms. We proceed by correcting it, but we accidentally mistype some of the r elements for o elements in lines [7](#page-15-2) and [8;](#page-15-3) and CiaoPP infers the following assertion and regular type:

```
6 :- pred cmp(X,R,Y) : (rt2(X), rwb(Y)) => lge(R).
7 cmp(o,=,r). cmp(w,=,w). cmp(b,=,b).
8 cmp(o,<,w). cmp(w,>,r). cmp(b,>,r).
9 cmp(r,<,b). cmp(w,<,b). cmp(b,>,w).
                                                                   1 :- regtype rt2/1.
                                                                   2 rt2 := r | b
                                                                   3 | w | o.
```

However, Hiord <sup>♯</sup> now reports that cmp/3 ≺<sup>♯</sup><sup>+</sup> **dutch\_cmp**, since it would not raise a runtime check error when called with an o on its first argument. Formally, (**rt2**(X), **rwb**(Y)) ⊒ (**rwb**(X), **rwb**(Y)) in eterms. In an attempt at improving the precision of the ordering, we refine cmp/3 to yield more informative results on the order relation between elements:

| 6 | :- pred cmp(X,R,Y) : (rwb(X), rwb(Y)) => lgLGe(R).<br>10 | :- regtype lgLGe/1.  |
|---|----------------------------------------------------------|----------------------|
| 7 | cmp(r, =,r). cmp(w,=,w). cmp(b, =,b).<br>11              | lgLGe :=<br><  <br>> |
| 8 | cmp(r, <,w). cmp(w,>,r). cmp(b,>>,r).<br>12              | <<   >>              |
| 9 | cmp(r,<<,b). cmp(w,<,b). cmp(b, >,w).<br>13              | <br>= .              |

In particular, we introduce **<<** and **>>** to reflect that X is "much lower" than Y, and viceversa; and define a new regular type and assertion. However, Hiord <sup>♯</sup> still reports that cmp/3 ≺♯<sup>+</sup> **dutch\_cmp**, since cmp/3 may yield comparison results that are not reflected in **lge**. Formally **lgLGe**(R) ⊒ **lge**(R) in eterms. Finally, we develop the following comparator:

```
6 :- pred cmp(X, R, Y) : (rwb(X), rwb(Y)) => lge(R).
7 cmp(r,=,r). cmp(w,=,w). cmp(b,=,b).
8 cmp(r,<,w). cmp(w,>,r). cmp(b,>,r).
9 cmp(r,<,b). cmp(w,<,b). cmp(b,>,w).
```

And Hiord <sup>♯</sup> proves that cmp/3 ≺♯<sup>−</sup> **dutch\_cmp**, since it behaves exactly as expected.

# 6 Conclusions

We have presented Hiord <sup>♯</sup> , a novel approach for the compile-time verification of higherorder (C)LP programs with higher-order assertions. We started by refining both the syntax and semantics of predicate properties. Then, we introduced an abstract criterion to determine whether a predicate conforms with a predicate property at compile time. We also motivated and explained a wrapper -based technique for "casting" predicate usage in a program analysis-friendly manner that enhances and complements the proposed abstract criterion. We then proposed a technique for dealing with these properties using an abstract interpretation-based static analyzer for programs with first-order assertions. Finally, we reported on a prototype implementation and studied the effectiveness of the approach with various examples within the Ciao system. We believe our proposal constitutes a practical approach to closing the existing gap in the verification at compile time of higher-order assertions; and that it is quite general and flexible, and can be applied, at least conceptually, to other similar gradual approaches.

Competing interests. The authors declare none.

# References

- <span id="page-15-1"></span>Cabeza, D., Hermenegildo, M., and Lipton, J. Hiord: A Type-Free Higher-Order Logic Programming Language with Predicate Abstraction. In ASIAN'04 2004, number 3321 in LNCS, pp. 93–108. Springer-Verlag.
- <span id="page-15-0"></span>Cardelli, L. Typeful programming. In Neuhold, E. J. and Paul, M., editors, Formal Description of Programming Concepts 1989, IFIP State-of-the-Art Reports. Springer.

- <span id="page-16-14"></span>Cousot, P. and Cousot, R. Abstract Interpretation: a Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. In Proc. of POPL'77 1977, pp. 238–252. ACM Press.
- <span id="page-16-16"></span>Debray, S., Lopez-Garcia, P., and Hermenegildo, M. Non-Failure Analysis for Logic Programs. In 1997 International Conference on Logic Programming 1997, pp. 48–62, Cambridge, MA. MIT Press, Cambridge, MA.
- <span id="page-16-10"></span>Hermenegildo, M., Bueno, F., Carro, M., Lopez-Garcia, P., Mera, E., Morales, J., and Puebla, G. 2012. An Overview of Ciao and its Design Philosophy. TPLP, 12, 1–2, 219–252.
- <span id="page-16-2"></span>Hermenegildo, M., Puebla, G., and Bueno, F. Using Global Analysis, Partial Specifications, and an Extensible Assertion Language for Program Validation and Debugging. In The Logic Programming Paradigm: a 25–Year Perspective 1999, pp. 161–192. Springer-Verlag.
- <span id="page-16-11"></span>Hermenegildo, M., Puebla, G., Bueno, F., and Garcia, P. L. 2005. Integrated Program Debugging, Verification, and Optimization Using Abstract Interpretation (and The Ciao System Preprocessor). Science of Computer Programming, 58, 1–2, 115–140.
- <span id="page-16-9"></span>Hill, P. and Lloyd, J. 1994. The Goedel Programming Language. MIT Press, Cambridge MA.
- <span id="page-16-0"></span>Körner, P., Leuschel, M., Barbosa, J., Santos-Costa, V., Dahl, V., Hermenegildo, M. V., Morales, J. F., Wielemaker, J., Diaz, D., Abreu, S., and Ciatto, G. 2022. Fifty Years of Prolog and Beyond. TPLP, 20th Anniversary Special Issue, 22, 6, 776–858.
- <span id="page-16-1"></span>Marlow, S., editor 2010. Haskell 2010 Language Report.
- <span id="page-16-7"></span>Miller, D. 1991. A logic programming language with λ-abstraction, function variables, and simple unification. Journal of Logic and Computation, 1(4), 497–536.
- <span id="page-16-15"></span>Muthukumar, K. and Hermenegildo, M. 1992. Compile-time Derivation of Variable Dependency Using Abstract Interpretation. Journal of Logic Programming, 13, 2/3, 315–347.
- <span id="page-16-12"></span>Puebla, G., Bueno, F., and Hermenegildo, M. An Assertion Language for Constraint Logic Programs. In Analysis and Visualization Tools for Constraint Programming 2000a, number 1870 in LNCS, pp. 23–61. Springer-Verlag.
- <span id="page-16-3"></span>Puebla, G., Bueno, F., and Hermenegildo, M. Combined Static and Dynamic Assertion-Based Debugging of Constraint Logic Programs. In Proc. of LOPSTR'99 2000b, LNCS 1817, pp. 273–292. Springer-Verlag.
- <span id="page-16-4"></span>Sanchez-Ordaz, M., Garcia-Contreras, I., Perez-Carrasco, V., Morales, J. F., Lopez-Garcia, P., and Hermenegildo, M. 2021. VeriFly: On-the-fly Assertion Checking via Incrementality. Theory and Practice of Logic Programming, 21, 6, 768–784.
- <span id="page-16-5"></span>Siek, J. G. and Taha, W. Gradual Typing for Functional Languages. In Scheme and Functional Programming Workshop 2006, pp. 81–92.
- <span id="page-16-8"></span>Somogyi, Z., Henderson, F., and Conway, T. 1996. The Execution Algorithm of Mercury: an Efficient Purely Declarative Logic Programming Language. Journal of Logic Programming, 29, 1–3, 17–64.
- <span id="page-16-6"></span>Stulova, N., Morales, J., and Hermenegildo, M. Assertion-based Debugging of Higher-Order (C)LP Programs. In PPDP'14 2014, pp. 225–235. ACM.
- <span id="page-16-13"></span>Stulova, N., Morales, J. F., and Hermenegildo, M. 2018. Some Trade-offs in Reducing the Overhead of Assertion Run-time Checks via Static Analysis. Science of Computer Programming, 155, 3–26.
- <span id="page-16-17"></span>Vaucheret, C. and Bueno, F. More Precise yet Efficient Type Inference for Logic Programs. In SAS'02 2002, number 2477 in LNCS, pp. 102–116. Springer.

### <span id="page-17-4"></span>Appendix A Proof of Theorem [4.1](#page-9-2)

<span id="page-17-0"></span>We start with some auxiliary lemmas.

Lemma A.1

Given two property formulas F<sup>1</sup> and F2, (F<sup>1</sup> ∧ F2) ♮ = F ♮ <sup>1</sup> ∩ F ♮ 2 . ✷

# Proof

We proceed by direct proof. Assume (F<sup>1</sup> ∧ F2) ♮ ̸= ∅, take any θ ∈ (F<sup>1</sup> ∧ F2) ♮ . By Definition [4.1,](#page-7-3) θ ⇒<sup>P</sup> (F<sup>1</sup> ∧ F2), and from Definition [2.1,](#page-3-2) θ ⇒<sup>P</sup> F<sup>1</sup> ∧ θ ⇒<sup>P</sup> F1. Hence, by Definition [4.1,](#page-7-3) θ ∈ F ♮ <sup>1</sup> ∧ θ ∈ F ♮ 2 , and from the properties of set intersection (∩), we conclude θ ∈ (F ♮ <sup>1</sup> ∩ F ♮ 2 ). Assume now (F<sup>1</sup> ∧ F2) ♮ = ∅, then ∀θ ∈ F ♮ 1 . θ /∈ F ♮ 2 ; hence F ♮ <sup>1</sup> ∩ F ♮ <sup>2</sup> = ∅. ✷

## Lemma A.2

Given the calls assertion condition calls(p(¯v),Pre) ∈ A, and the anonymous calls assertion condition calls(\_(¯v), ◦Pre) ∈ Π associated to Π.

<span id="page-17-2"></span>
$$
{}^{\circ}\!Pre^{\sharp+} \sqsubseteq Pre^{\sharp-} \Rightarrow p \text{ can be covered with } \Pi
$$

# Proof

The proof proceeds by assuming ◦Pre♯<sup>+</sup> ⊑ Pre♯<sup>−</sup> and showing ◦Pre♮ ⊆ Pre♮ .

$$
{}^{0}Pre^{\sharp+} \sqsubseteq Pre^{\sharp-}
$$
  
\n
$$
\Leftrightarrow \gamma({}^{0}Pre^{\sharp+}) \subseteq \gamma(Pre^{\sharp-})
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq \gamma({}^{0}Pre^{\sharp+}) \subseteq \gamma(Pre^{\sharp-}) \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow {}^{0}Pre^{\sharp} \subseteq Pre^{\sharp}
$$
  
\n
$$
\Leftrightarrow \Leftrightarrow \Leftrightarrow \Leftrightarrow \Leftrightarrow \Leftrightarrow \Leftrightarrow \Leftrightarrow \
$$

✷

We now proceed to the proof of Theorem [4.1.](#page-9-2)

# Theorem 4.1

Let p be a predicate, Π be a predicate property: p≺♯<sup>−</sup> Π ⇒ p≺Π, and p⊀♯<sup>+</sup> Π ⇒ p⊀Π. ✷

# Proof

Let P be a program, p be a predicate s.t. p ∈ P, and Π be a predicate property. We will prove each case separately.

• We proceed by contradiction. Assume that p abstractly conforms to Π:

<span id="page-17-1"></span>
$$
p \prec^{\sharp-} \Pi \tag{A.1}
$$

and that p does not conform to Π:

<span id="page-17-3"></span>
$$
p \nless \Pi \tag{A.2}
$$

First, by Equation [\(A.1\)](#page-17-1) and Lemma [A.2,](#page-17-2) we know that p can be covered with Π, hence

<span id="page-17-5"></span>
$$
{}^{\circ}\hspace{-1pt}Pre^{\natural} \subseteq Pre^{\natural} \tag{A.3}
$$

From Equation [\(A.2\)](#page-17-3) we know that there exists a query Q<sup>p</sup> = (p(¯v), θ0) to p s.t. Π is not redundant for p. Thus, by negating the redundance condition from Definition [4.5,](#page-7-5) we know that: ∃D′ ∈ derivsA′ (P, Qp). D′ [−1] = ⟨G′ | θ | {ℓ ′}⟩, and ∃D ∈ derivsA(P, Qp). U(D) = U(D′ ), s.t. D[−1] ❀<sup>∗</sup> <sup>A</sup> ⟨G | θ | ∅⟩ through any derivation that reduces only check literals; where A′ is defined as in Definition [4.6.](#page-8-4) We also know that both derivsA′ (P, Qp) and derivsA(P, Qp) share the same initial state S = ⟨p(¯v)| θ<sup>0</sup> | ∅⟩ given that they are deriving the same query Q<sup>p</sup> to p. We now consider two cases: the error comes from a calls or success assertion condition in A′ .

Calls: The label ℓ ′ identifies a calls assertion condition C ′ in A′—of the form calls(p(¯v),Pre ∧ ◦Pre) (from the definition of A′ )—which fails to be checked for θ; and the calls assertion condition C in A—of the form calls(p(¯v),Pre)—is checked for θ. On the one hand:

C ′ fails to be checked for θ

| ◦Pre<br>⇔<br>θ<br≯⇒P<br>Pre<br>∧    | HSemantics with assertionsI |
|--------------------------------------|-----------------------------|
| ◦Pre)<br>♮<br>⇔<br>θ /∈<br>(Pre<br>∧ | HDef.<br>4.1I               |
| Pre♮ ∩<br>◦Pre♮<br>⇔<br>θ /∈         | HLem.<br>A.1I               |
| ◦Pre♮<br>⇔<br>θ /∈                   | HEq. (A.3)I                 |
|                                      |                             |

On the other hand:

C is checked for θ

$$
\Leftrightarrow \theta \Rightarrow_P Pre
$$
   
 
$$
\Leftrightarrow \theta \in Pre^{\natural}
$$
   
 
$$
\Leftrightarrow \theta \in Pre^{\natural}
$$
   
 (Definition 1)

Since p ≺♯<sup>−</sup> Π (by Equation [\(A.1\)](#page-17-1)), we know from Definition [4.7](#page-8-3) that:

$$
Pre^{\sharp +} \sqsubseteq {}^{\circ}Pre^{\sharp -}
$$
  
\n
$$
\Leftrightarrow \gamma(Pre^{\sharp +}) \subseteq \gamma({}^{\circ}Pre^{\sharp -})
$$
  
\n
$$
\Leftrightarrow Pre^{\sharp} \subseteq \gamma(Pre^{\sharp +}) \subseteq \gamma({}^{\circ}Pre^{\sharp -}) \subseteq {}^{\circ}Pre^{\sharp}
$$
  
\n(1) 
$$
[Defs. 4.2 \text{ and } 4.3]
$$

Since θ ∈ Pre♮ and ⊆ is a partial order, it implies that θ ∈ ◦Pre♮ , contradicting θ /∈ ◦Pre♮ . E

Success: The label ℓ ′ identifies a success assertion condition C ′ in A′—of the form success(p(¯v), ◦Pre, ◦Post)—which fails to be checked for θ; and all success assertion conditions C<sup>i</sup> in A—of the form success(p(¯v),Pre<sup>i</sup> ,Post <sup>i</sup>) with i ∈ 1..n—is checked for θ. On the one hand:

C ′ fails to be checked for θ

$$
\Leftrightarrow (\theta_0 \Rightarrow_P {}^oPre) \land (\theta \npreceq_P {}^oPost)
$$
 (Semantics with assertions)  
\n
$$
\Leftrightarrow (\theta_0 \in {}^oPre^{\natural}) \land (\theta \notin {}^oPost^{\natural})
$$
 (Def. 4.1)

Since p ≺<sup>♯</sup><sup>−</sup> Π (by Equation [\(A.1\)](#page-17-1)), we know from Definition [4.8](#page-8-2) that there exists a proper subset of success assertion conditions S ⊂ A s.t.:

<span id="page-18-0"></span>
$$
(Pre_{\sqcup}^{\sharp -} = \sqcup \{ Pre^{\sharp -} \mid \text{success}(p(\bar{v}), Pre, \_) \in S \}) \sqsupseteq {}^{o}Pre^{\sharp +}
$$
 (A.4)

and

<span id="page-18-1"></span>
$$
(Post_{\sqcup}^{\sharp+} = \sqcup \{Post^{\sharp+} \mid \text{success}(p(\bar{v}), \_, Post) \in S\}) \sqsubseteq {}^{\circ}Post^{\sharp-} \tag{A.5}
$$

From Equations [\(A.4\)](#page-18-0) and [\(A.5\)](#page-18-1) and Definitions [4.2](#page-7-2) and [4.3,](#page-7-4) we obtain the following relations:

<span id="page-19-0"></span>
$$
\bigcup \{Pre^{\natural} \mid \text{success}(p(\bar{v}), Pre, \_) \in S \} \supseteq \gamma(Pre_{\sqcup}^{\sharp -}) \supseteq \gamma(^{\circ}Pre^{\sharp +}) \supseteq {}^{\circ}Pre^{\natural} \tag{A.6}
$$

and

<span id="page-19-1"></span>
$$
\bigcup \{Post^{\natural} \mid \text{success}(p(\bar{v}), \_, Post) \in S \} \subseteq \gamma(Post_{\sqcup}^{\sharp+}) \subseteq \gamma(^{\circ}Post^{\sharp-}) \subseteq {}^{\circ}Post^{\natural} \quad (A.7)
$$
  
Finally, since  $\theta_0 \in {}^{\circ}Pre^{\natural}$ :

$$
\theta_0 \in {}^{\circ}\!Pre^{\natural}
$$
\n
$$
\Leftrightarrow \theta_0 \in \cup \{Pre^{\natural} \mid \text{success}(p(\bar{v}), Pre, \_) \in S\}
$$
\n
$$
\Leftrightarrow \exists (C = \text{success}(p(\bar{v}), Pre, Post)) \in S. \ \theta_0 \in Pre^{\natural}
$$
\n
$$
\Leftrightarrow \theta \Rightarrow_{P} Post
$$
\n
$$
\Leftrightarrow \theta \in Post^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in V_{\text{est}}^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in V_{\text{est}}^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in V_{\text{est}}^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in \forall \text{est } \text{success}(p(\bar{v}), \_, Post) \in S\}
$$
\n
$$
\Leftrightarrow \theta \in {}^{\circ}\!Post^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in {}^{\circ}\!Post^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in {}^{\circ}\!Cost^{\natural}
$$
\n
$$
\Leftrightarrow \theta \in \{1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
$$

which leads to a contradiction with our initial hypothesis θ /∈ ◦Post ♮ . E

• We proceed by direct proof. Since p does not abstractly conform to Π:

$$
p \not\prec^{\sharp+} \Pi \tag{A.8}
$$

we consider two cases: p does not abstractly conform to Π's anonymous calls assertion condition, or to some anonymous success assertion condition of Π.

Calls: Let ( ◦C = calls(\_(¯v), ◦Pre)) ∈ Π, we know that p ⊀♯<sup>+</sup> ◦C, then:

$$
p \nless\n\begin{aligned}\n &\mathbb{P} \nless\n\end{aligned}\n\begin{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\begin{aligned}\n &\mathbb{P} \n\end{aligned}\n &\math
$$

Success: Let ( ◦C = success(\_(¯v), ◦Pre, ◦Post)) ∈ Π, since p ⊀♯<sup>+</sup> ◦C, we know that there exists a success assertion condition (C = success(p(¯v),Pre,Post)) ∈ A s.t. the following hold:

<span id="page-19-4"></span><span id="page-19-3"></span><span id="page-19-2"></span>
$$
Pre^{\sharp+} \sqsubseteq \,^\circ Pre^{\sharp-} \tag{A.9}
$$

$$
Post^{\sharp +} \sqcap \, ^{\circ}Post^{\sharp +} = \bot \tag{A.10}
$$

$$
\exists \theta_0 \in \text{Pre}^{\natural}. S_{\mathcal{A}}(p(\bar{v}), \theta_0, P, \gamma(\mathcal{Q}_p^{\sharp})) \neq \varnothing \tag{A.11}
$$

where γ(Q<sup>♯</sup> p ) is a superset of the set of valid queries to p described by p's calls assertion condition in A. First, by Definitions [4.2](#page-7-2) and [4.3,](#page-7-4) from Equation [\(A.9\)](#page-19-2)

and Equation [\(A.10\)](#page-19-3) we obtain:

<span id="page-20-1"></span><span id="page-20-0"></span>
$$
Pre^{\natural} \subseteq \,^{\circ}Pre^{\natural} \tag{A.12}
$$

$$
Post^{\natural} \cap {}^{\circ}Post^{\natural} = \varnothing \tag{A.13}
$$

Next, from Equation [\(A.11\)](#page-19-4) and Equation [\(A.12\)](#page-20-0), it follows that θ<sup>0</sup> ∈ Pre♮ and θ<sup>0</sup> ∈ ◦Pre♮ . Also, from Equation [\(A.11\)](#page-19-4) and the definition of the success context, we know that

$$
\theta \in \mathcal{S}_{\mathcal{A}}(p(\bar{v}), \theta_0, P, \gamma(\mathcal{Q}_p^{\sharp}))
$$

hence θ ∈ Post ♮ . However, by Equation [\(A.13\)](#page-20-1) we know that θ /∈ ◦Post ♮ . By Definition [4.1,](#page-7-3) this means that, on the one hand:

<span id="page-20-2"></span>
$$
\theta_0 \Rightarrow_P \text{Pre } \land \theta \Rightarrow_P \text{Post} \tag{A.14}
$$

And in the other hand:

<span id="page-20-3"></span>
$$
\theta_0 \Rightarrow_P {}^{\circ}\!Pre \wedge \theta \not\Rightarrow_P {}^{\circ}\!Post \tag{A.15}
$$

The above conditions Equation [\(A.14\)](#page-20-2) and Equation [\(A.15\)](#page-20-3), together with the definition of the operational semantics with assertions, implies that there exists a query Q<sup>p</sup> = (p(¯v), θ0) to p s.t. Π is not redundant for p. And, by the definition of non conformance (Definition [4.6\)](#page-8-4), this implies that p does not conform to Π. ✷