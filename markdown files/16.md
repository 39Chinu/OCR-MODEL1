# CASCADE: LLM-powered JavaScript Deobfuscator at Google

Shan Jiang\* *The University of Texas at Austin* shanjiang@utexas.edu

Pranoy Kovuri\* *Google Inc* kovuripranoy@gmail.com

David Tao *Google Inc* dtao@google.com

Zhixun Tan *Google Inc* tzx@google.com

*Abstract*—Software obfuscation, particularly prevalent in JavaScript, hinders code comprehension and analysis, posing significant challenges to software testing, static analysis, and malware detection. This paper introduces CASCADE, a novel hybrid approach that integrates the advanced coding capabilities of Gemini with the deterministic transformation capabilities of a compiler Intermediate Representation (IR), specifically JavaScript IR (JSIR). By employing Gemini to identify critical prelude functions—the foundational components underlying the most prevalent obfuscation techniques—and leveraging JSIR for subsequent code transformations, CASCADE effectively recovers semantic elements like original strings and API names, and reveals original program behaviors. This method overcomes limitations of existing static and dynamic deobfuscation techniques, eliminating hundreds to thousands of hard-coded rules while achieving reliability and flexibility. CASCADE is already deployed in Google's production environment, demonstrating substantial improvements in JavaScript deobfuscation efficiency and reducing reverse engineering efforts.

*Index Terms*—artificial intelligence, language models, compilers, security.

## I. INTRODUCTION

JavaScript is the dominant programming language for web development, powering client-side interactions across billions of web pages, mobile applications, and browser extensions. However, its widespread adoption has led to increased use of code obfuscation techniques that deliberately transform readable code into complex, difficult-to-understand variants. This poses significant challenges to software testing, complicates analysis, and hinders malware detection. Deobfuscation, which transforms the code to restore readability and reveal the original intention while maintaining code semantic equivalence, is inherently difficult. It requires robust handling of various complex obfuscation techniques—such as dynamic code generation (e.g., using the eval function to execute code from strings), control flow flattening, and string encoding. Deobfuscation involves not only syntactic simplification but also deeper semantic restructuring to reverse transformations like identifier mangling, opaque predicate removal, and constant unfolding. Aggressive code transformations might significantly enhance readability but inadvertently compromise semantic equivalence; conservative approaches may produce code that, while correct, remains largely inscrutable.

Based on empirical experience, Obfuscator.IO [1] is the most widely used JavaScript obfuscator by malware developers. Its level of obscurity, as demonstrated in a concrete example shown in Fig 1, significantly impedes malware detection workflows. Amongst its various obfuscation techniques, the obfuscation of strings and API names (method and property names) creates the greatest barriers to code analysis. Recovering original string literals and API names would markedly reduce the manual effort required in Google's malware detection processes. Since Obfuscator.IO performs API obfuscation by transforming direct API calls (e.g., chrome.cookies) as stringindexed lookups (chrome["cookies"]) before obfuscating the string literal ("cookies"), solving string obfuscation inherently resolves the API obfuscation. Consequently, we target Obfuscator.IO's string obfuscation in this paper.

To address string obfuscation of Obfuscator.IO, we propose CASCADE (Combined Analysis of Scripts with a Context-Aware Deobfuscation Engine), a hybrid JavaScript deobfuscator that combines large language models (LLMs) and a compiler intermediate representation (IR). First, it uses Gemini [2] to detect and extract key code patterns, termed *prelude functions*, generated by Obfuscator.IO for manipulating obfuscated strings. Then, it runs a customized constant propagation and inline pass built on JSIR [3], a next-generation compiler framework, and treats prelude functions as pure (i.e. idempotent and side-effect-free) functions and dynamically execute them in a sandboxed JavaScript environment. The use of LLMs for code pattern detection eliminates reliance on manually engineered heuristics; the compiler IR provides a robust structure for applying code transformations, ensuring functional integrity through semantics-preserving operations while systematically improving code readability.

Recent work confirms that LLMs possess strong code understanding skills [4]–[6], making them promising tools for identifying code patterns. LLMs also align user prompts with their learned internal representations [7] and show emergent competence on tasks not seen during training [8]. Together, these properties position LLMs to automatically pinpoint prelude functions in long, obfuscated codebases. However, LLMs still falter on tasks that demand exact logical or mathematical reasoning [9], [10] limiting their effectiveness in fully correct end-to-end deobfuscation. Even small arithmetic mistakes—e.g., flipping an if condition from true to false—can radically change program behavior. Evaluating pure

<sup>\*</sup>Work done when working at Google

```
function hi () {
  console . log ('Hello World !') ;
}
hi () ;
```

```
function _0x432d () {
   var _0x1398fd = [
        '754705 BaCmnb ', '710 BeTfxi ', '6078 JFPbmg ', '391457 WTcWXy ', '6916 iSWoZO ',
        '1533357 iISYWF ', '2400 oHfZQf ', '24 eeZIfI ', 'log ', '149 YcoFBV ',
        '1367628 nfkDqA ', '1243948 epsCBk ', 'Hello \ x20World !'
   ];
   _0x432d = function () {
        return _0x1398fd ;
   };
   return _0x432d () ;
}
( function ( _0x38057e , _0xee6281 ) {
   var _0x18e9b0 = _0x4c0c ;
   var _0x1ab84e = _0x38057e () ;
   while (!![]) {
        try {
             var _0xc7d52d = parseInt ( _0x18e9b0 (0 x1b7 ) ) / 0 x1 * ( - parseInt ( _0x18e9b0 (0 x1bf ) ) / 0 x2 ) + - parseInt ( _0x18e9b0 (0
     x1b8 ) ) / 0 x3 + - parseInt ( _0x18e9b0 (0 x1b9 ) ) / 0 x4 + - parseInt ( _0x18e9b0 (0 x1c1 ) ) / 0 x5 * ( parseInt ( _0x18e9b0 (0 x1bd ) ) / 0
     x6 ) + parseInt ( _0x18e9b0 (0 x1bb ) ) / 0 x7 * ( - parseInt ( _0x18e9b0 (0 x1b5 ) ) / 0 x8 ) + - parseInt ( _0x18e9b0 (0 x1c0 ) ) / 0 x9 + -
     parseInt ( _0x18e9b0 (0 x1bc ) ) / 0 xa * ( - parseInt ( _0x18e9b0 (0 x1be ) ) / 0 xb ) ;
             if ( _0xc7d52d === _0xee6281 ) {
                 break ;
             } else {
                 _0x1ab84e ['push ']( _0x1ab84e ['shift ']() ) ;
             }
        } catch ( _0x5a174b ) {
             _0x1ab84e ['push ']( _0x1ab84e ['shift ']() ) ;
        }
   }
}( _0x432d , 0 x40942 ) ) ;
function _0x4c0c ( _0x32b956 , _0x514a26 ) {
   var _0x432d26 = _0x432d () ;
   _0x4c0c = function ( _0x4c0c62 , _0x284b04 ) {
        _0x4c0c62 = _0x4c0c62 - 0 x1b5 ;
        var _0x85349e = _0x432d26 [ _0x4c0c62 ];
        return _0x85349e ;
   };
   return _0x4c0c ( _0x32b956 , _0x514a26 ) ;
}
function hi () {
   var _0x964834 = _0x4c0c ;
   console [ _0x964834 (0 x1b6 ) ]( _0x964834 (0 x1ba ) ) ;
}
hi () ;
```

Fig. 1. Hello World obfuscated by Obfuscator.IO with the default (the lowest level) configuration

LLM deobfuscation is also difficult because proving functional equivalence between the obfuscated and recovered programs is non-trivial. The hybrid approach of CASCADE leverages the best of both worlds: Gemini detects prelude functions with a 99.56% average success rate on a synthetic dataset of 12K obfuscated files; the deterministic transformations of JSIR then restores 945 string literals per sample in an average of two seconds, demonstrating practical throughput.

This paper offers three primary contributions:

- Novelty CASCADE is the first framework to pair an LLM with compiler-level IR transformations, merging probabilistic code understanding with deterministic rewrites for robust deobfuscation of JavaScript code.
- Industrial deployment CASCADE eliminates the need for hundreds to thousands of hard-coded pattern-matching rules, and is deployed in production at Google.
- Scalability We open-source our prompt templates and the full JSIR infrastructure to facilitate community

adoption and reproducibility. The repository is publicly available at https://github.com/google/jsir.

# II. BACKGROUND AND RELATED WORK

# *A. Software Obfuscation.*

Software obfuscation deliberately transforms code to hinder readability, analysis, and reverse engineering. Common obfuscation techniques include restructuring code, replacing descriptive variable names with unintuitive identifiers, injecting redundant or misleading instructions, manipulating control flow, and encrypting literals such as strings or configuration data [11], [12]. Although obfuscation can legitimately safeguard proprietary algorithms and sensitive resources (e.g., IP addresses) [13], [14], it is also exploited by attackers to mask malicious logic—especially in web and mobile scripts [15]– [17].

Obfuscated code severely diminishes the effectiveness of analysis tools, creating a major obstacle for software testing and static analysis methods [18]–[20]. Moreover, obfuscation hampers malware detection by concealing malicious behavior from static analyzers, security filters, machine-learning detectors, and manual reviewers [21]–[23]. JavaScript, the dominant client-side language, is particularly vulnerable because its source code is delivered directly to the browser [24], [25], making it an attractive target for both defensive and malicious obfuscation.

## *B. JavaScript Deobfuscation*

The prevalence of malicious JavaScript code underscores an urgent need for effective deobfuscation techniques [26], [27]. JavaScript deobfuscators aim to restore code readability for analysis while preserving semantic correctness. Various deobfuscation approaches have been explored in recent years.

Machine learning-based approaches, exemplified by DE-GUARD [28] for ProGuard-obfuscated Android code, have demonstrated promising results. However, the inherent stochasticity of current ML models prevents them from guaranteeing semantic equivalence between original and deobfuscated code.

Dynamic analysis can enhance code readability to facilitate manual inspection of obfuscated scripts [29]. Lu et al. [30] proposed a dynamic analysis technique incorporating program slicing. However, dynamic methods generally impose specific runtime environment requirements, incur substantial performance overhead, and raise security concerns.

Static analysis presents an alternative approach. JSDES [31] introduced function-centric deobfuscation but struggles with obfuscations implemented purely through basic operations. This limitation renders it less effective against Obfuscator.IO, which commonly interleaves such operations with complex function calls. Many static techniques operate at the AST level [32]–[35]. TransAST [36] uses static analysis and machine translation to deobfuscate JavaScript but faces difficulties with obfuscation techniques that are dynamically generated or manifested at runtime.

Pattern-matching approaches, such as Safe-Deobs [29], rely on predefined patterns derived from real-world malware. Webcrack [35] is a rule-based JavaScript deobfuscator that transforms code at the AST level. Webcrack relies on hardcoded AST rules, so even slight modifications (e.g., changing while (!![]) to while (!false)) can prevent successful deobfuscation. AST-based methods are limited when encountering heavily obfuscated code or novel obfuscation patterns not included in their predefined rule sets. The key limitation of AST-based tools is their lack of semantic understanding capabilities compared to compiler-based methods. These tools are prone to altering code behavior or introducing errors during the deobfuscation process.

## *C. LLM for SE.*

Large Language Models (LLMs) have recently demonstrated strong capabilities in diverse code-related tasks, including program synthesis, code refactoring, and automated test generation [4], [7], [37]. Trained on extensive corpora of code and textual data, these models develop an implicit understanding of programming language syntax, semantics, and code structures [38], [39]. Consequently, LLMs exhibit notable capabilities in tasks requiring both natural language comprehension and code manipulation [7]. While models such as StarCoder [40] and Gemini demonstrate proficiency in code generation, they remain susceptible to hallucination, wherein they generate plausible but incorrect or nonsensical outputs [41]. Moreover, LLMs exhibit limitations in tasks demanding precise logical and mathematical reasoning [9], [10]. This constrains their efficacy in achieving correct end-to-end deobfuscation, where precise computation is crucial, as even minor inaccuracies can drastically alter program behavior. To address these non-deterministic limitations, hybrid approaches integrating LLMs with Abstract Syntax Trees (ASTs) or Intermediate Representations (IRs) have demonstrated promise in various software engineering applications [42].

## III. STRING OBFUSCATION AND CASCADE APPROACH

![](_page_2_Figure_11.jpeg)

Fig. 2. CASCADE Deobfuscator

Obfuscator.IO represents a widely adopted obfuscation tool among malicious actors [43]. The tool employs a multi-stage obfuscation pipeline incorporating string obfuscation, control flow flattening, and complex arithmetic operations, etc.. String obfuscation emerges as the most critical technique for two key reasons: (1) recovering string literals and API names yields the greatest readability improvements, and (2) string obfuscation occurs as the final pipeline stage, layering atop other obfuscation methods and establishing string deobfuscation as a prerequisite for subsequent analysis. Consequently, CAS-CADE prioritizes string deobfuscation when processing Obfuscator.IO-generated code.

The Obfuscator.IO tool implements string obfuscation through two code transformations. First, it creates a string fetching function that retrieves and optionally decodes elements from a global string table. Second, it replaces each original string literal with a complex string recovery expression that calls the fetching function through multiple abstraction layers including wrapper functions, object property lookups, variable aliases, and arithmetic operations.

Figure 3 is a simplified version of Figure 1, and illustrates string obfuscation in Obfuscator.IO. In this example, the strings "log" and "Hello World!" are replaced by calls to a getString() function, which retrieves the corresponding entries from a global string array using offset indices.

```
function hi () {
  console . log ('Hello World !') ;
}
hi () ;
```

```
var globalStringTable = [
  ... , /* index : 8*/ 'log ',
  ... , /* index : 12 */ 'Hello World !'
];
function getStringArray () {
  return globalStringTable ;
}
function getString ( index ) {
  return getStringArray () [ index - 437];
}
( function () {
  var stringArray = getStringArray () ;
  while ( true ) {
    if ( conditionOnPermutationOf ( stringArray ) ) {
       stringArray . push ( stringArray . shift () ) ;
    }
  }
}) () ;
function hi () {
  console [ getString (438) ]( getString (442) ) ;
}
hi () ;
```

Fig. 3. Simplified Illustration of String Obfuscation

The global string table undergoes rotation an unknown number of times, which makes getStringArray()—and by extension, getString()—seem non-idempotent with side effects, despite their truly idempotent and side-effect-free nature. As a result, these functions bypass compiler optimizations such as constant propagation and inlining.

However, the definition and initialization of the global string table, along with the string fetching function—which we term prelude functions—are generated from templates and are highly recognizable. By detecting these code segments, treating getString() as an idempotent and side-effect-free builtin function, and dynamically executing it upon invocation, we can enhance constant propagation and inlining, thereby successfully evaluating the string recovery expressions.

To achieve this, the CASCADE deobfuscator employs a hybrid approach that integrates static analysis, dynamic execution, and AI:

- (1) We identify prelude functions by prompting Gemini, which leverages its high-level code understanding and structured output capabilities.
- (2) We dynamically execute these detected prelude functions in a sandboxed JavaScript environment to obtain accurate results from string fetching function calls.
- (3) We apply constant propagation and inlining via JSIR—a JavaScript intermediate representation built on MLIR [44]—to evaluate arithmetic expressions and resolve indirections.

This hybrid approach has the following key benefits:

(1) Hybrid dynamic execution: CASCADE overcomes the conservatism of pure static analysis, which often fails against complex obfuscations to maintain soundness. By dynamically executing code snippets that appear nonidempotent but are actually idempotent, CASCADE evaluates more expressions and recovers obfuscated strings effectively.

- (2) AI-driven maintainability: CASCADE eliminates the need for hundreds to thousands of lines of brittle, unreadable manual rules in prelude function detection by leveraging state-of-the-art Gemini, achieving accuracy of 99.56%. Such manual rules are easy to break with minor code changes (e.g. change true to !false, or make an alias to a variable), as shown in Figure 4. In comparison, Gemini is resilient against minor changes in code format and syntax, which evades traditional detection based on AST or regex rules.
- (3) Advanced static analysis via JSIR: CASCADE conducts comprehensive code analyses and transformations using the robust JSIR infrastructure, a novel high-level JavaScript intermediate representation (IR). Although ASTs preserve high fidelity to source code syntax and suit source-to-source transformations [45], [46], IRs facilitate more sophisticated semantic-level analyses and transformations [47], [48]. JSIR uniquely encodes all AST syntactical information while supporting dataflow analysis.
- (4) Responsible use of AI: CASCADE deliberately refrains from using LLMs to directly generate deobfuscated code, eliminating a wide range of potential hallucination errors. Its hybrid design improves explanability, observability, and evaluability, ensuring practical use in production environments.

## IV. DETECTING PRELUDE FUNCTIONS

Prelude functions, generated from templates, are easily recognizable to reverse engineers despite obfuscation efforts. However, manual detection becomes prohibitively timeconsuming when applied to lengthy obfuscated codebases. Rule-based approaches using AST patterns [35] or regular expressions [1] prove equally problematic—they require extensive manual crafting, demand ongoing maintenance, and exhibit brittleness when confronted with minor code variations.

Recent advances in LLM code comprehension capabilities, exemplified by models such as Gemini, motivated our investigation into LLM-based prelude detection. The remainder of this section is organized as follows: Section IV-A presents a comprehensive analysis of prelude function characteristics, Section IV-B details our prompting methodologies, and Section IV-C outlines optimization strategies for cost reduction and error mitigation.

## *A. Prelude functions*

Obfuscator.IO implements string obfuscation through three prelude functions:

(1) A string array function that defines a global string table as an array.

| function _0x4d08 () {<br>var _0x235313 = [  ];<br>_0x4d08 = function () {<br>return _0x235313 ;<br>};<br>return _0x4d08 () ;<br>} | function _0x4d08 () {<br>var _0x235313 = [  ];<br>var _alias = _0x235313 ; // Add an alias<br>_0x4d08 = function () {<br>return _alias ;<br>};<br>return _0x4d08 () ;<br>} |  |  |  |  |
|-----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|--|--|--|
| while ( true ) {  }                                                                                                               | while (! false ) {  } // true = > ! false                                                                                                                                  |  |  |  |  |
| while (!![]) {  }                                                                                                                 | while (!! true ) {  } // !![] = > !! true                                                                                                                                  |  |  |  |  |
| while ( true ) {  }                                                                                                               | for (; ! false ; ) {  } // Another infinite loop                                                                                                                           |  |  |  |  |

Fig. 4. Slight changes cause rule-based pattern match to fail, left means Webcrack deobfuscation is correct, right means Webcrack cannot deobfuscate

- (2) A string fetching function that retrieves elements from the array using shifted indices.
- (3) A string array rotate function implemented as an IIFE (immediately invoked function expression) that rotates the global string table until a complex arithmetic expression evaluates to a target value.

The following examples illustrate these prelude functions using simplified names for clarity. In practice, Obfuscator.IO generates incomprehensible function names such as 0x746cd9.

String Array Function: Figure 6 demonstrates the getStringArray() function, which returns a reference to a global string table containing both original string literals and those generated during obfuscation. This function employs a self-redefining pattern: upon first invocation, it redefines itself to return a reference to the string array created during that initial call. JavaScript closure mechanisms ensure that getStringArray() consistently returns the same array object in subsequent invocations.

String Fetching Function: Figure 7 demonstrates the getString() function, which retrieves a single element from the global string table using an index-based lookup with a fixed offset. Like getStringArray(), the getString() function employs self-modification during its initial execution, rendering it non-idempotent. This behavior likely serves as an anti-analysis technique designed to prevent compiler optimization through inlining. Figure 3 illustrates the default obfuscation level implementation. At elevated obfuscation levels, the global string table contains encoded strings, and getString() runs custom decoding algorithms (such as Base64 or RC4 decryption), significantly increasing the function's complexity and length.

String Array Rotate Function: Figure 8 demonstrates an IIFE that systematically rotates the global string table until a specific mathematical expression evaluates to a target value. The expression applies parseInt() to selected table strings and performs arithmetic operations, making the evaluation dependent on the table's current permutation order. Achieving the correct permutation is essential for getString() to successfully retrieve the intended string value.

# *B. Prompt Design*

We iterated over different LLM prompt designs to detect Obfuscator.IO prelude functions. Figure 5 presents our current prompt template. We adopt a few-shot learning paradigm by incorporating descriptions and examples of the code patterns we seek to detect, as well as a concrete end-to-end example. In particular:

- (1) We separate obfuscated code by top-level statements, enclosed by HTML-style comment tags (e.g., // <0> and // </0>) of IDs. This allows us to instruct the LLM to respond in the form of statement IDs, restricting the output space, minimizing the output size, and making it easy to consume the output for downstream deobfuscation steps.
- (2) We instruct the LLM to respond in a JSON format, mapping each template type to its corresponding statement ID. This structured output simplifies downstream automatic processing.
- (3) For each target pattern, we provide a natural language description, the template source code, and several concrete examples. Since Obfuscator.IO prelude functions have a limited number of variations, a few examples are sufficient to cover all preset configurations (default, low, medium, high), as demonstrated by evaluation results in section VI-B.

This description and example-oriented prompt effectively conveys the classification criteria and desired output structure of LLM without explicit rule definition. It eliminates the need for hundreds to thousands of lines of manual rules in AST patterns [35] or regex [1], while being resilient against minor formatting or structural changes, making it more maintainable and reliable.

Our prompt design exemplifies how structured instruction engineering, combined with few-shot learning, can effectively enable modern language models to undertake sophisticated code analysis tasks, presenting substantial potential benefits for automated security analysis and research.

# *C. Practical Engineering Optimization*

For production deployment, we implement two engineering optimizations to minimize LLM query costs and detection errors.

Pre-LLM filtering: We deploy a proprietary YARA [49] rule to identify Obfuscator.IO-obfuscated JavaScript before querying Gemini. This pre-filtering eliminates the majority

```
Obfuscator . io is a well - known JavaScript obfuscator .
To obfuscate strings , it usually inserts 3 templates : StringArrayTemplate , StringArrayRotateFunctionTemplate and
StringArrayCallsWrapperTemplate .
## StringArrayTemplate
StringArrayTemplate defines a string array that includes string literals from the original unobfuscated code .
It 's generated using this template :
```js
{{ string_array_template }}
```
An example looks like this :
```js
{{ string_array_template_example }}
```
## StringArrayCallsWrapperTemplate
StringArrayCallsWrapperTemplate fetches a string from the string array given a shifted index .
Depending on the obfuscation config , StringArrayCallsWrapperTemplate may also perform custom decoding such as base64 or
     rc4 .
It 's generated using this template :
```js
{{ string_array_calls_wrapper_template }}
```
### StringArrayCallsWrapperTemplate example 1:
```js
{{ string_array_calls_wrapper_template_example_1 }}
```
### StringArrayCallsWrapperTemplate example 2:
...
### StringArrayCallsWrapperTemplate example 3:
...
## StringArrayRotateFunctionTemplate
StringArrayRotateFunctionTemplate is a piece of code that rotates the string array defined in StringArrayTemplate .
It 's generated using this template :
```js
{{ string_array_rotate_function_template }}
```
An example looks like this :
```js
{{ string_array_rotate_function_template_example_1 }}
```
Another example looks like this :
```js
{{ string_array_rotate_function_template_example_2 }}
```
Now , as an obfuscator . io expert , your job is to detect these templates from a piece of obfuscated code .
In particular , the code is split into N parts , using html tags in comments with an ID .
Please return a JSON map from template name to a list of parts belonging to that template .
Here is an example . If the input is this :
< example_java_script >
// <0 >
var _0x42f9c1 = _0x1e0f ;
// < /0 >
// <1 >
String Array Rotate Function ...
// < /1 >
// <2 >
console [ _0x42f9c1 (337) ](' Hello , world !') ;
// < /2 >
// <3 >
String Fetching Function ...
// < /3 >
// <4 >
String Array Function ...
// < /4 >
</ example_java_script >
Output :
{
  'StringArrayTemplate ': 4 ,
  ' StringArrayRotateFunctionTemplate ': 1 ,
    StringArrayCallsWrapperTemplate ': 3
}
Now please investigate the following code and return the output JSON .
< investigation_java_script >
{{ annotated_example }}
</ investigation_java_script >
** Remember :**
* The values for StringArrayTemplate , StringArrayRotateFunctionTemplate , and StringArrayCallsWrapperTemplate can never be
      equal because of the nature of obfuscation .
* Only output the json , do not output any explanation
Output :
```

```
function getStringArray () {
  var stringArray = [
       'info ', 'ewLHr ', 'prototype ', ... ,
       'ctor (\ x22retu ', 'Hello \ x20Worl ',
       'tZhir ', '__proto__ ', 'table '
  ];
  getStringArray = function () {
    return stringArray ;
  };
  return getStringArray () ;
}
```

Fig. 6. String Array Function (Variable Renamed For Readability)

```
function getString ( index , ignored ) {
  var stringArray = getStringArray () ;
  return getString = function ( index , ignored ) {
    index = index -
              ( -0 x3 *0 x23b + 0 x1b3 + -0 x1 * -0 x676 ) ;
    var result = stringArray [ index ];
    return result ;
  } , getString ( index , ignored ) ;
}
```

Fig. 7. String Fetching Function (Variable Renamed For Readability)

of the millions of JavaScript samples processed daily, significantly reducing query costs.

Post-LLM validation: We set up a mechanism to validate Gemini's result. As shown in Figure 6, the three prelude functions have a fixed dependency relationship, and do not depend on other parts of the obfuscated code. We require that the LLM detected prelude conforms to this dependency relationship, and if the verification fails, we ignore the LLM detection result.

## V. JSIR TRANSFORMATION

This section describes how we transform code and recover obfuscated strings based on the prelude detection result, through a combination of static analysis and dynamic execution using JSIR.

```
( function ( getStringArray , target ) {
  var stringArray = getStringArray () ;
  function getStringWrapper1 (a , b , c , d ) {
    return getString ( d - 0 x1e2 , a ) ;
  }
  ...
  while (!![]) {
    try {
       var value = parseInt ( getStringWrapper2 ( -0 xbc , -0 xa4 ,
     -0 xc9 , -0 xab ) ) / ( -0 x22da + -0 x3e * -0 x4d +0 x1035 ) + -
     parseInt ( getStringWrapper1 (0 x38b , 0 x38a , 0 x357 , 0 x376 ) )
      ...
       if ( value === target )
         break ;
       else
         stringArray ['push ']( stringArray ['shift ']() ) ;
    } catch ( _0x5c80ce ) {
       stringArray ['push ']( stringArray ['shift ']() ) ;
    }
  }
}( getStringArray , 0 x7 * -0 x11ff9 + -0 x166d *0 xc7 + 0 x237a14 ) ) ;
```

![](_page_6_Figure_9.jpeg)

![](_page_6_Figure_10.jpeg)

Fig. 9. Dependency graph of prelude functions

We run an intra-procedural constant propagation pass augmented with (1) dynamic execution of the string fetching function, and (2) inlining of indirections introduced by Obfuscator.IO, including variable aliases, wrapper functions, and object wrappers. Table I illustrates the result of running the pass, assuming that dynamically executing getString(438) yields the string "Hello World!".

TABLE I ILLUSTRATION OF JSIR TRANSFORMATION

| Before                                   | After                       |
|------------------------------------------|-----------------------------|
| var x = getString (438) ;                | var x = " Hello World !";   |
| // Variable alias                        | // Variable alias           |
| var x = getString ;                      | var x = getString ;         |
|                                          |                             |
| var y = x (438) ;                        | var y = " Hello World !";   |
| // Wrapper function                      | // Wrapper function         |
| function x (a , b ) {                    | function x (a , b ) {       |
| return getString ( a - 1) ;              | return getString ( a - 1) ; |
| }                                        | }                           |
|                                          |                             |
| var y = x (439 , 101) ;                  | var y = " Hello World !";   |
| // Object wrapper                        | // Object wrapper           |
| var o = {                                | var o = {                   |
| "k1": function (f , x ) {                | "k1": function (f , x ) {   |
| return f ( x ) ;                         | return f ( x ) ;            |
| } ,                                      | } ,                         |
| "k2": function (a , b ) {                | "k2": function (a , b ) {   |
| return a + b ;                           | return a + b ;              |
| }                                        | }                           |
| };                                       | };                          |
|                                          |                             |
| var f = getString ;                      | var f = getString ;         |
| var y = o . k1 (f , o . k2 (437 , 1) ) ; | var y = " Hello World !";   |

## *A. Augmenting Constant Propagation*

The standard intra-procedural constant propagation is a dataflow analysis. It applies the worklist algorithm to iteratively update abstract states attached to each program point, by propagating the results of a *transfer function*, which simulates program execution in an abstract domain. In particular, we set the abstract state as a map from symbols to abstract values: {Uninit, Const(some constant value), Unknown}.

Figure 10 demonstrates abstract states in action. In this example, since a and b are both known to be constants, we can calculate d after the first assignment; since c is Unknown, we have to set d to Unknown after the second assignment.

We augment constant propagation by extending the kinds of abstract values such that they can represent not only constant values, but also (1) references to prelude functions and (2) expressions with inline potential.

| // State : {a #0: 100 , b #0: 200 , c#0: Unknown , d#0: Unknown }                |  |  |  |  |
|----------------------------------------------------------------------------------|--|--|--|--|
| d = a + b ;<br>// State : {a #0: 100 , b #0: 200 , c#0: Unknown , d#0: 300}      |  |  |  |  |
| d = a + c ;<br>// State : {a #0: 100 , b #0: 200 , c#0: Unknown , d#0: Unknown } |  |  |  |  |

Fig. 10. Intra-Procedural Constant Propagation

## *B. Dynamic Execution of Prelude Functions*

After detecting the prelude, i.e. getStringArray, getString and the string rotation code, we remove these parts from the obfuscated code, and load them in a JavaScript execution engine such as V8 [50] or QuickJS [51]. This means the JavaScript execution context now contains the rotated global string table and the definition of getString(). Now, utilizing the C++ API exposed by the engine, we can programmatically invoke any function defined in the context. More specifically, we can call getString() with any literal arguments at any time, as if getString() is a builtin function - this is why we call it a *prelude function*.

Then, a reference to a prelude function is considered a valid abstract value during the augmented constant propagation analysis. Figure 11 demonstrates an example, assuming getString is a prelude function, and the dynamic execution of getString(438) yields "Hello World!".

```
// State : {a #0: Unknown , f#0: Unknown }
f = getString ;
// State : {a #0: Unknown , f#0: <prelude " getString " >}
a = f (438) ;
// State : {a #0: " Hello World !" , f#0: <prelude " getString " >}
// State computed by dynamically executing getString (438)
```

Fig. 11. Constant Propagation: Dynamic Execution Of Prelude

## *C. Inlining Indirections*

In order to inline Obfuscator.IO indirections, we further extend the abstract value to support certain expressions with inline potential. In particular, we support the kinds of expressions listed in Figure 12.

```
expr ::= string
      | number
      | unary_op expr
      | expr bin_op expr
      | identifier
      | expr [ expr ] # member expression
      | { property , ... } # object expression
      | expr ( expr , ...) # call expression
      | ( identifier , ...) = > expr # function expression
property ::= ( string : expr )
```

![](_page_7_Figure_10.jpeg)

Then, to overcome the limit of intra-procedural analysis where the abstract state only contains symbols in the current function under analysis, we pre-build a global lookup table for all symbols that are assigned only once with a supported expression. During the analysis, we look up symbols not only from the abstract state, but also from the global lookup table.

(1) Variable Alias: Figure 13 is the example of a variable alias. Note that the alias x is defined outside the function foo, but it is still available in the global lookup table.

```
// Global lookup table :
// x: <prelude " getString " >
// ...
var x = getString ;
...
function foo () {
  // State : {y #1: Unknown }
  var y = x (438) ;
  // State : {y #1: " Hello World !"}
  //
  // State is computed by:
  // - Look up `x` in the global inline map
  // - Evaluate getString (438)
  // - = " Hello World !" <- Dynamic execution
  ...
}
```

![](_page_7_Figure_15.jpeg)

(2) Wrapper Function: Figure 14 is the example of a wrapper function. During the analysis, we evaluate the expression x(439, 101) in multiple steps, involving substitution (similar to that in lambda calculus), binary expression evaluation (standard constant folding), and dynamic execution.

```
// Global lookup table :
// x: (a#1 , b #1) = > getString (a#1 - 1)
// ...
function x (a , b ) {
  return getString ( a - 1) ;
}
...
function foo () {
  // State : {y #2: Unknown }
  var y = x (439 , 101) ;
  // State : {y #2: " Hello World !"}
  //
  // State is computed by:
  // - Look up `x` in the global inline map
  // - Eval ((a#1 , b #1) = > getString (a#1 - 1))(439 , 101)
  // - = getString (439 - 1) <- Substitution
  // - = getString (438) <- Binary expr evaluation
  // - = " Hello World !" <- Dynamic execution
  ...
}
```

![](_page_7_Figure_18.jpeg)

(3) Object Wrapper: Figure 15 shows the example of an object wrapper, which serves as a repository of utility functions. Similar to wrapper functions, during the analysis, we evaluate the expression o.k1(f, o.k2(437, 1)) in multiple steps, which includes fetching properties from an object expression.

```
// Global lookup table :
// o: {
// 'k1 ': (f#1 , x#1) = > f#1(x#1) ,
// 'k2 ': (a#2 , b#2) = > a#2 + b#2
// }
var o = {
  'k1 ': function (f , x ) {
    return f ( x ) ;
  } ,
  'k2 ': function (a , b ) {
    return a + b ;
  }
};
...
function foo () {
  // { State : f #3: Unknown , y#3: Unknown }
  var f = getString ;
  // { State : f #3: <getString > , y#3: Unknown }
  var y = o . k1 (f , o . k2 (437 , 1) ) ;
  // { State : f #3: <getString > , y#3: " Hello World !"}
  //
  // State calculated by:
  // - Look up `o` in the global inline map
  // - Eval {...}. k1( < getString > , {...}. k2 (437 , 1))
  // = multiple steps ...
  // = <getString >(438)
  // = " Hello World !"
  ...
}
```

Fig. 15. Inlining Object Wrapper

## VI. EVALUATION

In this section, we evaluate the CASCADE deobfuscator and address the following research questions:

RQ1: Prelude Detection. What is the Gemini's accuracy of prelude function detection when processing obfuscated code?

RQ2: JSIR Transformation. How many literals does CAS-CADE recover from the obfuscated code? How long does it take to complete the deobfuscation?

RQ3: Lessons Learned. What are the lessons learned from adopting Gemini for automating challenging software engineering tasks like code deobfuscation?

## *A. Experimental Setup*

We constructed a dataset by randomly selecting 3,000 JavaScript samples of diverse lengths from the ETH 150k JavaScript Dataset [49,50]. We then obfuscated each sample using four different preset configurations of Obfuscator.IO (default, low, medium, and high), which theoretically generates 12,000 obfuscated code snippets. However, Obfuscator.IO failed to process some files, yielding actually 2,937 files per configuration. Table II shows the size distributions of original and obfuscated samples.

We instrumented Obfuscator.IO to output prelude function locations, which serve as ground truth for evaluating Gemini prelude detection. We use Gemini 2.5 Flash without thinking (1M input tokens), for its lower latency and cost - both important for production use, and found that it already works nearly perfectly.

TABLE II FILE SIZE DISTRIBUTIONS (KB)

|          | 50p   | 90p   | 95p   | 99p     |
|----------|-------|-------|-------|---------|
| Original | 2.2   | 19.9  | 40.4  | 186.0   |
| Default  | 5.8   | 31.0  | 58.4  | 286.3   |
| Low      | 6.9   | 26.2  | 46.6  | 207.7   |
| Medium   | 28.1  | 109.7 | 201.7 | 973.0   |
| High     | 125.8 | 340.4 | 600.7 | 2,642.0 |

TABLE III RQ1: GEMINI PRELUDE FUNCTIONS DETECTION RESULT

| Configuration | Samples | Responses<br>(/ Samples) | Correct<br>(/ Responses) |
|---------------|---------|--------------------------|--------------------------|
| Default       | 2935    | 2935<br>(100%)           | 2934<br>(99.97%)         |
| Low           | 2935    | 2935<br>(100%)           | 2935<br>(100%)           |
| Medium        | 2935    | 2918<br>(99.42%)         | 2910<br>(99.73%)         |
| High          | 2935    | 2867<br>(97.68%)         | 2825<br>(98.54%)         |
| All           | 11740   | 11655<br>(99.28%)        | 11604<br>(99.56%)        |

# *B. RQ1: Prelude detection*

Table III evaluates Gemini's prelude detection across various configurations, with each tested on 2,935 samples (down from 2,937 samples because 2 samples could not be annotated with IDs due to preprocessing failures from caused by invalid code semantics).

The Default and Low configurations both achieved a 100% response rate - meaning Gemini provided a prelude detection result for every sample; Gemini failed to return a result for some Medium and High samples, mostly due to out-of-tokenlimit errors. For those samples where Gemini successfully returned a result, a near-perfect 99.56% of them matched the ground truth.

# *C. RQ2: JSIR transformation*

TABLE IV RQ2: STRING RECOVERY RESULT

| Samples | Successes<br>(Rate %) | Avg.<br>Recovered<br>Literals    | Avg.<br>Running<br>Time (s) |
|---------|-----------------------|----------------------------------|-----------------------------|
| 2934    | 2929                  | 127.71                           | 0.844                       |
| 2934    | 2929                  | 150.05                           | 0.893                       |
| 2934    | 2895                  | 1050.14                          | 2.364                       |
| 2934    | 2857<br>(97.38%)      | 2493.29                          | 5.164                       |
| 11736   | 11610<br>(98.93%)     | 945.26                           | 2.298                       |
|         |                       | (99.83%)<br>(99.83%)<br>(98.67%) |                             |

In the experiment, we set a timeout of 60 seconds. If the deobfuscator crashes or does not complete after 60 seconds, CASCADE is considered to be failed. We also count the number of literals recovered by CASCADE and record the running time. Table III presents a summary of our string recovery results across various obfuscation configurations. Each configuration was evaluated on 2934 samples (down from 2937 since 3 samples failed to be preprocessed). Across all 11748 samples, our approach achieved an overall high success rate of 98.93% (11610 successes) with an average of 945.26 literals recovered per file and an average running time of 2.298 seconds.

## *D. RQ3: Lessons Learned*

In this RQ, we discuss our lessons learned from using LLMs in industrial software engineering tasks, especially JavaScript deobfuscation. LLMs' ever-growing reasoning and code understanding capabilities suggest significant potential for LLM-driven deobfuscation. Yet, our investigation reveals that a hybrid (LLM + compiler) is still required for reliable production use. In particular, it provides the following critical improvements to an LLM-only solution:

- (1) Reduce hallucination: Deobfuscation of a single file relies on hundreds of accurate arithmetic calculations during operations like string retrieval, parameter calculation, and dataflow analysis. Even one subtle miscalculation, such as an off-by-one error, can fundamentally alter program semantics (e.g. by inverting the result of a conditional operation). Delegating precise analysis and calculation to a compiler tool eliminates vast categories of potential errors caused by LLM hallucination, improving correctness, which is important for production use [48].
- (2) Provide observability and explainability: There is limited control and explanation over why and how an LLM returns a specific response, which might even be different from its own 'thought log'. For instance, when we tasked Gemini 2.5 Pro with deobfuscating a program that outputs "world hello", it mistakenly responded with "hello world" even though it correctly identified "world hello" in the thought chain. This discrepancy likely stems from biases in the training data - where "hello world" is significantly more prevalent. Our hybrid approach enforces a workflow such that the result is explainable and intermediate steps are observable, improving user confidence.
- (3) Improve verifiability and evaluability: Due to the inherent probabilistic nature of AI, an important factor to consider for production use is the cost of verifying result correctness, which, in the case of deobfuscation, is functional equivalence between obfuscated and deobfuscated code. Since an LLM-only deobfuscator can make a wide range of errors, such verification is difficult if not impossible. Limiting the non-deterministic part to prelude detection not only makes it easier for a human to verify its correctness, but also makes it possible to define a correctness metric for evaluation.
- (4) Reduce latency and cost: LLM-only deobfuscation requires large amounts of reasoning, as many output tokens are the result of multiple steps of calculation. Our hybrid approach enables the use of Gemini 2.5 Flash without thinking, reducing latency and token costs. Limiting LLM use to only Obfuscator.IO pattern detection allows us to

deploy CASCADE to scan millions of JavaScript files per day.

# VII. LIMITATION AND FUTURE WORK

While CASCADE has demonstrated success in string deobfuscation, several limitations remain. This section outlines key areas we plan to explore in future:

- (1) Agent Integration. Instead of a workflow of predefined steps, we will evolve CASCADE into a LLM agent. In the agent, the LLM decides by itself when to invoke various JSIR-based code transformation primitives. This could scale CASCADE to other obfuscators than Obfuscator.IO without new purpose-built logic, and defeat more circumventions.
- (2) Deployment. CASCADE is deployed in Google's production environment, where it is utilized to detect malicious JavaScript on Google platforms, thereby enhancing user protection. Future work includes extending its deployment to additional platforms and releasing CAS-CADE as an open-source artifact to promote wider adoption within the software engineering and security community.
- (3) Enhancing CASCADE. Currently CASCADE focuses on string obfuscation of Obfuscator.IO, which is the most important for improving readability. But other obfuscation techniques and other obfuscators also warrant attention. Future work will leverage JSIR's robust infrastructure to address other obfuscation strategies, e.g. control-flow flattening and dead code elimination, and support more JavaScript obfuscators.

# VIII. CONCLUSION

CASCADE is a novel hybrid approach to JavaScript deobfuscation, offering a significant advancement in addressing complex obfuscation techniques. This approach specializes in string obfuscation of Obfuscator.IO, the most popular JavaScript obfuscator by malware writers. CASCADE employs a hybrid architecture, integrating LLMs with JSIR to achieve automated and correct deobfuscation. LLMs automate the detection of prelude functions, substantially reducing manual engineering effort, while the JSIR ensures the correctness of code transformations. Consequently, CASCADE fulfills two critical requirements for deobfuscation: it enhances code readability through string recovery, and guarantees correctness by leveraging JSIR-based compiler infrastructure. We believe that our experience of a responsible combination of LLM and compiler tools can inspire other use cases in software engineering and security communities.

## REFERENCES

- [1] "Javascript-obfuscator: A powerful obfuscator for javascript and node.js," https://github.com/javascript-obfuscator/javascript-obfuscator.
- [2] G. Comanici, E. Bieber, M. Schaekermann, I. Pasupat, N. Sachdeva, I. Dhillon, M. Blistein, O. Ram, D. Zhang, E. Rosen *et al.*, "Gemini 2.5: Pushing the frontier with advanced reasoning, multimodality, long context, and next generation agentic capabilities," *arXiv preprint arXiv:2507.06261*, 2025.

- [3] "JSIR An MLIR-based JavaScript Intermediate Representation." https: //github.com/google/jsir.
- [4] Z. Li, C. Wang, Z. Liu, H. Wang, D. Chen, S. Wang, and C. Gao, "Cctest: Testing and repairing code completion systems," in *ICSE*, 2023.
- [5] D. Nam, A. Macvean, V. Hellendoorn, B. Vasilescu, and B. Myers, "Using an LLM to help with code understanding," in *ICSE*, 2024.
- [6] Y. Hong, S. Jiang, Y. Fu, and S. Khurshid, "On the effectiveness of large language models in writing alloy formulas," *arXiv preprint arXiv:2502.15441*, 2025.
- [7] S. Jiang, C. Zhu, and S. Khurshid, "Generating executable oracles to check conformance of client code to requirements of jdk javadocs using llms," *arXiv preprint arXiv:2411.01789*, 2024.
- [8] R. Schaeffer, B. Miranda, and S. Koyejo, "Are emergent abilities of large language models a mirage?" *NeurIPS*, 2024.
- [9] Y. Zhao, Y. Long, H. Liu, R. Kamoi, L. Nan, L. Chen, Y. Liu, X. Tang, R. Zhang, and A. Cohan, "Docmath-eval: Evaluating math reasoning capabilities of llms in understanding financial documents," in *ACL*, 2024.
- [10] Z. Yuan, H. Yuan, C. Tan, W. Wang, and S. Huang, "How well do large language models perform in arithmetic tasks?" *arXiv preprint arXiv:2304.02015*, 2023.
- [11] G. Blanc, D. Miyamoto, M. Akiyama, and Y. Kadobayashi, "Characterizing obfuscated javascript using abstract syntax trees: Experimenting with malicious scripts," in *WAINA*, 2012.
- [12] X. Zhang, F. Breitinger, E. Luechinger, and S. O'Shaughnessy, "Android application forensics: A survey of obfuscation, obfuscation detection and deobfuscation techniques and their impact on investigations," *Forensic Science International: Digital Investigation*, 2021.
- [13] T. Doyle, "Privacy, obfuscation, and propertization," *IFLA Journal*, 2018.
- [14] B. Lynn, M. Prabhakaran, and A. Sahai, "Positive results and techniques for obfuscation," in *International conference on the theory and applications of cryptographic techniques*, 2004.
- [15] K. Brezinski and K. Ferens, "Metamorphic malware and obfuscation: a survey of techniques, variants, and generation kits," *Security and Communication Networks*, 2023.
- [16] M. Schloegel, T. Blazytko, M. Contag, C. Aschermann, J. Basler, T. Holz, and A. Abbasi, "Loki: Hardening code obfuscation against automated attacks," in *USENIX Security*, 2022.
- [17] D. Maiorca, D. Ariu, I. Corona, M. Aresu, and G. Giacinto, "Stealth attacks: An extended insight into the obfuscation effects on android malware," *Computers & Security*, 2015.
- [18] Z. Xie, M. Wen, H. Jia, X. Guo, X. Huang, D. Zou, and H. Jin, "Precise and efficient patch presence test for android applications against code obfuscation," in *ISSTA*, 2023.
- [19] S. A. Baset, S.-W. Li, P. Suter, and O. Tripp, "Identifying android library dependencies in the presence of code obfuscation and minimization," in *ICSE*, 2017.
- [20] J. Zhang, A. R. Beresford, and S. A. Kollmann, "Libid: reliable identification of obfuscated third-party android libraries," in *ISSTA*, 2019.
- [21] N. Pantelaios and A. Kapravelos, "Fv8: A forced execution javascript engine for detecting evasive techniques," *arXiv preprint arXiv:2405.13175*, 2024.
- [22] K. Ren, W. Qiang, Y. Wu, Y. Zhou, D. Zou, and H. Jin, "Jsrevealer: A robust malicious javascript detector against obfuscation," in *DSN*, 2023.
- [23] B. Li, P. Vadrevu, K. H. Lee, and R. Perdisci, "Jsgraph: Enabling reconstruction of web attacks via efficient tracking of live in-browser javascript executions," in *NDSS*, 2018.
- [24] D. Fraunholz and H. D. Schotten, "Defending web servers with feints, distraction and obfuscation," in *ICNC*, 2018.
- [25] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert, "Zozzle: fast and precise in-browser javascript malware detection," in *SEC*, 2011.
- [26] K. Ren, W. Qiang, Y. Wu, Y. Zhou, D. Zou, and H. Jin, "An empirical study on the effects of obfuscation on static machine learning-based malicious javascript detectors," in *ISSTA*, 2023.
- [27] Y. Huang, R. Wang, W. Zheng, Z. Zhou, S. Wu, S. Ke, B. Chen, S. Gao, and X. Peng, "Spiderscan: Practical detection of malicious npm packages based on graph-based behavior modeling and matching," in *ASE*, 2024.
- [28] B. Bichsel, V. Raychev, P. Tsankov, and M. Vechev, "Statistical deobfuscation of android applications," in *CCS*, 2016.
- [29] A. Herrera, "Optimizing away javascript obfuscation," in *SCAM*, 2020.
- [30] G. Lu and S. Debray, "Automatic simplification of obfuscated javascript code: A semantics-based approach," in *SERE(SSIRI)*, 2012.
- [31] M. AbdelKhalek and A. Shosha, "Jsdes: An automated de-obfuscation system for malicious javascript," in *ARES*, 2017.

- [32] A. Fass, M. Backes, and B. Stock, "Hidenoseek: Camouflaging malicious javascript in benign asts," in *CCS*, 2019.
- [33] "Synchrony a simple deobfuscator for mangled or obfuscated javascript files," https://github.com/relative/synchrony, 2024.
- [34] "Javascript deobfuscator general purpose javascript deobfuscator," https://github.com/ben-sb/javascript-deobfuscator.
- [35] "webcrack a tool for reverse engineering javascript," https://github. com/j4k0xb/webcrack.
- [36] Y. Qin, W. Wang, Z. Chen, H. Song, and S. Zhang, "TransAST: A machine translation-based approach for obfuscated malicious javascript detection," in *DSN*, 2023.
- [37] H. Zhong, S. Jiang, and S. Khurshid, "An approach for api synthesis using large language models," *arXiv preprint arXiv:2502.15246*, 2025.
- [38] K. Liu, Z. Chen, Y. Liu, J. M. Zhang, M. Harman, Y. Han, Y. Ma, Y. Dong, G. Li, and G. Huang, "Llm-powered test case generation for detecting bugs in plausible programs," *ACL*, 2025.
- [39] J. Richards and M. Wessel, "What you need is what you get: Theory of mind for an llm-based code understanding assistant," 2024.
- [40] A. Lozhkov, R. Li, L. B. Allal, F. Cassano, J. Lamy-Poirier, N. Tazi, A. Tang, D. Pykhtar, J. Liu, Y. Wei *et al.*, "Starcoder 2 and the stack v2: The next generation," *arXiv preprint arXiv:2402.19173*, 2024.
- [41] A. Gambardella, Y. Iwasawa, and Y. Matsuo, "Language models do hard arithmetic tasks easily and hardly do easy arithmetic tasks," in *ACL*, 2024.
- [42] S. Nikolov, D. Codecasa, A. Sjovall, M. Tabachnyk, S. Chandra, S. Taneja, and C. Ziftci, "How is Google using AI for internal code migrations?" *ICSE*, 2025.
- [43] "Now you see me, now you don't: Using llms to obfuscate malicious javascript," https://unit42.paloaltonetworks.com/ using-llms-obfuscate-malicious-javascript/.
- [44] C. Lattner, M. Amini, U. Bondhugula, A. Cohen, A. Davis, J. Pienaar, R. Riddle, T. Shpeisman, N. Vasilache, and O. Zinenko, "Mlir: Scaling compiler infrastructure for domain specific computation," in *2021 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)*, 2021, pp. 2–14.
- [45] Q. Hanam, F. S. d. M. Brito, and A. Mesbah, "Discovering bug patterns in javascript," in *FSE*, 2016.
- [46] S. Ndichu, S. Kim, S. Ozawa, T. Misu, and K. Makishima, "A machine learning approach to detection of javascript-based attacks using ast features and paragraph vectors," *Applied Soft Computing*, 2019.
- [47] M. Szafraniec, B. Roziere, H. J. Leather, P. Labatut, F. Charton, and G. Synnaeve, "Code translation with compiler representations," in *ICLR*, 2023.
- [48] J. Park, J. Park, S. An, and S. Ryu, "Jiset: Javascript ir-based semantics extraction toolchain," in *ASE*, 2020.
- [49] "Yara: The pattern matching swiss knife for malware researchers (and everyone else)," https://virustotal.github.io/yara.
- [50] "V8 javascript engine," https://github.com/v8/v8.
- [51] "Quickjs javascript engine," https://github.com/bellard/quickjs.