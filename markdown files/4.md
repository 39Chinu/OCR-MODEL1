# **The Complexity of Color-constrained Paths in Semicomplete Multipartite Digraphs**

## **Julian Brinkmann** [#](mailto:J.Brinkmann@em.uni-frankfurt.de)

Goethe University Frankfurt, Germany

#### **Abstract**

Every semicomplete multipartite digraph contains a quasi-Hamiltonian path, but the problem of finding a quasi-Hamiltonian path with prescribed start and end vertex is NP-complete even when restricted to semicomplete multipartite digraphs with independence number exactly 3. Recently, Bang-Jensen, Wang and Yeo (arXiv 2024) showed that deciding the presence of a quasi-Hamiltonian cycle which does not contain at least one vertex from each color class is NP-complete. Similarly, deciding the presence of a quasi-Hamiltonian cycle which intersects every part exactly once is also NP-complete as shown in the same work.

In this paper, we continue the study of paths with constraints on the number of covered vertices from each color class. We consider the problem of finding a path with prescribed start and end vertex that contains at least and at most vertices from each color class where all color classes have size exactly . This unifies the Hamiltonian path problem, the quasi-Hamiltonian path problem and the path-version of the cycle problems mentioned above, among other problems. Using Schaefer's dichotomy theorem, we classify the complexity of almost all problems in our framework. Notable open problems are the Hamiltonian path problem on semicomplete multipartite digraphs as well as the quasi-Hamiltonian path problem restricted to semicomplete multipartite digraphs with independence number 2.

We then investigate the quasi-Hamiltonian path problem restricted to semicomplete multipartite digraphs with independence number 2. We generalize sufficient criteria for Hamiltonian (, )-paths in semicomplete digraphs to sufficient criteria for quasi-Hamiltonian (, )-paths in this class. Although this does not settle the problem, our initial results suggest that this special case may be solvable in polynomial time.

# **Contents**

| 1 | Introduction                                             | 1  |  |  |  |
|---|----------------------------------------------------------|----|--|--|--|
| 2 | Terminology and Previous Work                            |    |  |  |  |
| 3 | Color Constrained Paths                                  |    |  |  |  |
| 4 | Structural Results                                       |    |  |  |  |
|   | 4.1<br>Sufficient Conditions for Quasi-Hamiltonian Paths | 9  |  |  |  |
|   | 4.2<br>Characterizing Hamiltonian Paths<br>.             | 15 |  |  |  |
|   | Bibliography                                             | 17 |  |  |  |

## <span id="page-1-0"></span>**1 Introduction**

A semicomplete multipartite digraph is a simple directed graph with color classes, also called parts or partite sets, 1, . . . , such that there exists at least one arc between vertices if and only if they are in different color classes. Note that the sets 1, . . . , are the unique maximal independent sets such that () <sup>=</sup> max{|1|, . . . , <sup>|</sup> |}. A semicomplete digraph is a semicomplete multipartite digraph with () <sup>=</sup> 1. A quasi-Hamiltonian path (resp. cycle) in is a path (resp. cycle) that contains at least one vertex from each color class. For semicomplete digraphs, quasi-Hamiltonian paths are Hamiltonian paths. Similarly, quasi-Hamiltonian cycles are Hamiltonian cycles. An (, )-path is path with start vertex and end vertex . We will often abbreviate quasi-Hamiltonian path by QHP and semicomplete multipartite digraph by SMD.

Generalizing a result of Redei [ ´ [Red34](#page-17-1) ´ ], Bang-Jensen and Gutin show that semicomplete multipartite digraphs always contain a quasi-Hamiltonian path [\[BG09\]](#page-17-2). While not every semicomplete multipartite digraph contains a Hamiltonian path, the longest path problem restricted to SMDs can be solved in time ( ) with an algorithm due to Gutin [\[Gut93\]](#page-17-3). Here, the value is the exponent of the running time of the fastest algorithm for computing a minimum cost maximum bipartite matching. As the longest path problem subsumes the Hamiltonian path problem, the same algorithm solves the Hamiltonian path problem restricted to SMDs. The complexity of the Hamiltonian path problem with prescribed endpoints restricted to SMDs is unknown.

In semicomplete digraphs, the presence of an (, )-Hamiltonian path can be decided in time ( 5 ) using the algorithm by Bang-Jensen, Manoussakis and Thomassen described in [\[BMT92\]](#page-17-4). For semicomplete multipartite digraphs, the presence of a quasi-Hamiltonian path whose endpoints are in the set {, } can be decided in time ( <sup>27</sup>) using the algorithm by Bang-Jensen, Maddaloni, and Simonsen described in [\[BMS13\]](#page-17-5). However, when the direction of the path is made explicit as well, the problem is NP-complete as shown in the same work. Though this is not stated in [\[BMS13,](#page-17-5) Theorem 3.1], the proof shows that the problem remains hard even when restricting the inputs to SMDs with independence number exactly 3. This is due to the fact that the reduction is from Boolean satisfiability and, apart from auxiliary singleton color classes, the color classes in the reduction correspond to the literals in clauses of the given CNF-formula. Thus, color classes of size 3 are sufficient when reducing from 3-SAT.

Recently, Bang-Jensen, Wang and Yeo showed a similar result in [\[BJWY24\]](#page-17-6): Deciding the presence of a quasi-Hamiltonian cycle satisfying the inequality 1 ≤ |() ∩ <sup>|</sup> <sup>&</sup>lt; <sup>|</sup> <sup>|</sup> for all such that 1 <sup>≤</sup> <sup>≤</sup> , i.e. a quasi-Hamiltonian cycle which avoids at least one vertex from each color class, is NP-complete. Similarly, deciding the presence of a quasi-Hamiltonian cycle where the equality <sup>|</sup>() ∩ | = 1 is satisfied for all such that 1 <sup>≤</sup> <sup>≤</sup> , i.e. a quasi-Hamiltonian cycle which intersects each color class exactly once, is NP-complete.

These recent results motivate us to consider path problems with prescribed start and end vertices under cardinality constraints on <sup>|</sup>() ∩ <sup>|</sup> for each such that 1 <sup>≤</sup> <sup>≤</sup> . Our formulation contains as special cases the Hamiltonian path problem, the quasi-Hamiltonian path problem and the pathanalogues of the cycle problems considered in [\[BJWY24\]](#page-17-6). Using Schaefer's dichotomy theorem [\[Sch78\]](#page-17-7), we are able to settle the complexity of the problem when constraints take the form ≤ |() ∩ | ≤ for all with 1 <sup>≤</sup> <sup>≤</sup> , where all color classes satisfy <sup>|</sup> <sup>|</sup> <sup>=</sup> , for almost all choices of parameters , and . We call this problem the (, , )-color-constrained path problem, abbreviated as (, , )-CCP, a formal definition is given in Section [3.](#page-4-0) Concretely, we show the following:

**Main Theorem [1.](#page-4-1)** *Let* (, , ) ∈ <sup>Z</sup> 3 *satisfy* <sup>0</sup> <sup>≤</sup> <sup>≤</sup> <sup>≤</sup> *and* <sup>≥</sup> <sup>1</sup>*. If* (, ) <sup>=</sup> (0, ) *or* <sup>=</sup> <sup>1</sup>*, the problem* (, , )*-*CCP *can be solved in polynomial-time. If* <sup>≥</sup> <sup>3</sup> *and* (, ) <sup>∉</sup> {(0, ), (, )}*, the problem* (, , )*-*CCP *is* NP*-complete.*

Thus, the unclassified cases are <sup>=</sup> <sup>=</sup> , which corresponds to the Hamiltonian path problem, and the cases where <sup>=</sup> 2 with (, ) <sup>≠</sup> (0, <sup>2</sup>). While semicomplete bipartite digraphs have received special attention in the literature, e.g. in [\[Yeo99\]](#page-17-8), we are unaware of any work that expressly deals with semicomplete multipartite digraphs of independence number at most 2. Thus, ours seems to be the first work studying this particular class. We generalize sufficient conditions for (, )-Hamiltonian paths in semicomplete digraphs from [\[BMT92\]](#page-17-4) to sufficient conditions for (, )-quasi-Hamiltonian paths in semicomplete multipartite digraphs. Concretely, we obtain the following results:

**Main Theorem [2.](#page-10-0)** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph and* , , <sup>∈</sup> *distinct vertices such that neither nor is contained in a 2-cycle and* <sup>−</sup> *as well as* <sup>−</sup> *are 2-strong. If* − {, , } *is not 2-strong and* ( − {, , }) ≥ <sup>4</sup>*, then contains an* (, )*-quasi-Hamiltonian path.*

**Main Theorem [3.](#page-13-0)** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph,* <sup>|</sup>| ≥ <sup>5</sup> <sup>+</sup> <sup>5</sup>() *and* () ≤ <sup>2</sup>*. Let* , <sup>∈</sup> *be different vertices of such that neither nor is contained in a 2-cycle,* <sup>⇒</sup> *, and* <sup>−</sup> *as well as* <sup>−</sup> *are 2-strong. If all 2-separators of and (if any) are trivial, then contains an* (, )*-quasi-Hamiltonian path.*

Main Theorems [2](#page-10-0) and [3](#page-13-0) generalize [\[BMT92,](#page-17-4) Theorem 3.3 and 3.4], respectively. Note that Main Theorem [3](#page-13-0) requires the independence number to be at most 2 indicating that the problem of finding a QHP with prescribed start and end vertex restricted to this class may be easier than the general case.

In [\[BMT92\]](#page-17-4), Bang-Jensen, Manoussakis and Thomassen use the corresponding conditions, among other results, to construct a polynomial-time algorithm for the (, )-Hamiltonian path problem on semicomplete digraphs. Note that, while the general (, )-quasi-Hamiltonian path problem is NPcomplete, the proof from [\[BMS13\]](#page-17-5) only works when allowing instances with () ≥ 3. The reduction is from 3-SAT and the independence number corresponds to the number of different literals allowed in a clause of the input formula. As 2-SAT is polynomial time solvable, this does not show hardness for instances with () ≤ 2. Obviously, the problem may still be NP-complete as witnessed by a more suitable reduction. Settling the complexity of this case is an interesting direction for future work.

By generalizing a result from [\[FLF80\]](#page-17-9), we also show that the existence of a Hamiltonian path is equivalent to unilateral connectivity for this class of SMDs. This implies that the Hamiltonian path problem restricted to this class can be solved in time ( 2 ), which beats the fastest previously known algorithm for general SMDs.

## <span id="page-2-0"></span>**2 Terminology and Previous Work**

Given a semicomplete multipartite digraph , we denote the unique partition {1, . . . , } underlying by (). Observe that () can be computed in polynomial time by inspecting the adjacency matrix. For a subset <sup>⊆</sup> (), we denote by () the set of vertices that share a color class with a vertex in . Formally, () <sup>=</sup> { <sup>∈</sup> () : <sup>∈</sup> ∈ (), <sup>∩</sup> <sup>≠</sup> ∅}. For vertices <sup>∈</sup> (), we write () instead of ({}). We denote the subgraph induced by a subset of () by []. Formally, [] <sup>=</sup> (, { <sup>∈</sup> () : , <sup>∈</sup> }). An (, )-path is a path starting at and ending in . An [, ]-path has end vertices in {, }, i.e. it is either an (, )-path or a (, )-path. If the arc exists in , we say that dominates . For sets of vertices , <sup>⊆</sup> (), we write <sup>⇒</sup> to denote that no vertex in dominates a vertex in . We write <sup>→</sup> if <sup>⇒</sup> and <sup>×</sup> <sup>⊆</sup> (). Given a path <sup>=</sup> <sup>1</sup> . . . ℓ , [ , ] denotes the subpath from to in , i.e. +<sup>1</sup> . . . −1 . Similarly, [ , [ denotes the path [ , ] − . The subpaths ] , ] and ] , [ are defined analogously. We also use this notation for subpaths in directed cycles. As the cycles are directed, this is unambiguous. A digraph is *strong* if it contains an (, )-path for every pair , <sup>∈</sup> () with <sup>≠</sup> . A digraph is *-strong* if it contains at least +1 vertices, is strong and remains strong after removing any set of at most −1 vertices.

A digraph is *unilaterally connected* if there exists an [, ]-path for every pair , <sup>∈</sup> () with <sup>≠</sup> . A *-separator* of vertices and is a set <sup>⊆</sup> () such that <sup>|</sup>| ≤ and there is no (, )-path in <sup>−</sup> . <sup>A</sup> -separator of and is *trivial* if +() ⊆ or −() ⊆ . Given an undirected graph , an *orientation* of is a digraph obtained from by replacing each edge with a single arc. A *biorientation* of is a digraph obtained from by replacing each edge with an arc or a pair of opposing arcs.

When dealing with path problems in semicomplete multipartite digraphs, it is often helpful to consider the following decomposition:

<span id="page-3-1"></span>**Lemma 2.1** [\[TV99\]](#page-17-10)**.** *Let* <sup>=</sup> (, ) *be a semicomplete multipartite digraph with color classes* 1, . . . , *. Then there exists a unique partition of into* 1, . . . , *, where, for all* <sup>1</sup> <sup>≤</sup> <sup>≤</sup> *,* [] *is either a strong component of or* <sup>⊆</sup> *for some* <sup>1</sup> <sup>≤</sup> <sup>≤</sup> *, such that* <sup>⇒</sup> *for all* <sup>1</sup> <sup>≤</sup> <sup>&</sup>lt; <sup>≤</sup> *and there are* <sup>∈</sup> *and* <sup>∈</sup> +<sup>1</sup> *such that* <sup>∈</sup> *for* <sup>1</sup> <sup>≤</sup> <sup>&</sup>lt; *.*

We call this unique partition the linear decomposition of . There is an ( 2 ) algorithm to find the linear decomposition of a given SMD [\[BMS13\]](#page-17-5): Find the strong components, find an acyclic ordering of the strong components and then group together all the vertices from the same color class that form consecutive components in the ordering.

When constructing (, )-quasi-Hamiltonian paths in SMDs, it is sufficient to find a collection of not necessarily internally disjoint (, )-paths that cover all color classes such that the union of all these paths is an acyclic digraph. This is due to the fact that two path whose union does not contain a cycle can be quasi-merged such that there is at least one vertex from each covered color class:

<span id="page-3-0"></span>**Lemma 2.2** [\[BMS13,](#page-17-5) Lemma 5.1]**.** *Let* <sup>=</sup> (, ) *be a semicomplete multipartite digraph, be an* (1, 1) *path and be an* (2, 2)*-path such that* <sup>∪</sup> *does not contain a directed cycle and* <sup>⊆</sup> () ∪() *be a vertex set where each vertex is from a distinct color class. Then and can be quasi-merged into a single* ( , )*-path covering , where* , ∈ {1, <sup>2</sup>}*. Such a quasi-merging can be performed in* (|() ∪ ()|) *time.*

Restricted to semicomplete digraphs , Lemma [2.2](#page-3-0) says that is path-mergeable, which is another generalization of tournaments, see also [\[BG98\]](#page-17-11). Although the paths are, in general, only partially merged by Lemma [2.2,](#page-3-0) we will refer to this process as merging. Using Lemmas [2.1](#page-3-1) and [2.2,](#page-3-0) it is not hard to show the following results by considering the structure imposed by the connectivity conditions:

<span id="page-3-5"></span>**Lemma 2.3** [\[BMS13,](#page-17-5) Theorem 5.2]**.** *Let* <sup>=</sup> (, ) *be a strong semicomplete multipartite digraph and let* <sup>⊆</sup> *be a vertex set where each vertex is from a distinct color class. There exists a cycle containing in and such a cycle can be identified in time* ( 2 )*.*

<span id="page-3-3"></span>**Lemma 2.4** (Reformulation of [\[BMS13,](#page-17-5) Lemma 5.6])**.** *Let* <sup>=</sup> (, ) *be a connected non-strong semicomplete multipartite digraph with* , <sup>∈</sup> *, let* 1, . . . , *be its linear decomposition and let* <sup>∈</sup> *,* <sup>∈</sup> *with* <sup>&</sup>lt; *. There exists an* (, )*-quasi-Hamiltonian path in if and only if* ∪ · · · ∪ *intersects all color classes of . In this situation, there is an algorithm computing an* (, )*-quasi-Hamiltonian path or deciding that there is none in time* ( 2 )*.*

<span id="page-3-4"></span>**Lemma 2.5** [\[BMS13,](#page-17-5) Lemma 5.8]**.** *Let* <sup>=</sup> (, ) *be a strong semicomplete multipartite digraph with vertices* , <sup>∈</sup> *and let* <sup>−</sup> *and* <sup>−</sup> *be strong. If* − {, } *is not strong then there exists an* (, )*-quasi-Hamiltonian path and such a path can be identified in time* ( 2 )*.*

<span id="page-3-2"></span>The following theorem summarizes Lemma 5.7, Lemma 5.8, Theorem 5.9 and Corollary 5.12 from [\[BMS13\]](#page-17-5) to characterize the existence of [, ]-quasi-Hamiltonian paths in sufficiently colorful SMDs. A complete, more complex characterization of weakly quasi-Hamiltonian-connected SMDs was given in [\[GLS12\]](#page-17-12), but Theorem [2.6](#page-3-2) is sufficient for our purposes.

**Theorem 2.6.** *Let be a strong semicomplete multipartite digraph and , distinct vertices of such that* ( − {, }) ≥ <sup>5</sup>*. Then has an* [, ]*-quasi-Hamiltonian path unless one of the following two conditions is satisfied, in which case there is no* [, ]*-quasi-Hamiltonian path:*

- **(i)** <sup>−</sup> *is not strong with linear decomposition* 1, . . . , *,* <sup>∈</sup> *and neither* <sup>1</sup> ∪ · · · ∪ *nor* ∪ · · · ∪ *covers all color classes of* <sup>−</sup> ()*.*
- **(ii)** <sup>−</sup> *is not strong with linear decomposition* 1, . . . , *,* <sup>∈</sup> *and neither* <sup>1</sup> ∪ · · · ∪ *nor* ∪ · · · ∪ *covers all color classes of* <sup>−</sup> ()*.*

When trying to find [, ]-quasi-Hamiltonian paths, it can be helpful to consider quasi-Hamiltonian cycles in − {, }. If the cycle is sufficiently large and obeys a particular structure, the following lemma can be used to obtain the desired path:

<span id="page-4-3"></span>**Lemma 2.7** [\[BMS13,](#page-17-5) Lemma 5.11]**.** *For any three distinct vertices of a strong semicomplete multipartite digraph there exists a quasi-Hamiltonian path connecting two of them.*

The following theorem generalizes [\[Tho80,](#page-17-13) Theorem 5.4], which was used in the algorithm for the (, )-Hamiltonian path problem in [\[BMT92\]](#page-17-4). In Section [4,](#page-9-0) we will generalize the two main remaining structural results used in [\[BMT92\]](#page-17-4).

<span id="page-4-2"></span>**Theorem 2.8** [\[GLS12,](#page-17-12) Theorem 3.2]**.** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph and let* , <sup>∈</sup> *be distinct vertices such that there exist three internally disjoint* (, )*-paths of length at least 2 in . Then contains an* (, )*-quasi-Hamiltonian path.*

# <span id="page-4-0"></span>**3 Color Constrained Paths**

In this section, we generalize the quasi-Hamiltonian path problem with prescribed endpoints by considering different constraints on the number of required vertices of each color. Recall that () is the unique partition of into maximal independent sets and that it can be computed in polynomial time. Note that the quasi-Hamiltonian (, )-path problem can be phrased as follows: Given and , <sup>∈</sup> (), does there exist an (, )-path such that 1 ≤ |() ∩ | ≤ |<sup>|</sup> for all ∈ (). By allowing the lower and upper bound to depend on , we obtain the following path problem on semicomplete digraphs, which we denote by (, , )-CCP:

(, , )-color-constrained path problem [(, , )-CCP] Instance: SMD <sup>=</sup> (, ) such that <sup>|</sup><sup>|</sup> <sup>=</sup> for all ∈ (), , <sup>∈</sup> Question: Does contain an (, )-path in such that ≤ |() ∩ | ≤ for all ∈ ()?

We want to stress that the condition that all color classes be of the same size is not really a restriction as any SMD with independence number () can be made to satisfy this condition by padding each color class with vertices that are not reachable from , e.g. vertices that only have outgoing arcs. This problem is hard for almost all choices of (, , ):

<span id="page-4-1"></span>**Main Theorem 1.** *Let* (, , ) ∈ <sup>Z</sup> 3 *satisfy* <sup>0</sup> <sup>≤</sup> <sup>≤</sup> <sup>≤</sup> *and* <sup>≥</sup> <sup>1</sup>*. If* (, ) <sup>=</sup> (0, ) *or* <sup>=</sup> <sup>1</sup>*, the problem* (, , )*-*CCP *can be solved in polynomial-time. If* <sup>≥</sup> <sup>3</sup> *and* (, ) <sup>∉</sup> {(0, ), (, )}*, the problem* (, , )*-*CCP *is* NP*-complete.*

We prove Main Theorem [1](#page-4-1) in 3 steps: First, we discuss the polynomial-time solvable and open cases. Second, we prove hardness for = 3 in Theorem [3.3.](#page-6-0) Finally, we lift the hardness from = 3 to the cases ≥ 4 by induction over in Corollary [3.4.](#page-8-0)

<span id="page-5-1"></span>

| Input                   | Output / Operation (𝑏 = 1)                        |              | Output / Operation (𝑏 = 2) |               |
|-------------------------|---------------------------------------------------|--------------|----------------------------|---------------|
| ∨<br>∨                  |                                                   | 𝑎 = 0        | 𝑎 > 0                      |               |
| 𝐴<br>𝐴<br>𝐴             |                                                   | /0           | unsatisfiable              |               |
| ∨<br>∨                  | 𝑎 = 0                                             | 𝐴<br>𝑎 = 1   | 𝑎 < 2                      | 𝑎 = 2         |
| 𝐴<br>𝐴<br>𝐵             | /0                                                | /0 and<br>/1 | /                          | /1 and<br>/0  |
| ∨<br>∨                  | 𝐴<br>𝐴<br>𝐵<br>𝐴<br>𝐵<br>𝐴<br>𝐵<br>replace by 1 ∨ |              |                            |               |
| 𝐴<br>𝐴<br>𝑋<br>0 ∨<br>∨ | 𝑋<br>replace by 𝑋 ∨                               |              |                            |               |
| 𝑋<br>𝑌<br>1 ∨<br>∨      | 𝑌<br>/0                                           |              |                            |               |
| 𝐴<br>𝐴<br>1 ∨<br>∨      | 𝐴<br>/0 and<br>/0<br>/                            |              |                            |               |
| 𝑋<br>𝑌<br>∨             | 𝑋<br>𝑌<br>/0                                      |              | 𝑋<br>𝑎 = 0                 | 𝑌<br>𝑎 > 0    |
| 𝐴<br>𝐴                  |                                                   | 𝐴            | remove                     | /1            |
| ∨                       | 𝐴<br>replace by 1                                 |              |                            |               |
| 𝐴<br>𝐴<br>0 ∨           | replace by 𝑋                                      |              |                            |               |
| 𝑋<br>1 ∨                | /0                                                | 𝑎 < 2,       | 𝑎 = 2                      |               |
| 𝑋                       | 𝑋                                                 |              | remove                     | /1            |
|                         | 𝑎 = 0                                             | 𝑎 = 1        |                            | 𝑋<br>𝑎 = 2    |
| 𝑋                       | remove                                            | /1           |                            | unsatisfiable |
|                         |                                                   | 𝑋            |                            |               |

**Figure 1.** Table of the reduction rules used in Lemma [3.1](#page-5-0) to simplify Boolean formulas

**Polynomial-time solvable and open cases.** Observe that (0, , )-CCP is simply the (, )-path problem on a special class of digraphs, so this case can be solved in polynomial time with any of the classical path-finding algorithm. Similarly, (, , )-CCP is the (, )-Hamiltonian path problem on a special class of semicomplete multipartite digraphs. The Hamiltonian path problem on general semicomplete multipartite digraphs without prescribed start and end point has an elegant solution using 1-path-cycle factors [\[Gut93\]](#page-17-3), but the complexity of the (, )-Hamiltonian path problem on semicomplete multipartite digraphs remains open. In the special case of semicomplete digraphs, i.e. (, , ) <sup>=</sup> (1, <sup>1</sup>, <sup>1</sup>), the problem is known to be polynomial-time solvable using the recursive algorithm of [\[BMT92\]](#page-17-4).

**Hardness.** We show NP-completeness of all remaining pairs 0 <sup>≤</sup> <sup>≤</sup> <sup>≤</sup> 3 for <sup>=</sup> 3 by a reduction from variants of <sup>3</sup>-SAT. Given a Boolean formula in CNF, we call an assignment of ita variables (, )*-satisfying* if it satisfies at least and at most literals in every clause. Consider the following variants of <sup>3</sup>-SAT, which we will call (, )-3-SAT: Given a Boolean formula in 3-CNF, decide if has an (, )-satisfying assignment. NP-completeness of these problems for 0 <sup>≤</sup> <sup>≤</sup> 2 and <sup>≤</sup> <sup>≤</sup> 3 easily follows from Schaefer's dichotomy theorem, see [\[Sch78\]](#page-17-7).

We will reduce (, )-3-SAT to (, , <sup>3</sup>)-CCP to show NP-completeness of the problem. Our reduction has trouble dealing with the same literal appearing more than once in any given clause, so we first prove two preprocessing lemma to avoid this situation.

<span id="page-5-0"></span>**Lemma 3.1.** *Let* <sup>0</sup> <sup>≤</sup> <sup>≤</sup> <sup>≤</sup> <sup>2</sup>*,* <sup>≥</sup> <sup>1</sup> *and let be an instance of* (, )*-3-SAT. There exists an algorithm which, in polynomial time, finds that is not* (, )*-satisfiable or computes a CNF-formula such that each clause of consists of 2 or 3 pairwise different literals and is* (, )*-satisfiable if and only if is* (, )*-satisfiable.*

**Proof.** The algorithm proceeds by iteratively replacing literals or clauses. In each step, the algorithm applies one of the rules displayed in Figure [1](#page-5-1) to reduce the current formula, replacing the clause with a smaller one or removing it entirely while assigning values to variables. Here, and denote literals with different underlying variables, denotes a constant and and are arbitrary literals or constants. The rules are only given up to permutation of their elements, i.e. <sup>∨</sup> <sup>∨</sup> is treated like <sup>∨</sup> <sup>∨</sup> . The operation / replaces the literal by and the negated literal by . The operation / is defined

| Input                     | Output / Operation |
|---------------------------|--------------------|
| ∨<br>∨                    | /1                 |
| 𝐴<br>𝐴<br>𝑋<br>∨<br>∨     | 𝐴<br>/1            |
| 𝐴<br>𝐴<br>𝑋<br>0 ∨<br>∨   | 𝑋<br>/1 and<br>/1  |
| 𝑋<br>𝑌<br>1 ∨<br>1 ∨<br>𝑋 | 𝑋<br>𝑌<br>remove   |
|                           |                    |

<span id="page-6-2"></span>**Figure 2.** Table of the reduction rules used in Lemma [3.2](#page-6-1) to simplify Boolean formulas

to be /. Both 1/1 and 0/0 induce no operation and the operations 1/0 and 0/1 cause the algorithm to output unsatisfiable. Similarly, the operation / causes the algorithm to output unsatisfiable. The correctness of the presented rules is immediate. In each step, a clause is removed or a literal is removed from a clause, so the algorithm can be seen to run in polynomial time with respect to ||.

<span id="page-6-1"></span>This covers all cases where 1 <sup>≤</sup> <sup>≤</sup> 2. The next lemma treats the case (, ) <sup>=</sup> (2, <sup>3</sup>).

**Lemma 3.2.** *Let be an instance of* (2, <sup>3</sup>)*-3-SAT. There exists an algorithm which, in polynomial time, finds that is not* (2, <sup>3</sup>)*-satisfiable or computes a CNF-formula such that each clause of consists of 3 pairwise different literals and is* (2, <sup>3</sup>)*-satisfiable if and only if is* (2, <sup>3</sup>)*-satisfiable.*

**Proof.** Figure [2](#page-6-2) gives a list of reduction rules that are the first phase of the algorithm. The notation is as in the proof of Lemma [3.1.](#page-5-0) After the formula has been exhaustively reduced, if it has not already been found that is not (2, <sup>3</sup>)-satisfiable, replace every occurrence of the constant 1 with a new variable .

We are now ready to prove hardness of the cases where = 3. We will then lift this to the general case of ≥ 3 by induction over .

<span id="page-6-0"></span>**Theorem 3.3.** *Let* (, ) ∈ {0, <sup>1</sup>, <sup>2</sup>, <sup>3</sup>} <sup>2</sup> \ {(0, <sup>0</sup>), (0, <sup>3</sup>), (3, <sup>3</sup>)}*. Then* (, , <sup>3</sup>)*-*CCP *is* NP*-complete.*

**Proof.** Membership of the problem (, , )-CCP in NP can easily be verified by using the witnesscharacterization of NP. The reductions presented here are modified versions of the constructions from [\[BMS13,](#page-17-5) [BJWY24\]](#page-17-6). The primary difference is that the instances constructed here satisfy <sup>|</sup><sup>|</sup> <sup>=</sup> 3 for all ∈ () whereas the instances of [\[BMS13,](#page-17-5) [BJWY24\]](#page-17-6) have color classes of arbitrary size. Actually, our constructed graphs will only satisfy () ≤ 3, so there may be color classes which are not of size exactly 3. However, this is not a problem: by iteratively adding vertices which are not reachable from , i.e. vertices with no negative neighbors, all color classes can be padded to size 3. Denote the result of padding the digraph by +.

The key elements of the reductions are the B-gadget [\[BJWY24\]](#page-17-6) and the W-gadget [\[BMS13\]](#page-17-5), which correspond to the cases <sup>≤</sup> 2 and <sup>=</sup> 3, respectively. These gadgets have the property that any (, ) path can contain at most one of two subpaths of a certain kind while satisfying the size constraints of (, , <sup>3</sup>)-CCP. This allows the modeling of truth assignments by identifying one path with 0 and the other with 1 while introducing one gadget for each variable. We will begin with the case <sup>≤</sup> 2.

The B-gadget [, , 1, 2] has vertex set <sup>=</sup> {, , 0, . . . , <sup>1</sup> , 1, . . . , 2+1} and the following arcs: <sup>0</sup> . . . <sup>1</sup> and <sup>1</sup> . . . 2+1 are paths such that every vertex on the path dominates all vertices preceding it except for its immediate predecessor and {0, . . . , <sup>1</sup> } → {1, . . . , 2+1}. The vertices of the gadgets will be partitioned differently depending on (, ), so some of the arcs will be removed later.

We now specify the reductions. Let be a formula in 3-CNF. Apply Lemma [3.1](#page-5-0) to obtain a formula or find that is not (, )-satisfiable. If it is not (, )-satisfiable, map to some fixed no-instance. Otherwise, let 1, . . . , be the variables of and 1, . . . , be the clauses of . Let occur times as a literal and times as a negated literal. For all such that 1 <sup>≤</sup> <sup>≤</sup> , we associate with the

B-gadget <sup>≔</sup> [ , , , ] and give each vertex in this gadget the superscript to uniquely identify all vertices. The -th occurrence of as a positive (resp. negative) literal corresponds to (resp. ). Denote by the set of vertices associated with the literals of the clause . Identify with +<sup>1</sup> and add arcs such that <sup>⇒</sup> for all and such that <sup>&</sup>lt; . If <sup>=</sup> 2, also add the vertices 1, . . . , 2+<sup>1</sup> such that +() <sup>=</sup> {+1} for all such that 1 <sup>≤</sup> <sup>&</sup>lt; <sup>2</sup> <sup>+</sup> 1 and +(2+1) <sup>=</sup> {1}. All vertices not in +() dominate . The color classes are defined as follows:

- is a color class for all 1 <sup>≤</sup> <sup>≤</sup> .
- { 0 , +<sup>1</sup> , } is a color class for all 1 <sup>≤</sup> <sup>≤</sup> (if does not exist, i.e. <sup>&</sup>lt; 2, remove it from the set).
- { , + } is a color class for all 1 <sup>≤</sup> <sup>≤</sup> . The same remark as above applies.
- { , 2+1} is a color class.

Remove all arcs between vertices in the same color class. Call the resulting SMD . Set <sup>≔</sup> <sup>1</sup> if <sup>=</sup> <sup>2</sup> and <sup>≔</sup> <sup>1</sup> otherwise. Set <sup>≔</sup> . We map to (+, , ). To prove correctness of our reduction, we will show that (+, , ) is a yes-instance of (, , <sup>3</sup>)-CCP if and only if there is an assignment of 1, . . . , such that in each clause at least and at most variables are satisfied. In order to achieve this, we first prove some structural properties of +.

"⇒": The vertex separates from +1 , so 1 , . . . , are traversed in this order in any (, )-path . In particular, any (, )-path uses all of the vertices 1, . . . , . Note that any (, )-path satisfying the upper bound can only go through either 0 or +<sup>1</sup> . If <sup>=</sup> 1, this is immediate as these vertices are in the same color class. If <sup>=</sup> 2, any (, )-path starts with the subpath <sup>1</sup> . . . 2+1<sup>1</sup> and is in the same color class as 0 and +<sup>1</sup> . Therefore, the size constraint of 2 for { 0 , +<sup>1</sup> , } is effectively a constraint of size 1 for { 0 , +<sup>1</sup> }. This implies that any (, )-path satisfying the upper bound contains either the subpath 0 . . . or 1 . . . +<sup>1</sup> . The vertex has only two positive neighbors, 0 and 1 . If contains , then . . . +<sup>1</sup> is a subpath of as +( ) ⊆ { 1 , . . . , +1 } for all 1 <sup>≤</sup> <sup>≤</sup> . This makes using an arc to a previous -vertex impossible when trying to reach . Additionally, cannot contain 0 and for any such that 1 <sup>≤</sup> <sup>≤</sup> <sup>+</sup> 1 as 0 and +<sup>1</sup> are mutually exclusive. Therefore, must contain the subpath 0 . . . if it does not contain 1 . . . +<sup>1</sup> as this is the only path from to that does not use any .

 Let now be an (, )-path witnessing that (+, , ) is a yes-instance. Set () <sup>≔</sup> 1 if <sup>0</sup> . . . is a subpath of , else set () <sup>≔</sup> 0. As the literals associated to the clause form a color class in +, this assignment sets at least and at most literals to 1 for each clause.

"⇐": Let an assignment : {1, . . . , } → {0, <sup>1</sup>} be given such that in each clause at least and at most literals are satisfied. Let <sup>0</sup> <sup>=</sup> <sup>1</sup> . . . 2+1<sup>1</sup> if <sup>=</sup> 2 and <sup>0</sup> <sup>=</sup> <sup>1</sup> if <sup>&</sup>lt; 2. For each 1 <sup>≤</sup> <sup>≤</sup> , set <sup>≔</sup> <sup>0</sup> . . . if () <sup>=</sup> 1 and <sup>≔</sup> 1 . . . +<sup>1</sup> if () <sup>=</sup> 0. Then <sup>0</sup> . . . is an (, )-path satisfying the cardinality constraints imposed by the parameters (, ) as the literals in each clause are pairwise different.

This leaves the case <sup>=</sup> 3 and ∈ {1, <sup>2</sup>}. Let be an instance of (, )-3-SAT. If <sup>=</sup> 2, preprocess to obtain the formula or map to a fixed no-instance if was determined not to be (2, <sup>3</sup>)-satisfiable. Otherwise, set <sup>≔</sup> . Let 1, . . . , be the variables of and 1, . . . , be the clauses of .

Figure [3](#page-8-1) depicts the prototypical -gadget. The -gadget [, , 1, 2] is obtained from Figure [3](#page-8-1) by replacing with , with , with a clique 1, . . . , <sup>1</sup> and with a clique 1, . . . , <sup>2</sup> . Here, a clique is a set of vertices where all possible arcs between any pair of different vertices exist. The arcs between the cliques and the remaining vertices are given by the arcs of Figure [3.](#page-8-1) Let be the number of positive occurrences of and the number of its negative occurrences. Introduce a -gadget [ , , , ] for each 1 <sup>≤</sup> <sup>≤</sup> . Give each vertex in the superscript to uniquely identify it. The -th positive (resp. negative) occurrence of is associated with (resp. ). Denote the vertices associated to

<span id="page-8-1"></span>![](_page_8_Figure_1.jpeg)

**Figure 3.** The -gadget as defined in [\[BMS13\]](#page-17-5).

the literals of clause by . Add arcs such that <sup>⇒</sup> and add the arc +<sup>1</sup> for all and such that 1 <sup>≤</sup> <sup>&</sup>lt; <sup>≤</sup> . The color classes are { , }, { , } and for all such that 1 <sup>≤</sup> <sup>≤</sup> . Remove arcs between vertices of the same color and call the resulting SMD . We map to (+, , ), where <sup>=</sup> 1 and <sup>=</sup> .

"⇒": Let be an (, )-path witnessing that (+, <sup>1</sup> , ) is a yes-instance. The crucial property of the -gadget is that any (, )-path cannot contain both and . This was proven in [\[BMS13,](#page-17-5) Theorem 3.1] but can also be seen from inspecting Figure [3.](#page-8-1) Replacing and with cliques does not change this fact. Set () <sup>≔</sup> 1 if { 1 , . . . , } ∩ () <sup>≠</sup> <sup>∅</sup> and () <sup>=</sup> 0 otherwise. As contains at least vertices from each , this assignment satisfies at least and at most <sup>=</sup> 3 variables from each clause, so is (, )-satisfiable.

"⇐": Let be an assignment witnessing that is (, )-satisfiable. Let be a quasi-Hamiltonian path in +[ 1 , . . . , ] if () <sup>=</sup> 1 and a quasi-Hamiltonian path in +[ 1 , . . . , ] if () <sup>=</sup> 0. Set <sup>=</sup> if () <sup>=</sup> 1 and <sup>=</sup> otherwise. Then <sup>=</sup> <sup>1</sup> . . . witnesses that (+, <sup>1</sup> , ) is a yes-instance as satisfies at least variables in every clause and the literals in each clause are pairwise different if <sup>=</sup> 2.

<span id="page-8-0"></span>**Corollary 3.4.** *Let* (, , ) ∈ <sup>Z</sup> 3 *such that* <sup>≥</sup> <sup>3</sup>*,* (, ) <sup>∉</sup> {(0, <sup>0</sup>), (0, ), (, )} *and* <sup>0</sup> <sup>≤</sup> <sup>≤</sup> <sup>≤</sup> *. Then* (, , )*-*CCP *is* NP*-complete.*

**Proof.** The statement has been shown for = 3. We inductively show hardness for + 1 > 3 assuming the statement for . Notice that by padding all color classes with unreachable vertices, (, , )-CCP reduces to (, , <sup>+</sup> <sup>1</sup>)-CCP. Additionally, changing the start vertex to a new vertex ′ and forcing every ( ′ , )-path to begin with a path covering one vertex from each color class whose final vertex can then only go to shows that (, , )-CCP reduces to ( <sup>+</sup> <sup>1</sup>, <sup>+</sup> <sup>1</sup>, <sup>+</sup> <sup>1</sup>)-CCP. This is similar to how paths are prefixed in the proof of Theorem [3.3.](#page-6-0)

This leaves the cases (0, , <sup>+</sup> <sup>1</sup>) and (1, <sup>+</sup> <sup>1</sup>, <sup>+</sup> <sup>1</sup>). In the first case, the starting vertex of an instance of (0, <sup>−</sup> <sup>1</sup>, )-CCP may be modified such that one new vertex from each color class is hit before reaching the original start vertex to reduce (0, <sup>−</sup> <sup>1</sup>, )-CCP to (0, , <sup>+</sup> <sup>1</sup>)-CCP. In the second case, the color classes of an instance of (1, , )-CCP may simply be padded with unreachable vertices to reduce (1, , )-CCP to (1, <sup>+</sup> <sup>1</sup>, <sup>+</sup> <sup>1</sup>)-CCP.

Our analysis shows that almost all choices of and make (, , )-CCP NP-complete given that ≥ 3 while particular choices are polynomial time solvable establishing a partial classification that mirrors Schaefer's dichotomy theorem. We did not establish a full dichotomy as the complexity of (1, <sup>1</sup>, <sup>2</sup>)-CCP, (1, <sup>2</sup>, <sup>2</sup>)-CCP and (, , )-CCP remains open. The complexity of the corresponding SAT-problems suggests that these problems may be solvable in polynomial time.

## <span id="page-9-0"></span>**4 Structural Results**

It is noteworthy that the case <sup>=</sup> 2 seems to play a special role for (, , <sup>2</sup>)-CCP. This is similar to how 2 is a "magic number" for the coloring number, e.g. Yeo obtained stronger results for semicomplete bipartite digraphs than for general semicomplete multipartite digraphs in [\[Yeo99\]](#page-17-8). This motivates us to study the class of semicomplete multipartite digraphs with independence number at most 2 in this section. We are unaware of any previous work that expressly studies this particular class. We prove sufficient conditions for quasi-Hamiltonian paths as generalizations of results for semicomplete digraphs in Main Theorems [2](#page-10-0) and [3](#page-13-0) and a simpler characterization of Hamiltonian paths in this graph class in Corollary [4.7.](#page-15-1)

## <span id="page-9-1"></span>**4.1 Sufficient Conditions for Quasi-Hamiltonian Paths**

The algorithm for detecting Hamiltonian (, )-paths in semicomplete digraphs from [\[BMT92\]](#page-17-4) is based on three sufficient conditions for Hamiltonian (, )-paths in semicomplete digraphs. The first is due to Thomassen [\[Tho80,](#page-17-13) Theorem 5.4] and corresponds to Theorem [2.8](#page-4-2) restricted to semicomplete digraphs. Bang-Jensen, Manoussakis and Thomassen prove the other two in [\[BMT92,](#page-17-4) Theorem 3.3 and 3.4]. We augment the results of [\[GLS12\]](#page-17-12) by also lifting these two theorems to sufficient conditions for quasi-Hamiltonian paths in semicomplete multipartite digraphs. The first condition is lifted to general semicomplete multipartite digraphs in Main Theorem [2,](#page-10-0) while we lift the second condition to semicomplete multipartite digraphs with independence number at most 2 in Main Theorem [3.](#page-13-0) Before proving the main results of this section, we externalize a simple argument that appears multiple times to avoid repetitions and then show a minor result needed for the proof of Main Theorem [3.](#page-13-0)

<span id="page-9-3"></span>**Proposition 4.1.** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph and* , , <sup>∈</sup> *such that there exists an* (, )*-quasi-Hamiltonian path* <sup>=</sup> 0<sup>1</sup> . . . ℓ+<sup>1</sup> *in* <sup>−</sup> *. If any of the following conditions is satisfied, then contains an* (, )*-quasi-Hamiltonian path:*

- **a)** <sup>|</sup>()| <sup>&</sup>gt; <sup>1</sup>
- **b)** *There exist and with* <sup>0</sup> <sup>≤</sup> <sup>&</sup>lt; <sup>≤</sup> <sup>ℓ</sup> <sup>+</sup> <sup>1</sup> *such that* , <sup>∈</sup> *.*
- **c)** <sup>∈</sup> *or* <sup>∈</sup>

**Proof. a)** In this situation, is also an (, )-quasi-Hamiltonian path in .

- **b)** The path and <sup>0</sup> . . . . . . ℓ+<sup>1</sup> can be merged using Lemma [2.2](#page-3-0) to obtain the desired path.
- **c)** As we may assume that neither of the previous situations are applicable, <sup>|</sup>()| <sup>=</sup> 1. Consider the case <sup>∈</sup> . As is 2-strong, there exists a path from () to that does not contain . Let be a shortest such path and let its starting vertex be . Then and <sup>0</sup> . . . −1 can be merged using Lemma [2.2](#page-3-0) to obtain the desired path. The case <sup>∈</sup> is treated analogously by considering a shortest path from to () that does not contain .

<span id="page-9-2"></span>**Lemma 4.2** (Generalization of [\[BMT92,](#page-17-4) Lemma 3.2])**.** *Let* <sup>=</sup> (, ) *be a semicomplete multipartite digraph and* , <sup>∈</sup> *such that there exist two internally disjoint* (, )*-paths and a 2-separator* {, } *of and in . Let* ′ *denote the digraph obtained from by adding the arcs and if they do not exist already. Then has an* (, )*-quasi-Hamiltonian path if and only if* ′ *has an* (, )*-path intersecting each element of* ()*.*

**Proof.** Clearly, ′ has an (, )-path intersecting each element of () if has an (, )-quasi-Hamiltonian path. Let be an (, )-path intersecting each element of () in ′ . If does not use any of the new arcs, there is nothing to show, so assume uses the new arc . The case where uses instead is symmetric. Let be the strong component of − {, } containing and let be the strong component of − {, } containing . Let <sup>1</sup> <sup>=</sup> <sup>1</sup> . . . be a shortest path from ([, ]) to in whose internal vertices are only from and <sup>2</sup> <sup>=</sup> . . . <sup>2</sup> be a shortest path from to ([, ]) in

whose internal vertices are only from . Such paths exist as there are two internally disjoint (, )-paths in and {, } is an (, )-separator. Define <sup>1</sup> <sup>B</sup> [, 1[2], ] and <sup>2</sup> <sup>B</sup> [, [1]2, ]. These paths only use arcs that also exist in and <sup>1</sup> <sup>∪</sup> <sup>2</sup> does not contain a directed cycle. Applying Lemma [2.2](#page-3-0) yields an (, )-quasi-Hamiltonian path in .

Care must be taken when applying Lemma [4.2.](#page-9-2) While applying [\[BMT92,](#page-17-4) Lemma 3.2], i.e. Lemma [4.2](#page-9-2) restricted to semicomplete digraphs, transforms one semicomplete digraph into another semicomplete digraph, applying Lemma [4.2](#page-9-2) to a semicomplete multipartite digraph is only guaranteed to yield another semicomplete multipartite digraph when the independence number is at most 2. The problem is that when and are part of an independent set of size 3, say {, , }, adding arcs between and forces the existence of at least one arc between {, } and in order to satisfy the definition of semicomplete multipartite digraphs.

<span id="page-10-0"></span>**Main Theorem 2.** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph and* , , <sup>∈</sup> *distinct vertices such that neither nor is contained in a 2-cycle and* <sup>−</sup> *as well as* <sup>−</sup> *are 2-strong. If* − {, , } *is not 2-strong and* ( − {, , }) ≥ <sup>4</sup>*, then contains an* (, )*-quasi-Hamiltonian path.*

**Proof.** We may assume that () and () are singletons by adding the arcs or whenever necessary. This only makes finding an (, )-QHP harder. As <sup>−</sup> and <sup>−</sup> are 2-strong, all of , and have a positive neighbor in <sup>1</sup> as well as a negative neighbor in . In particular, there is an (, )-quasi-Hamiltonian path in <sup>−</sup> whose second vertex is in <sup>1</sup> and whose penultimate vertex is in by Lemma [2.4.](#page-3-3) Let <sup>=</sup> 0<sup>1</sup> . . . <sup>ℓ</sup> ℓ+<sup>1</sup> be a longest path in <sup>−</sup> with these properties. Using Proposition [4.1,](#page-9-3) we may assume that <sup>|</sup>()| <sup>=</sup> 1 and that there exists a with 0 <sup>&</sup>lt; <sup>&</sup>lt; ℓ <sup>+</sup> 1 such that {+1, . . . , ℓ+1} → → {0, . . . , −1}. Because − {, , } consists of at least 4 color classes, it follows that <sup>≥</sup> 4.

# <span id="page-10-1"></span>Claim 4.3. *We may assume* <sup>2</sup> <sup>∈</sup> *.*

Proof. Assume that this is not the case, so <sup>2</sup> <sup>→</sup> . Then <sup>→</sup> for all <sup>≥</sup> 2 by Proposition [4.1.](#page-9-3) Let <sup>=</sup> . . . be a path from to () in − {, 1} that is internally disjoint from (). If <sup>≠</sup> <sup>2</sup> or 1 <sup>∈</sup> , <sup>1</sup> . . . −1+<sup>1</sup> . . . ℓ+<sup>1</sup> is the desired path. Otherwise, we may assume that <sup>→</sup> <sup>1</sup> and can only be chosen such that <sup>=</sup> 2. As <sup>2</sup> <sup>→</sup> , has length at least 2 and yields a vertex <sup>∉</sup> () such that <sup>∈</sup> . Let <sup>2</sup> <sup>∈</sup> and <sup>∈</sup> . By the choice of , {3, . . . , ℓ+1} ⇒ and <sup>2</sup> is reachable from . Therefore, the structure of the linear decomposition implies <sup>=</sup> as one of {3, . . . , ℓ } must have an arc to due to the fact that <sup>≥</sup> 4.

Assume < . Then () <sup>=</sup> (ℓ) as otherwise <sup>1</sup> . . . ℓ−1ℓ is the desired path. We obtain the arc ℓ−<sup>1</sup> <sup>∈</sup> so that {2, . . . , ℓ−<sup>1</sup> <sup>⊆</sup> }. This also implies <sup>⊆</sup> () because any vertex in \ () yields the desired path. Additionally, we may assume <sup>=</sup> <sup>2</sup> as the successor of on must be adjacent to ℓ . Let 2 <sup>&</sup>lt; <sup>&</sup>lt; be such that <sup>1</sup> can reach through a path in − {, } internally disjoint from (). Then <sup>∉</sup> () as this would yield a path from to that is internally disjoint from (). One of +<sup>1</sup> . . . ℓ−1<sup>2</sup> . . . −1ℓ or +<sup>1</sup> . . . ℓ−1<sup>2</sup> . . . −2ℓ is the desired path. Thus, we may assume that any path in − {, } from <sup>1</sup> to another vertex in () must use <sup>2</sup> or ℓ . The only positive neighbors of ℓ in <sup>−</sup> are and . Consider two internally disjoint (, 3)-paths 1, <sup>2</sup> in <sup>−</sup> . Then one path must use , say 1, and it cannot contain <sup>2</sup> as this would imply that can reach a vertex from () in <sup>−</sup> without using a vertex from {, 1, 2} by using 2. Similarly, if <sup>1</sup> <sup>∈</sup> (1), then <sup>1</sup> must occur on <sup>1</sup> before as otherwise <sup>1</sup> must also contain 2. Let be the first vertex in <sup>1</sup> on () after . By the previous analysis, <sup>≥</sup> 3. Then 1[, ]], ℓ−1]<sup>1</sup> . . . −1ℓ or 1[, ]], ℓ−1]<sup>1</sup> . . . −2ℓ is the desired path.

This leaves only <sup>=</sup> . Then <sup>1</sup> <sup>⊆</sup> () and <sup>=</sup> <sup>2</sup> as otherwise we would obtain a longer (, )- QHP in <sup>−</sup> . Assume that <sup>|</sup>1<sup>|</sup> <sup>&</sup>gt; 1 and let <sup>∈</sup> <sup>1</sup> <sup>−</sup> 1. It holds that <sup>∈</sup> as <sup>−</sup> is 2-strong and −() ⊆ {, , }. Then 12<sup>3</sup> . . . ℓ+<sup>1</sup> or 12<sup>4</sup> . . . ℓ+<sup>1</sup> is the desired path, so we may assume <sup>|</sup>1<sup>|</sup> <sup>=</sup> 1. We will call vertices in −() − {, ℓ } dominators. Dominators exist as <sup>−</sup> is 2-strong. Note that it is impossible for <sup>1</sup> to be a dominator as <sup>|</sup>1<sup>|</sup> <sup>=</sup> 1. Similarly, cannot be a dominator as then <sup>1</sup> . . . ℓ is the desired path. Assume that <sup>∈</sup> () is a dominator. One of the paths 1+<sup>1</sup> . . . ℓ <sup>2</sup> . . . or 1+<sup>2</sup> . . . ℓ <sup>2</sup> . . . is the desired path unless <sup>=</sup> <sup>ℓ</sup> <sup>−</sup> <sup>1</sup> and (1) <sup>=</sup> (ℓ). The vertex ℓ has a predecessor in <sup>−</sup> that is not ℓ−1. It follows that () <sup>≠</sup> (ℓ) <sup>=</sup> (1), so 1 <sup>∈</sup> . If <sup>∉</sup> (), 1ℓ <sup>2</sup> . . . ℓ−<sup>1</sup> is the desired path. Else, <sup>=</sup> for some so that one of 1+<sup>1</sup> . . . ℓ−1<sup>2</sup> . . . ℓ or 1+<sup>2</sup> . . . ℓ−1<sup>2</sup> . . . ℓ is an (, )-quasi-Hamiltonian path in .

Now assume () does not contain a dominator. Let <sup>1</sup> <sup>=</sup> . . . and <sup>2</sup> <sup>=</sup> . . . be different internally disjoint paths from () to a dominator in <sup>−</sup> . Such paths exist as <sup>−</sup> is 2-strong. Assume that and are the only vertices in <sup>1</sup> and <sup>2</sup> in (). If this is not the case, say there exists ′ <sup>∈</sup> (1) ∩ () with ′ <sup>≠</sup> , then set <sup>1</sup> <sup>B</sup> 1[ ′ , ]. Iterating this process and an analogous one for <sup>2</sup> achieves the desired condition. If <sup>≠</sup> <sup>ℓ</sup> <sup>−</sup> 1, choose <sup>0</sup> <sup>B</sup> 1. If <sup>=</sup> <sup>ℓ</sup> <sup>−</sup> 1 and <sup>≠</sup> <sup>ℓ</sup> <sup>−</sup> 1, choose <sup>0</sup> <sup>B</sup> 2. Otherwise, choose the longer of the two paths as <sup>0</sup> breaking ties by choosing 1. Let <sup>0</sup> <sup>=</sup> . . . . Then <sup>∉</sup> (0) as otherwise merging and [, [<sup>0</sup> yields the desired path. Similarly, we obtain <sup>→</sup> as the arc yields the path <sup>0</sup> . . . ℓ . It follows that <sup>∉</sup> (0) as this yields <sup>0</sup> . . . ℓ 0[, ], which is the desired path. If <sup>=</sup> , we obtain a longer (, )-QHP in <sup>−</sup> . If <sup>=</sup> <sup>ℓ</sup> <sup>−</sup> 1, then also <sup>=</sup> <sup>=</sup> <sup>ℓ</sup> <sup>−</sup> 1 and so <sup>0</sup> is the longer path among <sup>1</sup> and 2. In particular, <sup>0</sup> has at least one internal vertex as <sup>1</sup> and <sup>2</sup> are different, so that <sup>0</sup> . . . ℓ−2<sup>0</sup> is a longer (, )-QHP in <sup>−</sup> . If <sup>≤</sup> 1, 0<sup>1</sup> . . . ℓ or 0<sup>2</sup> . . . ℓ is the desired path. This implies 1 <sup>&</sup>lt; <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 1, so one of 1+<sup>1</sup> . . . ℓ [2, [<sup>0</sup> or 1+<sup>2</sup> . . . ℓ [2, [<sup>0</sup> is the desired path.

By reversing all arcs and repeating the argument of Claim [4.3](#page-10-1) for ℓ−<sup>1</sup> instead of 2, we obtain ℓ−1 <sup>∈</sup> . The fact that 2, ℓ−1 <sup>∈</sup> implies 1, <sup>ℓ</sup> <sup>∈</sup> . Let be minimal such that <sup>∈</sup> . The vertices and are not a part of the linear decomposition and <sup>1</sup> is in 1, so 2 <sup>≤</sup> <sup>≤</sup> . Then {1, . . . , −1} ⇒ .

**Case 1**, 3 <sup>&</sup>lt; <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 1: If 1 <sup>∈</sup> , set <sup>=</sup> , else set <sup>=</sup> <sup>+</sup> 1. If −1ℓ <sup>∈</sup> , set <sup>=</sup> <sup>−</sup> 1, else set <sup>=</sup> <sup>−</sup> 2. Then 1+<sup>1</sup> . . . ℓ−12<sup>3</sup> . . . ℓ is an (, )-quasi-Hamiltonian path in .

**Case 2**, <sup>≤</sup> 3: Recall that dominators are vertices in −() − {, ℓ }.

**Case 2.1**, () does not contain any dominators. Let be an an arbitrary dominator. Assume that only has positive neighbors in () − . Let <sup>=</sup> . . . be a shortest path from () to in <sup>−</sup> . must have internal vertices by the assumption of this subcase. If <sup>∈</sup> (), merging and <sup>0</sup> . . . −1 using Lemma [2.2](#page-3-0) yields the desired path. Otherwise, one of <sup>0</sup> . . . −1+<sup>1</sup> . . . ℓ+<sup>1</sup> and <sup>0</sup> . . . −1+<sup>2</sup> . . . ℓ+<sup>1</sup> is a longer (, )-QHP in <sup>−</sup> .

Now assume has a negative neighbor in () − . If <sup>∈</sup> , <sup>1</sup> . . . ℓ is the desired path. If <sup>∈</sup> , <sup>1</sup> . . . ℓ is the desired path. If 1 <sup>∈</sup> , 1<sup>2</sup> . . . ℓ is the desired path. Let be minimal with the property that <sup>∈</sup> and there exists <sup>&</sup>lt; such that <sup>∈</sup> . The value <sup>ℓ</sup> <sup>+</sup>1 satisfies this property, so is well-defined. If (−1) <sup>≠</sup> (), <sup>0</sup> . . . −1 . . . ℓ would be a longer (, )-QHP in <sup>−</sup> , so () <sup>=</sup> (−1). Minimality of implies −2 <sup>∈</sup> .

If <sup>=</sup> <sup>ℓ</sup> <sup>+</sup> 1, 1ℓ <sup>2</sup> . . . ℓ−1 is the desired path unless (1) <sup>=</sup> (ℓ). As the arc ℓ−1 exists, <sup>∈</sup> . The previous analysis precludes the arc 1, so (1) <sup>=</sup> (). As <sup>−</sup> is 2-strong, has a predecessor ′ <sup>≠</sup> ℓ−1. If ′ <sup>=</sup> <sup>∈</sup> (), then 1 <sup>&</sup>lt; <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 1 as ⇒ {, 1, ℓ }. Thus, one of 1+<sup>1</sup> . . . ℓ <sup>2</sup> . . . or 1+<sup>2</sup> . . . ℓ <sup>2</sup> . . . is the desired path. Otherwise, ′ <sup>∉</sup> (). There must be an arc between <sup>1</sup> and ′ . If 1 ′ <sup>∈</sup> , 1 ′<sup>2</sup> . . . ℓ is an (, )-QHP. Else, ′ <sup>∈</sup> <sup>1</sup> and there exists a path ′ from <sup>1</sup> to ′ in 1. If <sup>2</sup> <sup>∉</sup> (′ ), ′<sup>2</sup> . . . ℓ is the desired path. In the other case, <sup>2</sup> <sup>∈</sup> (′ ) ⊆ <sup>1</sup> and one of 1<sup>3</sup> . . . ℓ−12ℓ or 1<sup>4</sup> . . . ℓ−12ℓ is the desired path.

If <sup>&</sup>lt; ℓ <sup>+</sup> 1, ′ <sup>B</sup> <sup>0</sup> . . . −2 . . . ℓ is an (, )-quasi-Hamiltonian path in <sup>−</sup> of equal length that contains a dominator. By a previous argument, <sup>→</sup> , so 1 <sup>≤</sup> <sup>−</sup> 2, i.e. the second vertex of ′ is still <sup>1</sup> <sup>∈</sup> 1. Additionally, the penultimate vertex in ′ remains <sup>ℓ</sup> <sup>∈</sup> . Thus, we may restart the proof with ′ instead of . The proof will then finish in case 2.2, so there is no circular reasoning.

**Case 2.2**, () contains a dominator. Let 1 <sup>≤</sup> <sup>&</sup>lt; be maximal such that is a dominator. We differentiate the cases <sup>≠</sup> 1 and <sup>=</sup> 1. Assume <sup>≠</sup> 1. Then one of 1+<sup>1</sup> . . . ℓ <sup>2</sup> . . . or 1+<sup>2</sup> . . . ℓ <sup>2</sup> . . . is the desired path unless (1) <sup>=</sup> (ℓ) and <sup>=</sup> <sup>ℓ</sup> <sup>−</sup> 1. If there exists a with 2 <sup>≤</sup> <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 1 such that ℓ <sup>∈</sup> , then 1+<sup>1</sup> . . . ℓ−1<sup>2</sup> . . . ℓ or 1+<sup>2</sup> . . . ℓ−1<sup>2</sup> . . . ℓ is the desired path. Otherwise, it follows that ℓ ⇒ {1, . . . , ℓ−2}. As is not contained in any 2-cycles, we obtain ℓ → {, }, but <sup>−</sup> is 2-strong, so there exists a vertex <sup>∈</sup> − {, , , ℓ−1} such that ℓ <sup>∈</sup> . Let <sup>=</sup> . . . be a shortest path from () to in − {, ℓ }. If <sup>∈</sup> (), [, [ℓ and can be merged to obtain the desired path, so assume this is not the case. If <sup>=</sup> −2, then 1ℓ−1<sup>2</sup> . . . ℓ−3ℓ is the desired path. If <sup>=</sup> <sup>ℓ</sup> <sup>−</sup>1, <sup>1</sup> . . . ℓ−2ℓ is a longer (, )-QHP in <sup>−</sup> , which is a contradiction. If <sup>=</sup> 0, ℓ <sup>1</sup> . . . ℓ−<sup>1</sup> is the desired path. If 0 <sup>&</sup>lt; <sup>&</sup>lt; <sup>−</sup> 2, [, [ℓ +<sup>1</sup> . . . ℓ−<sup>1</sup> is a longer (, )- QHP in <sup>−</sup> unless (+1) <sup>=</sup> (ℓ). Then 1+<sup>2</sup> . . . ℓ−1[2, [ℓ is the desired path.

Now assume <sup>=</sup> 1. As has a positive neighbor in <sup>1</sup> and does not lie on a 2-cycle, <sup>|</sup>1<sup>|</sup> <sup>&</sup>gt; 1. Additionally, <sup>1</sup> must be strong as otherwise −(1) ⊆ {, , } which contradicts the fact that <sup>−</sup> is 2-strong and does not lie on a 2-cycle. Let <sup>∈</sup> <sup>1</sup> <sup>∩</sup> +(1). Note the it may be that <sup>=</sup> 2. If the arc <sup>2</sup> exists, we obtain a longer (, )-QHP in <sup>−</sup> . If the arc 2 exists, we obtain <sup>2</sup> <sup>∈</sup> <sup>1</sup> and one of the paths 1<sup>3</sup> . . . ℓ−12ℓ , 1<sup>3</sup> . . . ℓ−12ℓ , 1<sup>3</sup> . . . ℓ−12ℓ or 1<sup>4</sup> . . . ℓ−12ℓ is the desired path. Thus, there can be no arcs between <sup>2</sup> and , so () <sup>=</sup> (2). Then 1<sup>3</sup> . . . ℓ is an (, )-QHP in <sup>−</sup> of length <sup>|</sup>|, so we may assume <sup>∈</sup> by previous arguments. If () <sup>≠</sup> (ℓ), one of 1<sup>3</sup> . . . ℓ−1ℓ or 1<sup>4</sup> . . . ℓ−1ℓ is the desired path, so we may assume this is not the case. Thus, the vertex is a vertex in <sup>1</sup> with () <sup>=</sup> (ℓ) that behaves similarly to <sup>2</sup> or potentially even is 2.

If there exists 2 <sup>≤</sup> <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 2 such that ℓ <sup>∈</sup> , one of the paths 1+<sup>1</sup> . . . ℓ−1<sup>2</sup> . . . ℓ or 1+<sup>2</sup> . . . ℓ−1<sup>2</sup> . . . ℓ is the desired path. If there exists 2 <sup>≤</sup> <sup>&</sup>lt; <sup>ℓ</sup> <sup>−</sup> 2 such that <sup>∈</sup> , then one of the paths 1<sup>3</sup> . . . +<sup>1</sup> . . . ℓ , 1<sup>4</sup> . . . +<sup>1</sup> . . . ℓ , 1<sup>3</sup> . . . +<sup>2</sup> . . . ℓ or 1<sup>4</sup> . . . +<sup>2</sup> . . . ℓ is the desired path. Thus, assume no such exists. As <sup>=</sup> 1 is maximal, this implies {, , ℓ } ⇒ {2, . . . , ℓ−3}. If the arc ℓ−2ℓ exists, one of 1ℓ−1<sup>2</sup> . . . ℓ−2ℓ or 1ℓ−1<sup>3</sup> . . . ℓ−2<sup>ℓ</sup> is the desired path. Otherwise, it is impossible that ⊆ {2, . . . , <sup>ℓ</sup> } as the vertex ℓ−<sup>2</sup> separates <sup>3</sup> <sup>∈</sup> from <sup>1</sup> in <sup>−</sup> in this case contradicting the fact that <sup>−</sup> is 2-strong. Therefore, there exists <sup>∈</sup> − {2, . . . , <sup>ℓ</sup> } such that <sup>∈</sup> or <sup>∈</sup> . In the first case, 1<sup>2</sup> . . . ℓ or 1<sup>3</sup> . . . ℓ is the desired path. Otherwise, <sup>→</sup> and <sup>1</sup> . . . ℓ is the desired path.

**Case 3**, <sup>ℓ</sup> <sup>−</sup> <sup>1</sup> <sup>≤</sup> : If <sup>|</sup><sup>1</sup> <sup>∩</sup> ()| <sup>&</sup>gt; 2, reversing all arcs and applying the previous arguments to the reversal of yields a (, )-QHP in the reversed graph, i.e. the desired path in . Thus, we may assume that <sup>1</sup> <sup>∩</sup> () ⊆ {1, 2}. Assume 1ℓ−<sup>1</sup> <sup>∈</sup> . Then the path 1ℓ−1<sup>2</sup> . . . ℓ−2ℓ or 1ℓ−1<sup>2</sup> . . . ℓ−3ℓ is the desired path unless <sup>=</sup> 4 and (2) <sup>=</sup> (4). However, this is impossible as ( − {, , }) ≥ 4, so we may assume that 1ℓ−<sup>1</sup> <sup>∉</sup> . This implies (1) <sup>=</sup> (ℓ−1) and <sup>&</sup>gt; 4. Then (1) <sup>≠</sup> (ℓ−2), so 1ℓ−<sup>2</sup> <sup>∈</sup> . If (ℓ−3) <sup>≠</sup> (ℓ), 1ℓ−2ℓ−1<sup>2</sup> . . . ℓ−3ℓ is the desired path. Otherwise, <sup>&</sup>gt; 5 as ( − {, , }) ≥ 4, (1) <sup>=</sup> (ℓ−1) and (ℓ−3) <sup>=</sup> (ℓ). Thus, 1ℓ−2ℓ−1<sup>2</sup> . . . ℓ−4ℓ is an (, )-quasi-Hamiltonian path in .

For semicomplete digraphs, the chromatic number is identical to the number of vertices such that the condition ( − {, , }) ≥ 4 simplifies to <sup>|</sup>| ≥ 7. As a semicomplete digraphs satisfying all conditions of Main Theorem [2](#page-10-0) except for <sup>|</sup>| ≥ 7 has at least 6 vertices, restricting Main Theorem [2](#page-10-0) almost exactly yields Theorem 3.3 from [\[BMT92\]](#page-17-4), which does not have any restriction on the number of vertices.

<span id="page-13-0"></span>**Main Theorem 3.** *Let* <sup>=</sup> (, ) *be a 2-strong semicomplete multipartite digraph,* <sup>|</sup>| ≥ <sup>5</sup> <sup>+</sup> <sup>5</sup>() *and* () ≤ <sup>2</sup>*. Let* , <sup>∈</sup> *be different vertices of such that neither nor is contained in a 2-cycle,* <sup>⇒</sup> *, and* <sup>−</sup> *as well as* <sup>−</sup> *are 2-strong. If all 2-separators of and (if any) are trivial, then contains an* (, )*-quasi-Hamiltonian path.*

**Proof.** As this only makes finding an (, )-QHP harder, we may assume that () and () are singletons by adding the arcs or whenever necessary while ensuring that <sup>→</sup> . If no 2-separators exist, we obtain the desired path by Theorem [2.8.](#page-4-2) By Main Theorem [2,](#page-10-0) we may assume that − {, } is 2-strong. Let , <sup>∈</sup> be a 2-separator of and . Assume that is a 2-cycle using Lemma [4.2.](#page-9-2) We will assume that −() <sup>=</sup> {, } as the case +() <sup>=</sup> {, } is symmetric.

Assume there is an arc from to {, }, without loss of generality let <sup>∈</sup> . If <sup>∈</sup> , let be <sup>a</sup> [, ]-QHP in − {, } as given by Theorem [2.6.](#page-3-2) Theorem [2.6](#page-3-2) is applicable as we have

$$
\chi(D - \{x, y, u, w\}) \ge \left\lceil \frac{|V| - 4}{\alpha(D)} \right\rceil \ge 6.
$$

Then is the desired path. Otherwise, <sup>∉</sup> . If there are 2 internally disjoint (, )-paths in − {, }, there are 3 internally disjoint (, )-paths of length at least 2 in <sup>−</sup> and so Theorem [2.8](#page-4-2) yields an (, )-QHP in <sup>−</sup> and with that an (, )-QHP in . Thus, there exists <sup>∈</sup> − {, , , } such that {, } is a 2-separator of and in <sup>−</sup> . As this is also a 2-separator of and in , it must be a trivial 2-separator, so +() <sup>=</sup> {, }. By Lemma [4.2,](#page-9-2) we may assume to be a 2-cycle in . If <sup>∉</sup> , there must be 2 internally disjoint (, )-paths in − {, , } because all 2-separators of and are trivial. With the third path , this yields an (, )-QHP in − {, } through Theorem [2.8](#page-4-2) and with that an (, )-QHP in , so assume <sup>∈</sup> .

Set ′ <sup>B</sup> − {, }. If ′ <sup>−</sup> contains a [, ]-QHP, we obtain the desired path, so assume this is not the case. Thus, one of the two conditions of Theorem [2.6](#page-3-2) must apply as we have

$$
\chi(D - \{x, y, r, u, w\}) \ge \left\lceil \frac{|V| - 5}{\alpha(D)} \right\rceil \ge 5.
$$

If the first condition applies, ′ − {, } is not strong. As ′ is 2-strong, there exists an (, )-QHP in ′ by Lemma [2.5](#page-3-4) and is the desired path. If the alternative condition applies, ′ − {, } is not strong and contains an (, )-QHP in ′ by a symmetric argument, which also leads to the desired path. Therefore, we may assume {, } ⇒ .

If there are 3 internally disjoint (, {, })-paths in <sup>−</sup> , there are 3 internally disjoint (, )-paths or 3 internally disjoint (, )-paths of length at least 2, so Theorem [2.8](#page-4-2) yields an (, )-QHP. Thus, we may assume that there are , <sup>∈</sup> − {, , , } such that {, } is a 2-separator of and {, }. Then {, } also separates and , so it must hold that +() <sup>=</sup> {, }. As before, assume that is a 2-cycle in . If {, } ⇒ {, }, then the fact that all (, )-separators of size 2 are trivial implies that there are 3 internally disjoint ({, }, {, })-paths in − {, }. Thus, there are 3 internally disjoint (0, 1)-paths for some <sup>0</sup> ∈ {, } and <sup>1</sup> ∈ {, } in − {, } completing the proof using Theorem [2.8.](#page-4-2) Without loss of generality, assume that <sup>∈</sup> . If {, } ⇒ , there are 3 internally disjoint (, {, })-paths of length at least 2 in − {, } because all 2-separators of (, ) are trivial, which again completes the proof through Theorem [2.8.](#page-4-2) Thus, we may assume that <sup>∈</sup> or <sup>∈</sup> .

Consider the case <sup>∈</sup> . If − {, , } contains an [, ]-QHP , is the desired path. Otherwise, Theorem [2.6](#page-3-2) implies that − {, , , } or − {, , , } is not strong. If − {, , , } is not strong, Lemma [2.5](#page-3-4) yields an (, )-QHP in − {, } as − {, } is 2-strong. If − {, , , } is not strong, Lemma [2.5](#page-3-4) yields an (, )-QHP in − {, }. In either case, is the desired path. If , <sup>∈</sup> , we argue similarly to obtain an (, )-QHP. Thus, we may assume that the only arcs from {, } to {, } are and .

Set <sup>B</sup> − {, , , , , }. As − {, } is 2-strong, there are at least 2 arcs in each direction between and {, , , }. Assume is not strong with linear decomposition 1, . . . , . Then there exists an (, )-QHP in for any pair of vertices <sup>∈</sup> <sup>1</sup> and <sup>∈</sup> by Lemma [2.4.](#page-3-3) If there exists <sup>0</sup> ∈ {, } and <sup>1</sup> ∈ {, } such that +(0) ∩ <sup>1</sup> <sup>≠</sup> <sup>∅</sup> and −(1) ∩ <sup>≠</sup> <sup>∅</sup>, there exists a (0, 1)- QHP in [() ∪ {0, 1}]. This path easily expands to an (, )-QHP in . Thus, <sup>1</sup> ⇒ {, } or {, } ⇒ . In the first case, both and must have positive neighbors in <sup>1</sup> as − {, } is 2-strong. A vertex in must have a positive neighbor <sup>1</sup> ∈ {, , , }. No matter which one it is, it can be combined with some <sup>0</sup> ∈ {, } to obtain a (0, 1)-QHP in [() ∪ {0, 1}] which extends to an (, )-QHP in . The case {, } ⇒ is symmetric. Therefore, we may assume that is strong.

Let <sup>=</sup> <sup>0</sup> . . . ℓ−1<sup>0</sup> be a quasi-Hamiltonian cycle in . The existence of is guaranteed by Lemma [2.3.](#page-3-5) If {, } ⇒ (), let <sup>=</sup> . . . be a shortest ((), {, })-path in − {, }. As − {, } is 2-strong, both and must have negative neighbors in so that consists of 3 vertices, i.e. <sup>=</sup> with ∈ {, }. Let ∈ {, }\{} and ∈ {, }\{}. Then one of [+1, [ or [+2, [ is the desired path where indices are viewed modulo . Thus, we may assume that there exists an arc from () to {, }. Without loss of generality, assume that 1 <sup>∈</sup> . If <sup>2</sup> <sup>∈</sup> or <sup>2</sup> <sup>∈</sup> , we obtain the (, )-QHP [2, 1] or [2, 1] , so <sup>2</sup> ⇒ {, }. As () <sup>≠</sup> (), one of the arcs 2 or 2 must exist in . Using an analogous argument, we obtain <sup>3</sup> ⇒ {, }. Inductively, we conclude that 2+<sup>1</sup> ⇒ {, } and 2 ⇒ {, } for all <sup>∈</sup> <sup>N</sup>. In particular, <sup>ℓ</sup> can be assumed to be even.

If ⇒ {, }, let <sup>=</sup> . . . be a shortest ({, }, ())-path in − {, }. As − {, } is 2-strong, both and must have positive neighbors in so that consists of 3 vertices, i.e. <sup>=</sup> with (, ) ∈ {(, ), (, )}. Let ∈ {, } \ {} and ∈ {, } \ {}. Then, ] , −1] or ] , −2] is the desired path. Thus, we may assume that or has a positive neighbor on , i.e. 2 <sup>∈</sup> or 2+<sup>1</sup> <sup>∈</sup> for some <sup>∈</sup> <sup>N</sup>. In either case, an inductive argument analogous to the previous one yields {, } ⇒ 2+<sup>1</sup> ⇒ {, } and {, } ⇒ 2 ⇒ {, } for all <sup>∈</sup> <sup>N</sup>.

Assume the set contains at least 5 pairwise different color classes. Then, by Lemma [2.7,](#page-4-3) there exists a QHP <sup>=</sup> <sup>1</sup> . . . ℓ in [] with end vertices in {0, 2, 4}. One of the arcs <sup>1</sup> and <sup>1</sup> must exist as () ≤ 2. Similarly, one of the arcs ℓ and ℓ must exist. If <sup>1</sup> <sup>∈</sup> , then or is the desired path. Else, <sup>1</sup> <sup>∈</sup> , so or is the desired path.

Finally, assume contains at most 4 pairwise different color classes. Then () <sup>=</sup> 1 as () <sup>=</sup> <sup>2</sup> implies <sup>|</sup>()| <sup>=</sup> <sup>|</sup>| − <sup>6</sup> <sup>≥</sup> 9 which yields |()| ≥ 5. By assumption, this yields <sup>|</sup>()| ≥ 4, so consist of exactly 4 vertices. As () <sup>=</sup> 1, we have <sup>3</sup> → {, } → 0, so 1234 is a Hamiltonian path in .

Theorem [2.8,](#page-4-2) Main Theorem [2](#page-10-0) and Main Theorem [3](#page-13-0) restricted to semicomplete digraphs are the structural results used in [\[BMT92\]](#page-17-4) to construct a polynomial-time algorithm for the Hamiltonian (, ) path problem on semicomplete digraphs. However, it is not clear how one might generalize the algorithmic results of the same work in order to obtain a similar algorithm for quasi-Hamiltonian (, ) paths in semicomplete multipartite digraphs with independence number at most 2. The problem is NP-complete even when the independence number is bounded by 3 as shown in Section [3,](#page-4-0) but the results of this section suggest that the problem may be polynomial-time solvable for independence number at most 2.

# <span id="page-15-0"></span>**4.2 Characterizing Hamiltonian Paths**

The existence of Hamiltonian paths in general semicomplete multipartite digraphs is characterized by the existence of a 1-path-cycle factor as shown by Gutin in [\[Gut93\]](#page-17-3). Restricting the graph class to those semicomplete multipartite digraphs with independence number at most 2 allows a simpler characterization in terms of unilateral connectivity. To achieve this, we generalize the following result of Fink and Lesniak-Forster shown in [\[FLF80\]](#page-17-9) from orientations to biorientations in Corollary [4.6:](#page-15-2)

<span id="page-15-4"></span>**Lemma 4.4.** *[\[FLF80\]](#page-17-9) Let* <sup>∈</sup> <sup>N</sup>*. If is a collection of vertex-disjoint paths of length at most 2 in , then every unilaterally connected orientation of* <sup>−</sup> Ð ∈ () *contains a Hamiltonian path.*

In fact, an analysis of the proof given in [\[FLF80\]](#page-17-9) shows that one can argue against the existence of opposing arcs for the relevant vertices such that the original proof is mostly sufficient. In order to avoid restating the original proof with only slight modifications, we instead use the following lemma:

<span id="page-15-3"></span>**Lemma 4.5.** *Let* <sup>=</sup> (, ) *be a unilaterally connected digraph. There is an arc set* ′ <sup>⊆</sup> *containing exactly one arc from each 2-cycle such that* (, \ ′ ) *is unilateral.*

**Proof.** The digraph is unilateral if and only if there exists an ordering 1, . . . , of such that there exists a ( , )-path in − { : 1 <sup>≤</sup> <sup>&</sup>lt; } if <sup>&</sup>lt; [\[HNC65\]](#page-17-14). If the arc ( , ) lies on a 2-cycle for some and such that 1 <sup>≤</sup> <sup>&</sup>lt; <sup>≤</sup> , remove the arc ( , ), i.e. ′ <sup>B</sup> {( , ) ∈ : <sup>&</sup>lt; , ( , ) ∈ }. Let be a shortest ( , )-path in − { : 1 <sup>≤</sup> <sup>&</sup>lt; } for all and such that 1 <sup>≤</sup> <sup>&</sup>lt; <sup>≤</sup> . We show by induction over <sup>|</sup> <sup>|</sup> that the paths are also valid in ′ . This immediately implies that ′ is unilateral.

For <sup>|</sup> <sup>|</sup> <sup>=</sup> 1, the path uses only the arc ( , ). This arc cannot be in ′ as <sup>&</sup>lt; . Assume all of the paths of length at most are still valid and show the statement for paths of length <sup>+</sup> <sup>1</sup> <sup>≤</sup> <sup>−</sup> 1. Let <sup>=</sup> <sup>1</sup> . . . +<sup>2</sup> and <sup>2</sup> <sup>=</sup> . Then <sup>&</sup>lt; , so the arc ( , ) cannot be in ′ . The subpath [ , ] is a shortest path from to of length , without loss of generality assume <sup>=</sup> [ , ]. By the induction hypothesis, the path is valid in ′ so <sup>=</sup> is also valid.

<span id="page-15-2"></span>**Corollary 4.6** (Generalization of [\[FLF80\]](#page-17-9))**.** *Let be a biorientation of* <sup>−</sup> Ð =1 () *where* 1, . . . , *are pairwise disjoint paths of length at most* <sup>2</sup> *in . Then is unilaterally connected if and only if contains a Hamiltonian path.*

**Proof.** If contains a Hamiltonian path, it is clearly unilaterally connected. Using Lemma [4.5,](#page-15-3) the digraph can be turned into a unilaterally connected orientation of <sup>−</sup> Ð =1 (). Applying Lemma [4.4](#page-15-4) completes the proof.

Note that removing the edge in a path of length 1 is equivalent to introducing an independent set of size 2. This yields the following corollaries:

<span id="page-15-1"></span>**Corollary 4.7.** *Let be a semicomplete multipartite digraph such that* () ≤ <sup>2</sup>*. Then is unilaterally connected if and only if contains a Hamiltonian path.*

<span id="page-15-5"></span>**Corollary 4.8.** *The Hamiltonian path problem can be solved in time* ( 2 ) *for semicomplete multipartite digraphs with independence number at most 2.*

**Proof.** A semicomplete multipartite digraph is unilaterally connected if and only if no linear component is an independent set of size at least 2. There is a linear component that is an independent set of size at least 2 if and only if there are two consecutive strong components with no arcs between them in an acyclic ordering of the strong components. Such strong components are necessarily of size 1 such that this property can be checked in ( 2 ) time by computing and then sorting the strong components. Note that it is enough to consider up to 2 representing vertices for each strong component to determine the acyclic ordering. These representatives can be found using the pigeon hole principle as among any 3 vertices of a strong compoenent, there must be 2 with different colors.

Corollary [4.7](#page-15-1) is best possible in the sense that the condition () ≤ 2 cannot be relaxed to () ≤ 3. This fact can be verified by considering the complete bipartite graph 1,3. This graph does not contain a Hamiltonian path, so no biorientation of it can contain one either. However, when replacing each edge with two opposing arcs, the result is a strongly connected semicomplete bipartite digraph. Corollary [4.7](#page-15-1) generalizes Redei's result stating that every tournament contains a Hamiltonian path [ ´ [Red34](#page-17-1) ´ ]. Corollary [4.8](#page-15-5) improves the algorithm from [\[Gut93\]](#page-17-3) which runs in time ( ) indicating that the bounded independence number makes the class less complex from an algorithmic perspective. Here, is the exponent in the running time of the algorithm for computing a minimum cost maximum bipartite matching. While slower, the algorithm from [\[Gut93\]](#page-17-3) works for SMDs with arbitrary independence number.

# <span id="page-17-0"></span>**Bibliography**

- <span id="page-17-11"></span><span id="page-17-2"></span>**BG98** Jørgen Bang-Jensen and Gregory Z. Gutin. Generalizations of tournaments: A survey. *J. Graph Theory*, 28(4):171–202, 1998. [doi:10.1002/\(SICI\)1097-0118\(199808\)28:4<171::AID-JGT1>3.0.CO;2-G](https://doi.org/10.1002/(SICI)1097-0118(199808)28:4<171::AID-JGT1>3.0.CO;2-G). **BG09** Jørgen Bang-Jensen and Gregory Z. Gutin. *Digraphs - Theory, Algorithms and Applications, Second Edition*. Springer Monographs in Mathematics. Springer, 2009. [doi:10.1007/978-1-84800-998-1](https://doi.org/10.1007/978-1-84800-998-1).
- <span id="page-17-6"></span>**BJWY24** Jørgen Bang-Jensen, Yun Wang, and Anders Yeo. Generalized paths and cycles in semicomplete multipartite digraphs, 2024. [arXiv:2403.07597](https://arxiv.org/abs/2403.07597).
- <span id="page-17-5"></span>**BMS13** Jørgen Bang-Jensen, Alessandro Maddaloni, and Sven Simonsen. Quasi-hamiltonian paths in semicomplete multipartite digraphs. *Discret. Appl. Math.*, 161(7-8):889–898, 2013. [doi:10.1016/J.DAM.2012.12.003](https://doi.org/10.1016/J.DAM.2012.12.003).
- <span id="page-17-4"></span>**BMT92** Jørgen Bang-Jensen, Yannis Manoussakis, and Carsten Thomassen. A polynomial algorithm for hamiltonianconnectedness in semicomplete digraphs. *J. Algorithms*, 13(1):114–127, 1992. [doi:10.1016/0196-6774\(92\)90008-Z](https://doi.org/10.1016/0196-6774(92)90008-Z). **FLF80** John F. Fink and Linda Lesniak-Foster. Graphs for which every unilateral orientation is traceable. *Ars. Combinatoria*,
- <span id="page-17-9"></span>9:113–118, 1980. **GLS12** Yubao Guo, Mei Lu, and Michel Surmacs. Weakly quasi-hamiltonian-set-connected multipartite tournaments. *Discret.*
- <span id="page-17-12"></span>*Appl. Math.*, 160(10-11):1561–1566, 2012. [doi:10.1016/J.DAM.2012.02.012](https://doi.org/10.1016/J.DAM.2012.02.012).
- <span id="page-17-3"></span>**Gut93** Gregory Z. Gutin. Finding a longest path in a complete multipartite digraph. *SIAM J. Discret. Math.*, 6(2):270–273, 1993. [doi:10.1137/0406020](https://doi.org/10.1137/0406020).
- <span id="page-17-14"></span>**HNC65** Frank Harary, Robert Z. Norman, and Dorwin Cartwright. *Structural models: An introduction to the theory of directed graphs*, volume 82. Wiley New York, 1965.
- <span id="page-17-1"></span>**Red34 ´** Laszl ´ o R´ edei. Ein kombinatorischer Satz. ´ *Acta Litt. Szeged*, 7:39–43, 1934.
- <span id="page-17-7"></span>**Sch78** Thomas J. Schaefer. The complexity of satisfiability problems. In Richard J. Lipton, Walter A. Burkhard, Walter J. Savitch, Emily P. Friedman, and Alfred V. Aho, editors, *Proceedings of the 10th Annual ACM Symposium on Theory of Computing, May 1-3, 1978, San Diego, California, USA*, pages 216–226. ACM, 1978. [doi:10.1145/800133.804350](https://doi.org/10.1145/800133.804350).
- <span id="page-17-13"></span>**Tho80** Carsten Thomassen. Hamiltonian-connected tournaments. *J. Comb. Theory B*, 28(2):142–163, 1980. [doi:10.1016/](https://doi.org/10.1016/0095-8956(80)90061-1) [0095-8956\(80\)90061-1](https://doi.org/10.1016/0095-8956(80)90061-1).
- <span id="page-17-10"></span>**TV99** Meike Tewes and Lutz Volkmann. Vertex deletion and cycles in multipartite tournaments. *Discret. Math.*, 197-198:769– 779, 1999. [doi:10.1016/S0012-365X\(99\)90145-0](https://doi.org/10.1016/S0012-365X(99)90145-0).
- <span id="page-17-8"></span>**Yeo99** Anders Yeo. A polynomial time algorithm for finding a cycle covering a given set of vertices in a semicomplete multipartite digraph. *J. Algorithms*, 33(1):124–139, 1999. [doi:10.1006/JAGM.1999.1041](https://doi.org/10.1006/JAGM.1999.1041).