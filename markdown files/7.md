# Longest Unbordered Factors on Run-Length Encoded Strings

Shoma Sekizaki <sup>1</sup> and Takuya Mieno [1](https://orcid.org/0000-0003-2922-9434)

University of Electro-Communications, Chofu, Japan s2431091@edu.cc.uec.ac.jp , tmieno@uec.ac.jp

Abstract. A border of a string is a non-empty proper prefix of the string that is also a suffix. A string is unbordered if it has no border. The longest unbordered factor is a fundamental notion in stringology, closely related to string periodicity. This paper addresses the longest unbordered factor problem: given a string of length n, the goal is to compute its longest factor that is unbordered. While recent work has achieved subquadratic and near-linear time algorithms for this problem, the best known worst-case time complexity remains O ( n log n ) [Kociumaka et al., ISAAC 2018]. In this paper, we investigate the problem in the context of compressed string processing, particularly focusing on run-length encoded (RLE) strings. We first present a simple yet crucial structural observation relating unbordered factors and RLE-compressed strings. Building on this, we propose an algorithm that solves the problem in O(m<sup>1</sup>.<sup>5</sup> log 2 m ) time and O ( m log 2 m ) space, where m is the size of the RLE-compressed input string. To achieve this, our approach simulates a key idea from the O(n<sup>1</sup>.<sup>5</sup>)-time algorithm by [Gawrychowski et al., SPIRE 2015], adapting it to the RLE setting through new combinatorial insights. When the RLE size m is sufficiently small compared to n, our algorithm may show linear-time behavior in n, potentially leading to improved performance over existing methods in such cases.

Keywords: string algorithms · unbordered factors · run-length encoding

#### 1 Introduction

A non-empty string b is called a border of another string T if b is both a prefix and a suffix of T. A string is said to be bordered if it has a border, and unbordered otherwise. Unbordered factors are known to have a deep connection with the smallest period of the string. The length of a string uv is called a period of a string T if T = (uv ) k u for some strings u, v and an integer k ≥ 1. The concept of string periodicity is fundamental and has applications in various areas of string processing, including pattern matching, text compression, and sequence assembly in bioinformatics [\[16](#page-13-0)[,5,](#page-12-0)[20\]](#page-13-1).

In 1979, Ehrenfeucht and Silberger [\[9\]](#page-12-1) posed the problem of determining the conditions under which τ ( T) = π ( T ) holds for a string T of length n, where τ ( T ) denotes the length of the longest unbordered factor of T and π ( T ) denotes

#### 2 S. Sekizaki and T. Mieno

the smallest period of T. They further conjectured that τ (T) ≤ n/2 implies τ (T) = π(T). However, this conjecture was disproved by Assous and Pouzet [\[2\]](#page-12-2), who provided a counterexample. Subsequently, some progress was made toward the conjecture [\[6,](#page-12-3)[21,](#page-13-2)[7](#page-12-4)[,12,](#page-13-3)[14,](#page-13-4)[13\]](#page-13-5). Finally, in 2012, Holub and Nowotka [\[15\]](#page-13-6) solved this longstanding open problem, showing that τ (T) = π(T) holds if τ (T) ≤ 3n/7, and that this bound is tight due to the counterexample of [\[2\]](#page-12-2).

This result led to increased research activity on algorithms for computing the longest unbordered factor [\[8](#page-12-5)[,19,](#page-13-7)[11,](#page-13-8)[17\]](#page-13-9). As a special case, when a string of length n is periodic (i.e., its smallest period is at most n/2), its longest unbordered factor can be computed in O(n) time [\[8\]](#page-12-5). Unfortunately, since many strings are non-periodic on average [\[19\]](#page-13-7), this linear-time approach has limited applicability. For the general case, a straightforward O(n 2 )-time algorithm can be designed by constructing border arrays [\[16\]](#page-13-0), which can be computed in linear time, for all suffixes of a string T of length n. The resulting n border arrays indicate whether each factor of T is bordered or unbordered. The first non-trivial algorithm for computing the longest unbordered factor was proposed by Loptev et al. [\[19\]](#page-13-7), who presented an algorithm with average-case running time O(n <sup>2</sup>/σ<sup>4</sup> ), where σ is the alphabet size. Furthermore, Cording et al. [\[4\]](#page-12-6) proved that the expected length of the longest unbordered factor of a random string is n − O(σ −1 ), and used this result to propose an average-case O(n)-time algorithm. In terms of worstcase time complexity, all of the above are quadratic-time algorithms. The first worst-case subquadratic-time algorithm was given by Gawrychowski et al. [\[11\]](#page-13-8), whose algorithm runs in O(n √ n) time. We will later review the basic strategy of their algorithm, which we simulate in our approach. The state-of-the-art algorithm for this problem is an O(n log n)-time algorithm proposed by Kociumaka et al. [\[17,](#page-13-9)[18\]](#page-13-10), which exploits combinatorial properties of unbordered factors and sophisticated data structures, including the prefix-suffix query (PSQ) data structure. As of 2018 [\[17\]](#page-13-9), their algorithm was reported to run in O(n log n log<sup>2</sup> log n) time in the worst case due to the cost of constructing the PSQ data structures. Later improvements [\[18\]](#page-13-10) sped up the construction of the PSQ data structure to linear time, bringing the overall algorithm down to O(n log n) time. Whether the longest unbordered factor can be computed in O(n) time remains open.

In this paper, instead of directly aiming to an O(n)-time algorithm, we propose an efficient solution in the context of compressed string processing. Especially, this work focuses on the run-length encoding (RLE) of a string. We first give a simple but important relationship between unbordered strings and RLE strings (Lemma [2\)](#page-3-0). Using this relationship, we propose an RLE-based algorithm for computing all longest unbordered factors that runs in O(m √ m log<sup>2</sup> m) time and uses O(m log<sup>2</sup> m) space, where m is the size of the RLE-compressed string. When m is sufficiently small (e.g., m < n<sup>2</sup>/3−<sup>ε</sup> for a small constant ε > 0), our approach achieves O(n) time, thus improving the worst-case complexity over existing methods for such cases. On the one hand, the high-level idea of our approach is inspired by the algorithm of Gawrychowski et al. [\[11\]](#page-13-8), which achieves subquadratic time via a non-trivial combination of fundamental string data structures and combinatorial techniques on strings. On the other hand, our algorithm differs in details and require techniques specially tailored to unbordered factors in RLE strings, particularly in Sections [4.2](#page-7-0) and [4.3.](#page-10-0)

Several proofs are omitted due to space limitations. All the omitted proofs are provided in Appendix [A.](#page-13-11)

#### 2 Preliminaries

Let Σ be an alphabet. An element in Σ is called a character. An element in Σ<sup>⋆</sup> is called a string. The empty string is the string of length 0, which is denoted by ε. A string in which all characters are identical is called a unary string. The concatenation of strings S and T is written as S · T, or simply ST when there is no confusion. Let T be a non-empty string. If T = X · Y · Z holds for some strings X, Y , and Z, then X, Y , and Z are called a prefix, a factor, and a suffix of T, respectively. Further, they are called a proper prefix, a proper factor, and a proper suffix of T if X ̸= T, Y ̸= T, and Z ̸= T, respectively. A non-empty string B is called a border of T if B is both a proper prefix and a proper suffix of T. We call the occurrence of B as a prefix (resp. suffix) of T the prefix-occurrence (resp. suffix-occurrence) of border B. We call the longest border of T the border of T. A string T is said to be bordered If T has a border, and is said to be unbordered otherwise. We denote by |T| the length of T. For an integer i with 1 ≤ i ≤ |T|, we denote by T[i] the ith character of T. For integers i, j with 1 ≤ i ≤ j ≤ |T|, we denote by T[i..j] the factor of T that starts at position i and ends at position j. For strings S, T, we denote by lcp(S, T) the length of the longest common prefix (in short, lcp) of S and T. An integer p with 1 ≤ p ≤ |T| is called a period of T if T[i] = T[i + p] holds for all i with 1 ≤ i ≤ |T| − p. We call the smallest period of T the period of T. The border array Bord<sup>T</sup> of a string T is an array of length |T|, where Bord<sup>T</sup> [i] stores the length of the border of T[1..i] for each 1 ≤ i ≤ |T| [\[16\]](#page-13-0). The border-group array BG<sup>T</sup> of a string T is an array of length |T| such that, for each 1 ≤ i ≤ |T|, BG<sup>T</sup> [i] stores the length of the shortest border of T[1..i] whose smallest period equals that of T[1..i] if such a border exists, and BG<sup>T</sup> [i] = i otherwise [\[22\]](#page-13-12). It is known that the border array and the border-group array of a string T can be computed by O(|T|) character comparisons [\[16,](#page-13-0)[22\]](#page-13-12).

<span id="page-2-0"></span>The range maximum query (RMQ) over an integer array A of length N is, given a query range [i, j] ⊆ [1, N], to output a position p such that A[p] is a maximum value among sub-array A[i..j]. The range minimum query (RmQ) is defined analogously. The following result is known.

Lemma 1 (e.g., [\[3\]](#page-12-7)). There is a data structure of size O(N) that can answer any RMQ (and RmQ) over an integer array of length N in O(1) time. The data structure can be constructed in O(N) time.

In what follows, we fix an arbitrarily non-unary string T of length n for our purpose. This is because the longest unbordered factor of a unary string a · · · a is simply a.

## 3 Tools for RLE strings

This section provides some tools for RLE strings that are commonly used in Section [4.](#page-5-0)

#### 3.1 Run-Length Encoding; RLE

The Run-Length Encoding (RLE) of a string T, denoted by rle(T), is a compressed representation of T that encodes every maximal character run T[i..i + e − 1] in T by c e if (1) T[j] = c for all j with i ≤ j ≤ i + e − 1, (2) i = 1 or T[i − 1] ̸= c, and (3) i + e − 1 = n or T[i + e] ̸= c. We simply call a maximal character run in T a run in T. Also, we call the number e of characters c in a run c e the exponent of the run. The RLE size of string T, denoted by r(T), is the number of runs in T. For each i with 1 ≤ i ≤ r(T), we denote by R<sup>i</sup> the ith run of rle(T). Also, we denote by beg<sup>i</sup> (resp., endi) the beginning (resp., the ending) position of R<sup>i</sup> , and by exp<sup>i</sup> the exponent of R<sup>i</sup> . A factor of T is said to be RLE-bounded if the factor starts at beg<sup>i</sup> and ends at end<sup>j</sup> for some i, j with i ≤ j. In what follows, we use m to denote the RLE size of the given string T.

Example 1. The RLE of string T = aaabbcccccabbbb is a 3b 2c 5a 1b 4 . The exponents of the first two runs a <sup>3</sup> and b <sup>2</sup> are three and two, respectively. The factor T[4..11] = bbccccca of T is RLE-bounded since it starts at beg<sup>2</sup> = 4 and ends at end<sup>4</sup> = 11. The RLE size of T is 5.

<span id="page-3-0"></span>The following lemma establishes a significant connection between unbordered strings and RLE strings.

Lemma 2. Let u be a string of length at least two, and let a = u[1] and b = u[|u|]. If u is unbordered, then both au and ub are also unbordered.

Proof. For the sake of contradiction, assume that au is bordered. Let k be the length of the border of au. If k = 1, then the border of au is a, which implies a = b, contradicting the assumption that u is unbordered. If k > 1, let x be the border of au. Then, x[2..k] is a border of u, a contradiction. Therefore, au must be unbordered. The proof for ub is symmetric. ⊓⊔

From Lemma [2,](#page-3-0) any longest unbordered factor of a non-unary string T must be RLE-bounded. Furthermore, the number of occurrences of longest unbordered factors is at most m − 1 since any factor starting at the beginning position of the rightmost run is bordered. Also, the upper bound m − 1 is tight: For string (a eb e ) m <sup>2</sup> where e is a positive integer, all the occurrences of a eb <sup>e</sup> and b ea <sup>e</sup> are the longest unbordered factors. Similarly, the next observation holds:

<span id="page-3-1"></span>Observation 1 Let w be a non-empty string. If w · w[|w|] has a border of RLE size p, then w also has a border of RLE size p.

<span id="page-4-0"></span>![](_page_4_Figure_1.jpeg)

Fig. 1. Illustration for border a <sup>s</sup>B ′ b t of w. String B ′ is an RLE-bounded border of w ′ .

#### 3.2 RLE shortest border array

We define the RLE shortest border array rSBord of T as follows: For each i with 1 ≤ i ≤ m, rSBord[i] stores the RLE size of the shortest border of the prefix T[1..end<sup>i</sup> ] of T. For example, when T = aaabbbbaaaaaccaaaabbbaa, rSBord = [1, 0, 1, 0, 1, 2, 1].

To design an efficient algorithm for computing rSBord, we give an observation. Let w be a non-unary string, and let a <sup>s</sup> and b <sup>t</sup> be the first and the last run of w, respectively. Further let w ′ be the factor of w such that w = a <sup>s</sup>w ′ b t . If w has a border B with r(B) ≥ 3, then B = a <sup>s</sup>B′ b <sup>t</sup> holds for non-empty string B′ that is a border of w ′ . Also, the occurrences of B′ in w ′ as a suffix and as a prefix are RLE-bounded (see Fig. [1\)](#page-4-0). Namely, each border B of w with r(B) ≥ 3 can be obtained from some RLE-bounded border B′ of w ′ by prepending a <sup>s</sup> and appending b t to B′ .

From the above observation, we can compute rSBord as follows: for each i ≤ m, check whether each RLE-bounded border of a string R<sup>2</sup> · · · Ri−<sup>1</sup> can be extended to the left by R<sup>1</sup> and to the right by R<sup>i</sup> . A naïve implementation of this algorithm runs in O(m<sup>2</sup> ) time because all RLE-bounded borders of all prefixes of T ′ = R<sup>2</sup> · · · Rm−<sup>1</sup> can be computed by considering rle(T ′ ) as a string of length m − 2 over the alphabet Σ × N and constructing the border array of rle(T ′ ). To speed up, we make use of the following well-known fact about the periodicity of borders:

<span id="page-4-1"></span>Lemma 3 ([\[16\]](#page-13-0)). The set of borders of a string w can be partitioned into O(log |w|) groups according to their smallest periods.

Within such a group of borders, the characters that follow prefix-occurrences of all borders except the longest one must be identical due to periodicity. Thus, at most two distinct characters can follow prefix-occurrences of borders within the group. The same holds for the number of distinct characters preceding suffixoccurrences of borders within a group. Finally, by utilizing the border array and the border-group array of rle(T ′ ), we can compute rSBord in O(m log m) time:

<span id="page-4-2"></span>Lemma 4. Given rle(T), the RLE shortest border array rSBord of T can be computed in O(m log m) time.

Proof. Let T ′ = R<sup>2</sup> · · · Rm−1. We first construct the border array Bordrle(T′) and the border-group array BGrle(T′) of rle(T ′ ), considering rle(T ′ ) as a string of length m − 2 over Σ × N. For each j with 1 ≤ j ≤ m − 2, we scan the borders of rle(T ′ )[1..j] = rle(T)[2..j + 1] in decreasing order of their lengths, skipping some of them and processing the rest as follows: We check whether the current border B of rle(T ′ ) can be extended to the left by R<sup>1</sup> and to the right by Rj+2, by examining the runs immediately after the prefix-occurrence and before the suffix-occurrence of B in rle(T ′ )[1..j]. If the group to which B belongs has at least two borders, we perform the same procedure for the shortest border in the group. We then find the next group using the border-group array BGrle(T′) , update B to the longest border in that group, and repeat the above procedure. The time required to process each group is O(1), and there are O(log m) groups for each prefix of rle(T ′ ) by Lemma [3.](#page-4-1) Therefore, the total running time is O(m log m). ⊓⊔

#### 3.3 Some functions for RLE strings

Given rle(T), we construct array ExpSum of size m such that ExpSum[j] = P<sup>j</sup> <sup>k</sup>=1 exp<sup>k</sup> for each 1 ≤ j ≤ m. Then, given a text position i with 1 ≤ i ≤ n, we can compute the run to which the ith character T[i] belongs in O(log m) time by performing binary search on ExpSum. Tamakoshi et al. [\[23\]](#page-13-13) proposed an O(m)-space data structure based on RLE, called a truncated RLE suffix array (tRLESA). They showed that tRLESA enhanced with some additional information of size O(m) supports several standard string queries, such as pattern matching. By applying tRLESA and related data structures in conjunction with RMQ and/or RmQ (Lemma [1\)](#page-2-0), several additional queries can be efficiently supported, as detailed below.

<span id="page-5-2"></span>For positive integers i, p, j, q satisfying i ≤ m, p ≤ exp<sup>i</sup> , j ≤ m, and q ≤ exp<sup>j</sup> , let rlcp(i, p, j, q) denote the length of the longest common prefix of T[beg<sup>i</sup> + p − 1..n] and T[beg<sup>j</sup> + q − 1..n].

Lemma 5. After O(m log m)-time and O(m)-space preprocessing for rle(T), the value rlcp(i, p, j, q) can be computed in O(1) time for given integers i, p, j, and q.

For positive integers x, y, h, ℓ with h < x ≤ y ≤ m, we define

$$
\mathsf{ridx}_{x,y}(h,\ell) = \begin{cases} -1 & \text{if } \operatorname{lcp}(T[\mathsf{end}_h..n], T[\mathsf{end}_z..\mathsf{end}_y]) > \ell \text{ for all } x \leq z \leq y, \\ \arg\max_{z: x \leq z \leq y} \{\operatorname{lcp}(T[\mathsf{end}_h..n], T[\mathsf{end}_z..\mathsf{end}_y]) \leq \ell \} \quad \text{otherwise}.
$$

<span id="page-5-1"></span>In words, ridxx,y(h, ℓ) is the index x ≤ z ≤ y of a run such that T[endz..endy] has the longest lcp with T[endh..n] where the lcp length is at most ℓ, if such z exists.

Lemma 6. After O(m log m)-time and O(m)-space preprocessing for rle(T) and integers x, y with 1 ≤ x ≤ y ≤ m, the value ridxx,y(h, ℓ) can be computed in O(log m) time for given integers h and ℓ with h < x.

#### <span id="page-5-0"></span>4 Algorithm for computing longest unbordered factors

<span id="page-5-3"></span>In this section, we prove our main theorem:

Algorithm 1 Algorithm for computing the longest unbordered factor Input: String T of RLE size m.

<span id="page-6-0"></span>Output: The set of longest unbordered factors of T. 1: LUB ← longest-short-ub(T) ▷ LUB: set of longest unbordered factors. 2: ℓ <sup>⋆</sup> = max{|x| : x ∈ LUB} ▷ ℓ<sup>⋆</sup> : length of the longest unbordered factor. 3: Preprocess for rm-long-bordered 4: for k ← 5 to ⌈ √ m ⌉ do 5: Preprocess for candidate<sup>k</sup> 6: C ← {ε} 7: for i ← 1 to (k − 4)⌊ √ m⌋ do 8: C ← C ∪ {candidatek(i)} 9: end for 10: U ← rm-long-bordered(k, C) ▷ All strings in U are unbordered. 11: ℓ ← max{|u| : u ∈ U} 12: if ℓ < ℓ<sup>⋆</sup> then 13: continue ▷ Do nothing and continue to the next stage. 14: else if ℓ > ℓ<sup>⋆</sup> then 15: LUB ← ∅ ▷ Clear the current tentative solutions. 16: ℓ <sup>⋆</sup> ← ℓ 17: end if 18: LUB ← LUB ∪ {u ∈ U : |u| = ℓ ⋆ } 19: end for 20: return LUB

Theorem 1. Given an RLE encoded string rle(T) of RLE size m, we can compute the set of longest unbordered factors of T in O(m √ m log<sup>2</sup> m) time using O(m log<sup>2</sup> m) space.

The high-level strategy of our algorithm, presented in Algorithm [1,](#page-6-0) is essentially the same as that of Gawrychowski et al. [\[11\]](#page-13-8). We divide the input string T into ⌈ √ m ⌉ blocks J1, J2, . . . , J⌈ <sup>√</sup><sup>m</sup> ⌉ , where each block J<sup>k</sup> is RLE-bounded and has RLE size ⌊ √ m⌋ for every 1 ≤ k < ⌈ √ m ⌉. Throughout this section, we refer to a border of RLE size at most <sup>√</sup> m as a short border, and otherwise as a long border. Let ρ<sup>T</sup> denote the RLE size of a longest unbordered factor of T. Also, we refer to a factor starting at beg<sup>i</sup> and ending within the kth block J<sup>k</sup> as an (i, k) factor. Note that the longest unbordered factor of T must be an (i, k)-factor for some i and k since it is RLE-bounded (see Lemma [2\)](#page-3-0).

Let us look at Algorithm [1.](#page-6-0) The set LUB represents the current tentative solution and the variable ℓ ⋆ represents the length of an element in LUB. First of all, we invoke the subroutine longest-short-ub, which outputs the longest unbordered factors of RLE size at most 4 √ m, and tentatively update LUB and ℓ ⋆ (lines 1–2). The main part of our algorithm consists of O( √ m) stages, corresponding to the outer for loop (lines 4–19). In each stage, say the kth stage, we first compute a set C of candidates for longest unbordered factors that end within J<sup>k</sup> by calling the subroutine candidate<sup>k</sup> O(m) times (lines 7–9). Here, as we will show later in Lemma [7,](#page-7-1) the subroutine candidatek(i) returns one of the following three strings: (1) the longest unbordered (i, k)-factor, if such a factor exists; (2) the empty string, if all (i, k)-factors have short borders; or (3) an (i, k)-factor that has no short border but has a long border, otherwise. Then, the set C is guaranteed to contain a longest unbordered factor of T if (i) ρ<sup>T</sup> > 4 √ m and (ii) there is a longest unbordered factor ending within Jk. We then eliminate from C all factors that have a long border by calling the subroutine rm-long-bordered(k, C), which checks whether each string in C has a long border and removes it if so (line 10). If any candidates remain, we select the longest ones and update ℓ <sup>⋆</sup> and LUB if necessary (lines 11–18). After the outer for loop, we have the final answer LUB, thus output it.

The correctness of Algorithm [1](#page-6-0) is straightforward from the properties of the three subroutines longest-short-ub, candidatek, and rm-long-bordered. In what follows, we describe how to implement the subroutines efficiently.

### 4.1 Implementation of longest-short-ub

To implement longest-short-ub, we simply apply Lemma [4](#page-4-2) for all RLEbounded factors of RLE size 4 √ m. By doing so, we can compute the longest unbordered factors of RLE size at most 4 √ m in a total of O(m √ m log m) time.

# <span id="page-7-0"></span>4.2 Implementation of candidate<sup>k</sup>

Throughout this subsection, we fix an integer <sup>5</sup> <sup>≤</sup> <sup>k</sup> ≤ ⌈√ m ⌉ arbitrarily. The definition of function candidatek(i) is as follows: candidatek(i) returns the longest (i, k)-factor that has no short border, if it exist; or the empty string, otherwise. This definition leads to the following properties:

<span id="page-7-1"></span>Lemma 7. (1) If there is an unbordered (i, k)-factor, then candidatek(i) returns the longest unbordered (i, k)-factor. (2) If all (i, k)-factors have short borders, then candidatek(i) returns the empty string. (3) Otherwise, candidatek(i) returns an (i, k)-factor that has no short border but has a long border.

<span id="page-7-2"></span>Let Jk.first and Jk.last be the indices of runs such that T[begJk.first.. endJk.last] = Jk. Let D<sup>k</sup> = Jk−1Jk, x = Jk−1.first, y = Jk.first, and z = Jk.last. Namely, T[beg<sup>x</sup> ..endz] = D<sup>k</sup> and T[beg<sup>y</sup> ..endz] = J<sup>k</sup> hold. Let P<sup>i</sup> be the longest prefix of T[end<sup>i</sup> ..endz] that occurs in Dk. If P<sup>i</sup> = ε, then candidatek(i) returns T[beg<sup>i</sup> ..endz] since it has no short border. Otherwise, let p = r(Pi). If p = 1, candidatek(i) can be easily computed by comparing the characters of the ith run and the zth run. Thus, we assume p > 1 in the following. Let P<sup>i</sup> = aub<sup>e</sup><sup>1</sup> where a = P<sup>i</sup> [1], b e1 is the last run of P<sup>i</sup> , and u ∈ Σ<sup>⋆</sup> is the rest. Further let Γ be the set of exponents of b following some occurrences of au in Dk. If min Γ > e1, the next character of aub<sup>e</sup><sup>1</sup> in D<sup>k</sup> is always b. Then, any factor starting at end<sup>i</sup> and ending at end<sup>j</sup> ′ for some y ≤ j ′ ≤ z can not have a short border of RLE size exactly p because if such a border exists, the border forms aub<sup>e</sup> with e ≤ e1, contradicts that min Γ > e1. If min Γ ≤ e1, we define e<sup>2</sup> = max{γ ∈ Γ | γ ≤ e1}. Let end<sup>t</sup> be the starting position of an occurrence of aub<sup>e</sup><sup>2</sup> in Dk. We further define F(t, j) = T[endt..endz]\$T[beg<sup>x</sup> ..endy+j−1] for j with 1 ≤ j ≤ √ m, where \$ is a special character with \$ ̸∈ Σ. The next lemma holds:

Lemma 8. Assume min Γ ≤ e<sup>1</sup> holds. For each 1 ≤ j ≤ √ m, T[end<sup>i</sup> ..endy+j−1] has a short border of RLE size p if and only if F(t, j) has a short border of RLE size p.

Proof. Let j ′ = y + j − 1. (⇒) If T[end<sup>i</sup> ..end<sup>j</sup> ′ ] has a short border of RLE size p ≤ √ m, the border forms aubexp<sup>j</sup> ′ and it holds that exp<sup>j</sup> ′ ≤ e1. Also, exp<sup>j</sup> ′ ≤ e<sup>2</sup> holds since e<sup>2</sup> < exp<sup>j</sup> ′ ≤ e<sup>1</sup> contradicts the definition of e2. Therefore, F(t, j) has border aubexp<sup>j</sup> ′ since F(t, j) starts with aube<sup>2</sup> . (⇐) If F(t, j) has a short border of RLE size p ≤ √ m, the border forms aubexp<sup>j</sup> ′ and it holds that exp<sup>j</sup> ′ ≤ e2. Also, exp<sup>j</sup> ′ ≤ e<sup>2</sup> ≤ e<sup>1</sup> holds by the definition of e2. Therefore, T[end<sup>i</sup> ..end<sup>j</sup> ′ ] has border aubexp<sup>j</sup> ′ since T[end<sup>i</sup> ..end<sup>j</sup> ′ ] starts with aube<sup>1</sup> . ⊓⊔

Let t <sup>⋆</sup> = t if min Γ ≤ e1; otherwise, let t <sup>⋆</sup> be the starting position of an occurrence of aub in Dk. Regardless of the value of min Γ, for each 1 ≤ j ≤ √ m, the set of short borders of T[end<sup>i</sup> ..endy+j−1] of RLE size q is equivalent to that of F(t ⋆ , j) for any q < p, since such borders are prefixes of their common prefix au. Also, the RLE size of any short border of T[end<sup>i</sup> ..endy+j−1] is upper bounded by p from the definition of P<sup>i</sup> . To summarize, the set of short borders of T[end<sup>i</sup> ..endy+j−1] is equivalent to the set of short borders of F(t ⋆ , j) of RLE size at most p − 1 if min Γ > e1; otherwise, it is equivalent to the set of short borders of F(t ⋆ , j) of RLE size at most p by Lemma [8.](#page-7-2) √

Next, for 1 ≤ j ≤ m, let us consider the short borders of T[beg<sup>i</sup> ..end<sup>j</sup> ′ ] where j ′ = y+j−1. A short border of T[beg<sup>i</sup> ..end<sup>j</sup> ′ ] can be obtained by extending a short border of T[end<sup>i</sup> ..end<sup>j</sup> ′ ] to the left by exp<sup>i</sup> − 1 characters. Consider all the short borders B1, B2, . . . , B<sup>g</sup> of T[end<sup>i</sup> ..end<sup>j</sup> ′ ], which satisfy that r(Bs) ≤ min{p, <sup>√</sup> m} for all s. Note that all such borders are also borders of F(t ⋆ , j) as discussed above. Let e<sup>s</sup> be the exponent of the first run of the suffix-occurrence of B<sup>s</sup> for each 1 ≤ s ≤ g. Let E p j ′ be the set of such e<sup>s</sup> for all B1, B2, . . . , Bg. If e<sup>s</sup> < exp<sup>i</sup> for all e<sup>s</sup> ∈ E<sup>p</sup> j ′ , i.e., max E p j ′ < exp<sup>i</sup> , then T[beg<sup>i</sup> ..end<sup>j</sup> ′ ] cannot have a short border. Conversely, if max E p j ′ ≥ exp<sup>i</sup> , then T[beg<sup>i</sup> ..end<sup>j</sup> ′ ] has a short border.

Based on the observations above, we design an algorithm for computing candidatek(i).

Preprocessing. We construct a data structure for ridxx,z(·, ·) by using Lemma [6.](#page-5-1) Next, let us conceptually consider a <sup>√</sup> m × √ m table M<sup>τ</sup> defined as follows: M<sup>τ</sup> [r][j] = ∞ for all r if the first and the last characters of F(τ, j) are the same; otherwise, M<sup>τ</sup> [r][j] stores the maximum exponent among the first runs of the suffix-occurrences of those borders of F(τ, j) whose RLE size is at most r; if there is no such a border, then M<sup>τ</sup> [r][j] = 0 (see also the left part of Fig. [2\)](#page-9-0). Note that we do not explicitly construct such <sup>√</sup> m × √ m tables. The details of their implementation will be described later.

Query. Given a position i, we first compute α = ridxx,z(i, ∞), which satisfies that the lcp of T[end<sup>i</sup> ..n] and T[endα..endz] equals P<sup>i</sup> . Also, we compute e<sup>1</sup> = |P<sup>i</sup> | − |au| and p = r(Pi). If expα+p−<sup>1</sup> = e1, then we set t = α

|   | 10 12 12 ∞ |   |     |   | 12 7 |   | 7 ∞ | 7 | 7 | 7    |        |   |     |   | 12 |   |   |   |   |   |      |  |
|---|------------|---|-----|---|------|---|-----|---|---|------|--------|---|-----|---|----|---|---|---|---|---|------|--|
|   | 9 12 12 ∞  |   |     | 9 | 7    |   | 7 ∞ | 7 | 7 | 7    |        |   |     |   |    |   | 7 |   |   |   |      |  |
|   | 8 12 12 ∞  |   |     | 9 | 7    |   | 5 ∞ | 7 | 7 | 7    |        |   | 12  |   |    | 7 |   |   |   |   |      |  |
|   | 7 12 9 ∞   |   |     | 9 | 5    |   | 5 ∞ | 7 | 7 | 7    | 12     |   |     |   |    |   |   |   |   |   |      |  |
| 6 | 9          |   | 9 ∞ | 9 | 5    |   | 5 ∞ | 7 | 7 | 7    |        |   |     |   |    |   |   |   |   |   |      |  |
| 5 | 9          |   | 9 ∞ | 9 | 5    |   | 5 ∞ | 7 | 7 | 7    | ′<br>𝑝 |   |     |   | 9  |   |   |   |   |   |      |  |
| 4 | 9          |   | 9 ∞ | 5 | 5    |   | 5 ∞ | 7 | 7 | 7    |        |   |     |   |    |   | 5 |   |   |   | 7    |  |
| 3 | 9          |   | 9 ∞ | 5 | 5    |   | 0 ∞ | 7 | 7 | 0    |        |   | 9   |   |    | 5 |   |   |   | 7 |      |  |
| 2 | 9          |   | 0 ∞ | 5 | 0    |   | 0 ∞ | 7 | 0 | 0    |        | 9 |     |   | 5  |   |   |   | 7 |   |      |  |
| 1 | 0          |   | 0 ∞ | 0 | 0    |   | 0 ∞ | 0 | 0 | 0    |        | 0 | 0 ∞ |   | 0  | 0 | 0 | ∞ | 0 | 0 | 0    |  |
|   | 1          | 2 | 3   | 4 | 5    | 6 | 7   | 8 |   | 9 10 |        | 1 | 2   | 3 | 4  | 5 | 6 | 7 | 8 |   | 9 10 |  |

<span id="page-9-0"></span>Fig. 2. Left: An example of table M<sup>τ</sup> . Each column is non-decreasing from bottom to top. The ∞ symbols in the 3rd and 7th columns indicate that the first and last characters of F(τ, 3) and F(τ, 7) are the same, respectively. Right: Line segments corresponding to the runs in all columns of M<sup>τ</sup> . If p ′ = 5 and e = 7, the largest j ⋆ such that M<sup>τ</sup> [p ′ ][j ⋆ ] < e is 6.

since e<sup>2</sup> = e1. Otherwise, we compute β = ridxx,z(α, |P<sup>i</sup> |). Next, we compute L = lcp(T[end<sup>i</sup> ..n], T[endβ..endz]) by calling rlcp(i, exp<sup>i</sup> , β, exp<sup>β</sup> ). If |L| ≤ |au|, then min Γ > e<sup>1</sup> holds and thus we set t = α. Otherwise, we set t = β since e<sup>2</sup> = |L| − |au| ≤ e1. Furthermore, we set p ′ = min{p − 1, √ m} if min Γ > e1; otherwise, set p ′ = min{p, <sup>√</sup> m}. Next, we find the largest j ⋆ such that Mt[p ′ ][j ⋆ ] < exp<sup>i</sup> . If there is no such j ⋆ , candidatek(i) returns ε. Otherwise, it returns T[beg<sup>i</sup> ..endy+<sup>j</sup> <sup>⋆</sup>−1] since T[beg<sup>i</sup> ..end<sup>ι</sup> ] has a short border for all ι with y + j <sup>⋆</sup> − 1 < ι ≤ z, and hence, by Observation [1,](#page-3-1) T[beg<sup>i</sup> ..q] has a short border for all text positions q with begy+<sup>j</sup> <sup>⋆</sup> ≤ q ≤ endz.

Implementing table M<sup>τ</sup> . The remaining task is to efficiently implement M<sup>τ</sup> so that j ⋆ can be found quickly. For each column of a table M<sup>τ</sup> , say jth column, the values are non-decreasing by definition. Also, there are only O(log m) distinct values due to periodicity of borders of T[end<sup>τ</sup> + 1..endz]\$T[beg<sup>x</sup> ..endy+j−2]. Namely, there are O(log m) runs of integers in the column. We define a (vertical) line segment that corresponds to each run, and assign the integer representing a run to each segment as its weight (see Fig. [2\)](#page-9-0). Then we have O( √ m log m) weighted line segments for M<sup>τ</sup> in total. By using such weighted line segments, we can compute, for given p ′ and e, the largest j ⋆ such that M<sup>τ</sup> [p ′ ][j ⋆ ] < e as follows: find the rightmost line segment that intersects the horizontal line r = p ′ and has weight less than e, then j ⋆ is the j-coordinate of the line segment (again, see Fig. [2\)](#page-9-0).

The set S<sup>τ</sup> of such line segments can be computed in O( √ m log m log log m) time by adapting the idea of the construction algorithm for the RLE shortest border array (Lemma [4\)](#page-4-2) as follows: For each prefix of F(τ, z), we enumerate all O(log m) possible exponents of the first runs of the suffix-occurrences of borders, and for each exponent E, compute the minimum RLE size of a border whose first run has exponent E. By sorting these values by their RLE size in ascending order and then scanning their exponents, we can obtain the desired segments.

For each x ≤ τ ≤ z, we construct a data structure of the weighted lowest stabbing query (WLSQ) on S<sup>τ</sup> , where S<sup>τ</sup> is rotated 90 degrees to the right, as defined below:

Definition 1 (Weighted Lowest Stabbing Query; WLSQ). A set S of weighted horizontal segments over N × N grid are given for preprocessing. The query is, given integers v, w1, and w2, to report the lowest segment s such that s is stabbed by vertical line x = v and the weight of s is between w<sup>1</sup> and w2.

Given i, we can obtain j <sup>⋆</sup> by answering WLSQ on S<sup>t</sup> for v = p ′ , w<sup>1</sup> = 0, and w<sup>2</sup> = exp<sup>i</sup> − 1.

Very recently, Akram and Mieno proposed an algorithm for a problem called the 2D top-k stabbing query with weight constraint (Definition 8 in [\[1\]](#page-12-8)), which subsumes WLSQ as a special case. Although not stated explicitly, their data structure can be constructed in O(|S| log<sup>2</sup> |S|) time. We propose a simpler data structure specialized for WLSQ and show that it can be constructed slightly faster, in O(|S| log |S|) time:

<span id="page-10-1"></span>Lemma 9. A set S of segments is given as the input of WLSQ. We can build a data structure of size O(|S| log |S|) in O(|S| log |S|) time that can answer any WLSQ in O(log |S|) time.

Thus, we can implement candidate<sup>k</sup> so that candidatek(i) can be computed in O(log m) time for each i after O( P x≤τ≤z |S<sup>τ</sup> | log |S<sup>τ</sup> |) = O(m log<sup>2</sup> m) time and space preprocessing.

### <span id="page-10-0"></span>4.3 Implementation of rm-long-bordered

We define a new notion called the RLE pseudo period as follows: for a string w of RLE size r, the RLE pseudo period pp(w) of w is the value r − b where b is the RLE size of the border of w. Note that the RLE size p of the prefix (or suffix) of w whose length equals the period of w is not always equal to pp(w), but it holds that p − 1 ≤ pp(w) ≤ p.

Example 2. Consider string w = abaababa of RLE size r = 7. For this string, pp(w) = 4 holds since the border of w is aba of RLE size b = 3. The period of w is 5. On the one hand, the RLE size p<sup>1</sup> of the length-5 prefix abaab of w is 4, and then pp(w) = p<sup>1</sup> holds. On the other hand, the RLE size p<sup>2</sup> of the length-5 suffix ababa of w is 5, and then pp(w) = p<sup>2</sup> − 1 holds.

![](_page_11_Figure_1.jpeg)

<span id="page-11-1"></span>Fig. 3. String c ∈ C<sup>j</sup> is the candidate for an unbordered factor that ends at end<sup>j</sup> we focus on. (1) The lcs of T[1..end<sup>j</sup> ] and the prefix T[1..ζ1] of T that ends at the leftmost occurrence of S<sup>j</sup> in the figure does not reach the starting position of c. We cannot yet determine whether c is bordered. (2) The lcs of T[1..end<sup>j</sup> ] and the prefix T[1..ζ2] of T that ends at the second leftmost occurrence of S<sup>j</sup> in this figure reaches the starting position of c, which reveals that c is bordered.

For each j > <sup>√</sup> m, let S<sup>j</sup> be the longer string within (1) the shortest suffix of \$T[1..end<sup>j</sup> ] whose RLE pseudo period is greater than <sup>√</sup> m/2 − 1, and (2) T[begj<sup>−</sup> <sup>√</sup>m+1..end<sup>j</sup> ]. Note that S<sup>j</sup> is well-defined since the RLE pseudo period of \$T[1..end<sup>j</sup> ] must be greater than <sup>√</sup> m/<sup>2</sup> <sup>−</sup> <sup>1</sup> for j > <sup>√</sup> m.

<span id="page-11-2"></span>Lemma 10. If the shortest border of T[beg<sup>i</sup> ..end<sup>j</sup> ] is a long border, then S<sup>j</sup> is a suffix of each border of T[beg<sup>i</sup> ..end<sup>j</sup> ].

Proof. Let B be the shortest border of T[beg<sup>i</sup> ..end<sup>j</sup> ]. Since B is unbordered, the pseudo period of <sup>B</sup> equals the RLE size of <sup>B</sup>, which is greater than <sup>√</sup> m. Thus, |S<sup>j</sup> | ≤ |B| holds, and thus S<sup>j</sup> is a suffix of B. Therefore, S<sup>j</sup> is a suffix of each border of T[beg<sup>i</sup> ..end<sup>j</sup> ]. ⊓⊔

<span id="page-11-3"></span>Lemma 11. The number of occurrences of S<sup>j</sup> in T is in O( √ m).

<span id="page-11-0"></span>Lemma 12. Given j > <sup>√</sup> m, string S<sup>j</sup> and its all occurrences can be computed in O( √ m log m) time after O(m log m) time preprocessing.

Preprocessing We construct the data structure of Lemma [12.](#page-11-0)

Query algorithm Again, let us consider the kth stage and let x = Jk−1.first, y = Jk.first, and z = Jk.last. D<sup>k</sup> = T[beg<sup>x</sup> ..endz] and J<sup>k</sup> = T[beg<sup>y</sup> ..endz]. For each j with y ≤ j ≤ z, we compute S<sup>j</sup> and its occurrences, and sort them by using Lemma [12.](#page-11-0) Let L<sup>j</sup> be the sorted list of occurrences of S<sup>j</sup> . Given a set C of candidates for the longest unbordered factors, we first radix sort the elements of C using their starting points as the primary key and their ending points as the secondary key. Let C ′ be the sorted list of the elements of C. In the following, we scan elements in C ′ in order throughout the algorithm. We denote by C<sup>j</sup> the list of elements in C ′ whose end positions are end<sup>j</sup> . Then, C<sup>j</sup> is a consecutive sub-list of C ′ from the condition of the radix sorting. For every j with y ≤ j ≤ z, we execute the following, scanning C<sup>j</sup> and L<sup>j</sup> from left to right: Let variables c and occ store elements in C<sup>j</sup> and L<sup>j</sup> we focus on, respectively. By using the data structure of Lemma [5](#page-5-2) for the reversal of T, compute the longest common suffix (lcs) of T[1..end<sup>j</sup> ] and the T[1..ζ] where ζ is the ending position of occ (see Fig. [3\)](#page-11-1).

- If the lcs does not reach the starting position of c, then update occ to the next element in L<sup>j</sup> . If such an element in L<sup>j</sup> does not exists, then the current c is the longest string in C<sup>j</sup> that has no long border by Lemma [10.](#page-11-2)
- If the lcs reaches the starting position of c, then c is bordered and hence update c to the next element in C<sup>j</sup> that starts after ζ. If such an element in C<sup>j</sup> does not exists, there is no unbordered factor in C<sup>j</sup> . So we update c to the next element in C ′ and increment j accordingly.

The query algorithm can be performed in O(|C| log |C| + P y≤j≤z |L<sup>j</sup> |) = O(m log m) time with O(m) working space for each stage k.

Putting all pieces together, we complete the proof of Theorem [1.](#page-5-3)

Acknowledgments. This work was supported by JSPS KAKENHI Grant Number JP24K20734 (TM).

#### References

- <span id="page-12-8"></span>1. Akram, W., Mieno, T.: Sorted consecutive occurrence queries in substrings. In: CPM 2025 (to appear)
- <span id="page-12-2"></span>2. Assous, R., Pouzet, M.: Une caracterisation des mots periodiques. Discret. Math. 25(1), 1–5 (1979). [https://doi.org/10.1016/0012-365X\(79\)90146-8](https://doi.org/10.1016/0012-365X(79)90146-8)
- <span id="page-12-7"></span>3. Bender, M.A., Farach-Colton, M.: The LCA problem revisited. In: LATIN 2000: Theoretical Informatics, 4th Latin American Symposium, Punta del Este, Uruguay, April 10-14, 2000, Proceedings. Lecture Notes in Computer Science, vol. 1776, pp. 88–94. Springer (2000).<https://doi.org/10.1007/10719839\_9>
- <span id="page-12-6"></span>4. Cording, P.H., Gagie, T., Knudsen, M.B.T., Kociumaka, T.: Maximal unbordered factors of random strings. Theor. Comput. Sci. 852, 78–83 (2021). [https://doi.org/](https://doi.org/10.1016/J.TCS.2020.11.019) [10.1016/J.TCS.2020.11.019](https://doi.org/10.1016/J.TCS.2020.11.019)
- <span id="page-12-0"></span>5. Crochemore, M., Mignosi, F., Restivo, A., Salemi, S.: Text compression using antidictionaries. In: Automata, Languages and Programming, 26th International Colloquium, ICALP'99, Prague, Czech Republic, July 11-15, 1999, Proceedings. Lecture Notes in Computer Science, vol. 1644, pp. 261–270. Springer (1999). <https://doi.org/10.1007/3-540-48523-6\_23>
- <span id="page-12-3"></span>6. Duval, J.: Relationship between the period of a finite word and the length of its unbordered segments. Discret. Math. 40(1), 31–44 (1982). [https://doi.org/10.](https://doi.org/10.1016/0012-365X(82)90186-8) [1016/0012-365X\(82\)90186-8](https://doi.org/10.1016/0012-365X(82)90186-8)
- <span id="page-12-4"></span>7. Duval, J., Harju, T., Nowotka, D.: Unbordered factors and lyndon words. Discret. Math. 308(11), 2261–2264 (2008).<https://doi.org/10.1016/J.DISC.2006.09.054>
- <span id="page-12-5"></span>8. Duval, J., Lecroq, T., Lefebvre, A.: Linear computation of unbordered conjugate on unordered alphabet. Theor. Comput. Sci. 522, 77–84 (2014). [https://doi.org/](https://doi.org/10.1016/J.TCS.2013.12.008) [10.1016/J.TCS.2013.12.008](https://doi.org/10.1016/J.TCS.2013.12.008)
- <span id="page-12-1"></span>9. Ehrenfeucht, A., Silberger, D.M.: Periodicity and unbordered segments of words. Discret. Math. 26(2), 101–109 (1979). [https://doi.org/10.1016/0012-365X\(79\)](https://doi.org/10.1016/0012-365X(79)90116-X) [90116-X](https://doi.org/10.1016/0012-365X(79)90116-X)
- <span id="page-12-9"></span>10. Fine, N.J., Wilf, H.S.: Uniqueness theorems for periodic functions. Proceedings of the American Mathematical Society 16(1), 109–114 (1965)

- 14 S. Sekizaki and T. Mieno
- <span id="page-13-8"></span>11. Gawrychowski, P., Kucherov, G., Sach, B., Starikovskaya, T.: Computing the longest unbordered substring. In: String Processing and Information Retrieval - 22nd International Symposium, SPIRE 2015, London, UK, September 1-4, 2015, Proceedings. Lecture Notes in Computer Science, vol. 9309, pp. 246–257. Springer (2015).<https://doi.org/10.1007/978-3-319-23826-5\_24>
- <span id="page-13-3"></span>12. Harju, T., Nowotka, D.: Minimal Duval extensions. Int. J. Found. Comput. Sci. 15(2), 349–354 (2004).<https://doi.org/10.1142/S0129054104002467>
- <span id="page-13-5"></span>13. Harju, T., Nowotka, D.: Periodicity and unbordered words: A proof of the extended duval conjecture. J. ACM 54(4), 20 (2007). [https://doi.org/10.1145/1255443.](https://doi.org/10.1145/1255443.1255448) [1255448](https://doi.org/10.1145/1255443.1255448)
- <span id="page-13-4"></span>14. Holub, S.: A proof of the extended Duval's conjecture. Theor. Comput. Sci. 339(1), 61–67 (2005).<https://doi.org/10.1016/J.TCS.2005.01.008>
- <span id="page-13-6"></span>15. Holub, S., Nowotka, D.: The ehrenfeucht-silberger problem. J. Comb. Theory A 119(3), 668–682 (2012).<https://doi.org/10.1016/J.JCTA.2011.11.004>
- <span id="page-13-0"></span>16. Knuth, D.E., Jr., J.H.M., Pratt, V.R.: Fast pattern matching in strings. SIAM J. Comput. 6(2), 323–350 (1977).<https://doi.org/10.1137/0206024>
- <span id="page-13-9"></span>17. Kociumaka, T., Kundu, R., Mohamed, M., Pissis, S.P.: Longest unbordered factor in quasilinear time. In: 29th International Symposium on Algorithms and Computation, ISAAC 2018, December 16-19, 2018, Jiaoxi, Yilan, Taiwan. LIPIcs, vol. 123, pp. 70:1–70:13. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2018). <https://doi.org/10.4230/LIPICS.ISAAC.2018.70>
- <span id="page-13-10"></span>18. Kociumaka, T., Radoszewski, J., Rytter, W., Walen, T.: Internal pattern matching queries in a text and applications. SIAM J. Comput. 53(5), 1524–1577 (2024). <https://doi.org/10.1137/23M1567618>
- <span id="page-13-7"></span>19. Loptev, A., Kucherov, G., Starikovskaya, T.: On maximal unbordered factors. In: Combinatorial Pattern Matching - 26th Annual Symposium, CPM 2015, Ischia Island, Italy, June 29 - July 1, 2015, Proceedings. Lecture Notes in Computer Science, vol. 9133, pp. 343–354. Springer (2015). [https://doi.org/10.1007/](https://doi.org/10.1007/978-3-319-19929-0\_29) [978-3-319-19929-0\\_29](https://doi.org/10.1007/978-3-319-19929-0\_29)
- <span id="page-13-1"></span>20. Margaritis, D., Skiena, S.: Reconstructing strings from substrings in rounds. In: 36th Annual Symposium on Foundations of Computer Science, Milwaukee, Wisconsin, USA, 23-25 October 1995. pp. 613–620. IEEE Computer Society (1995). <https://doi.org/10.1109/SFCS.1995.492591>
- <span id="page-13-2"></span>21. Mignosi, F., Zamboni, L.Q.: A note on a conjecture of Duval and Sturmian words. RAIRO Theor. Informatics Appl. 36(1), 1–3 (2002). [https://doi.org/10.1051/ITA:](https://doi.org/10.1051/ITA:2002001) [2002001](https://doi.org/10.1051/ITA:2002001)
- <span id="page-13-12"></span>22. Mitani, K., Mieno, T., Seto, K., Horiyama, T.: Shortest cover after edit. In: 35th Annual Symposium on Combinatorial Pattern Matching, CPM 2024, June 25-27, 2024, Fukuoka, Japan. LIPIcs, vol. 296, pp. 24:1–24:15. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2024).<https://doi.org/10.4230/LIPICS.CPM.2024.24>
- <span id="page-13-13"></span>23. Tamakoshi, Y., Goto, K., Inenaga, S., Bannai, H., Takeda, M.: An opportunistic text indexing structure based on run length encoding. In: Algorithms and Complexity - 9th International Conference, CIAC 2015, Paris, France, May 20-22, 2015. Proceedings. Lecture Notes in Computer Science, vol. 9079, pp. 390–402. Springer (2015).<https://doi.org/10.1007/978-3-319-18173-8\_29>

### <span id="page-13-11"></span>A Omitted proofs

Proof (of Lemma [5\)](#page-5-2). Suppose that an RLE-compressed string rle(T) of RLE size m is given. In the preprocessing phase, we construct length-m arrays tRLESA, tRLEISA, and tRLELCP of string T, defined as follows: The truncated RLE suffix array tRLESA of T is the integer array such that tRLESA[r] = k iff the rth lexicographically smallest suffix among S = {T[endx..n] | 1 ≤ x ≤ m} is T[endk..n]. For convenience, we denote by T⟨r⟩ = T[endtRLESA[r] ..n] the rth lexicographically smallest suffix among S. The truncated RLE inverse suffix array tRLEISA of T is the integer array such that tRLEISA[k] = r iff tRLESA[r] = k. The truncated RLE longest common prefix array tRLELCP of T is the integer array such that tRLELCP[1] = −1 and tRLELCP[r] = lcp(T⟨r⟩, T⟨r − 1⟩) for 2 ≤ r ≤ m. We further construct an RmQ (range minimum query) data structure on tRLELCP. Given query integers i, p, j, and q, we first compare expi−p+1 and exp<sup>j</sup> −q+1. If they are not equal, the lcp value is the minimum of those values. Otherwise, let r<sup>1</sup> = min{tRLEISA[i],tRLEISA[j]} and r<sup>2</sup> = max{tRLEISA[i],tRLEISA[j]}. Then, the lcp value to return is exp<sup>i</sup> − p + min{tRLELCP[r] | r<sup>1</sup> + 1 ≤ r ≤ r2}, which can be computed in O(1) time by answering RmQ on tRLELCP. ⊓⊔

Proof (of Lemma [6\)](#page-5-1). Given rle(T) of RLE size m and integers x, y, we consider string T ′ = T\$T[beg<sup>x</sup> ..endy] whose RLE size is at most 2m + 1. Then, if a string occurs within T[beg<sup>x</sup> ..endy], then it also occurs at position p > n + 1 in T ′ . As in the proof of Lemma [5,](#page-5-2) we construct three arrays of T ′ and RmQ data structure on tRLELCP. In addition, we construct an RMQ (range maximum query) data structure on tRLESA. Given query integers h and ℓ, we first obtain r<sup>h</sup> = tRLEISA[h]. Then, we compute the maximal range [r1, r2] ⊂ [1, m] such that lcp(T⟨r1⟩, T⟨rh⟩) ≥ ℓ + 1 and lcp(T⟨rh⟩, T⟨r2⟩) ≥ ℓ + 1 hold. The range [r1, r2] can be computed in O(log m) time by combining binary search and RmQ on tRLELCP. Next, we compute the maximum value r<sup>3</sup> ∈ [1, r<sup>1</sup> − 1] such that lcp(T⟨r3⟩, T⟨rh⟩) ≤ ℓ and tRLESA[r3] ≥ m + 2. The value r<sup>3</sup> can be computed in O(log m) time by combining binary search and RMQ on tRLESA in range [1, r<sup>1</sup> − 1]. Similarly, we compute the minimum value r<sup>4</sup> ∈ [r<sup>2</sup> + 1, m] such that lcp(T⟨rh⟩, T⟨r4⟩) ≤ ℓ and tRLESA[r4] ≥ m + 2 in O(log m) time. Finally, we return tRLESA[r ⋆ ] where r <sup>⋆</sup> = arg maxr∈{r3,r4}{lcp(T⟨r⟩, T⟨rh⟩)}. ⊓⊔

Proof (of Lemma [7\)](#page-7-1). (1) Consider the case where there is an unbordered (i, k) factor, and let U be the longest unbordered (i, k)-factor. For the sake of contradiction, assume that U is shorter than candidatek(i). Then, candidatek(i) has a long border since it has no short border. However, the suffix-occurrence of the long border starts before <sup>J</sup><sup>k</sup> since <sup>r</sup>(Jk) = <sup>√</sup> m, which contradicts that U is unbordered. Thus, candidatek(i) is the longest unbordered (i, k)-factor in this case. (2) If all (i, k)-factors have short borders, then candidatek(i) returns ε by definition. (3) Otherwise, i.e., all (i, k)-factors have some borders. By definition, candidatek(i) has no short border, thus it must have a long border. ⊓⊔

Proof (of Lemma [9\)](#page-10-1). In the preprocessing phase, we first sort the segments by their weights. Then, we construct the segment tree of S with N leaves by inserting segments in the sorted order. Each segment stored in a node is represented as a tuple (w, y, id) where w is the weight of the segment, y is the y-coordinate of the segment, and id is the unique id of the segment in S. The resulting segment tree satisfies the condition that segments stored in each node are sorted by their

#### 16 S. Sekizaki and T. Mieno

weights. Subsequently, for each node of the segment tree, we build an RmQ data structure for the list of y-coordinates stored in the node. Lastly, we apply the fractional cascading to the series of tuples over the segment tree, using weight w as the key.

Given a query (v, w1, w2), we first find the path π from the root to the leaf that corresponds to v in the segment tree. We then traverse π starting from the root. At each node u ∈ π, we compute the range corresponding to [w1, w2] in the list of tuples in u by using the fractional cascading structure, and compute the smallest y-coordinate within the range by using the RmQ data structure. At the end, we output the id that corresponds to the smallest y-coordinate within the minima.

The size of the data structure is O(|S| log |S|), which is dominated by the segment tree. The construction time is O(|S| log |S|): sorting the segments takes O(|S| log |S|) time, building the segment tree requires O(|S| log |S|) time, and constructing the RmQ data structures and applying fractional cascading take time linear in the total size of the lists, i.e., O(|S| log |S|). Given a query, we first find the root-to-leaf path π of length O(log |S|). Detecting all the ranges corresponding to [w1, w2] over the lists in π can be done in O(log |S|) time thanks to fractional cascading. We then perform an O(1)-time RmQ |π| times, which takes O(log |S|) time. Thus, the query time is O(log |S|) in total. ⊓⊔

Proof (of Lemma [11\)](#page-11-3). Since the pseudo period pp of <sup>S</sup><sup>j</sup> is greater than <sup>√</sup> m/2−1, the RLE size of the overlap of any two occurrences of S<sup>j</sup> is at most r(S<sup>j</sup> )−pp < r(S<sup>j</sup> ) − √ m/2 + 1. Thus, the lemma holds. ⊓⊔

Proof (of Lemma [12\)](#page-11-0). We first compute the RLE pseudo period π of T[begj<sup>−</sup> <sup>√</sup>m+1..end<sup>j</sup> ] in O( √ <sup>m</sup> log <sup>m</sup>) time. If π > <sup>√</sup> m/2 − 1, then S<sup>j</sup> = T[begj<sup>−</sup> <sup>√</sup>m+1..end<sup>j</sup> ]. Otherwise, we compute the longest suffix T[s..end<sup>j</sup> ] of T[1..end<sup>j</sup> ] whose RLE pseudo period is π by computing the longest common suffix of T[1..endj<sup>−</sup> <sup>√</sup><sup>m</sup> and T[1..ι] where ι is the ending position of the prefixoccurrence of the border of T[begj<sup>−</sup> <sup>√</sup>m+1..end<sup>j</sup> ]. Such suffix can be computed by using the lcp data structure of Lemma [5](#page-5-2) for the reversal of T. If s = 1, then we have S<sup>j</sup> = \$T[1..end<sup>j</sup> ]. Otherwise, we show the following claim:

Claim. The RLE pseudo period <sup>ψ</sup> of <sup>T</sup>[<sup>s</sup> <sup>−</sup> <sup>1</sup>..end<sup>j</sup> ] is greater than <sup>√</sup> m/2 − 1.

Proof (of Claim). Now we consider the RLE pseudo period ψ of T[s − 1..end<sup>j</sup> ] which satisfies ψ > π. For the sake of contradiction, we assume that ψ ≤ √ m/2− 1 holds. Then, it holds that π + 1 +ψ + 1 < √ m ≤ r(T[s..end<sup>j</sup> ]) since ψ > π. Let p and q be the periods of T[s..end<sup>j</sup> ] and T[s − 1..end<sup>j</sup> ], respectively. Further, let π ′ and ψ ′ be the RLE sizes of T[s..s+p−1] and T[s..s+q−1], respectively. Then, π ′ ≤ π + 1 and ψ ′ ≤ ψ ′ + 1 hold by the definition of RLE pseudo borders. Thus, we obtain π ′ + ψ ′ ≤ π + 1 + ψ + 1 < r(T[s..end<sup>j</sup> ]). Therefore, p + q < |T[s..end<sup>j</sup> ]| holds. From the periodicity lemma [\[10\]](#page-12-9), gcd(p, q) is a period of T[s..end<sup>j</sup> ] where gcd(p, q) is the greatest common diviser of p and q. Since p is the smallest period of T[s..end<sup>j</sup> ], q is a multiple of p. Then, T[s−1..end<sup>j</sup> ] also has period p. However, the RLE pseudo period of T[s − 1..end<sup>j</sup> ] is π, which contradicts the definition of s. ⊓⊔ Namely, S<sup>j</sup> = T[s − 1..end<sup>j</sup> ] holds if s ≥ 2. Finally, we compute each occurrence of S<sup>j</sup> in O(occ +log m) time by using the index structure based on tRLESA [\[23\]](#page-13-13), where occ is the number of occurrences of S<sup>j</sup> in T. The total running time is O( √ m log m) since occ = O( √ m) by Lemma [11.](#page-11-3) ⊓⊔